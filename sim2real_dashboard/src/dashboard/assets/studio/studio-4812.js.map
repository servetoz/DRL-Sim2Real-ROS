{"version":3,"file":"studio-4812.js","mappings":"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","sources":["webpack:///../../packages/comlink-transfer-handlers/src/abortSignalTransferHandler.ts","webpack:///../../packages/log/src/index.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/IteratorCursor.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/WorkerIterableSourceWorker.ts","webpack:///../../packages/studio-base/src/util/FetchReader.ts","webpack:///../../packages/studio-base/src/util/isDesktopApp.ts","webpack:///../../packages/studio-base/src/util/BrowserHttpReader.ts","webpack:///../../packages/studio-base/src/util/ranges.ts","webpack:///../../packages/studio-base/src/util/VirtualLRUBuffer.ts","webpack:///../../packages/studio-base/src/util/getNewConnection.ts","webpack:///../../packages/studio-base/src/util/CachedFilelike.ts"],"sourcesContent":["// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { TransferHandler } from \"comlink\";\n\nconst isAbortSignal = (val: unknown): val is AbortSignal => val instanceof AbortSignal;\n\n/**\n * abortSignalTransferHandler implements a Comlink TransferHandler for AbortSignal instances\n *\n * Serialize creates an array with a boolean for whether the signal is already aborted and a message\n * port to send an abort signal.\n *\n * Deserialize creates a new abort controller and aborts it when the abort message is sent over the\n * message port.\n *\n * Reference: https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\n */\nconst abortSignalTransferHandler: TransferHandler<AbortSignal, [boolean, MessagePort]> = {\n  canHandle: isAbortSignal,\n  deserialize: ([aborted, msgPort]) => {\n    const controller = new AbortController();\n\n    if (aborted) {\n      controller.abort();\n    } else {\n      msgPort.onmessage = () => {\n        controller.abort();\n      };\n    }\n\n    return controller.signal;\n  },\n  serialize: (abortSignal) => {\n    const { port1, port2 } = new MessageChannel();\n    abortSignal.addEventListener(\"abort\", () => {\n      port1.postMessage(\"aborted\");\n    });\n\n    return [[abortSignal.aborted, port2], [port2]];\n  },\n};\n\nexport { abortSignalTransferHandler };\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\n// logger channel -> logger\nconst channels = new Map<string, Logger>();\n\nconst noop = () => {};\n\ntype LogLevel = \"error\" | \"warn\" | \"info\" | \"debug\";\n\nclass Logger {\n  // default logger has an empty name\n  public static default = new Logger(\"\");\n\n  #name: string;\n\n  // all new loggers are created from the default logger\n  private constructor(name: string) {\n    this.#name = name;\n    this.setLevel(\"debug\");\n    channels.set(name, this);\n  }\n\n  // fully qualified name for the logger\n  public name(): string {\n    return this.#name;\n  }\n\n  /**\n   * Return true if the level would display when logged by the logger\n   */\n  public isLevelOn(level: LogLevel): boolean {\n    switch (level) {\n      case \"debug\":\n        return this.debug !== noop;\n      case \"info\":\n        return this.info !== noop;\n      case \"warn\":\n        return this.warn !== noop;\n      case \"error\":\n        return this.error !== noop;\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @returns the current log level\n   */\n  public getLevel(): LogLevel {\n    if (this.debug !== noop) {\n      return \"debug\";\n    } else if (this.info !== noop) {\n      return \"info\";\n    } else if (this.warn !== noop) {\n      return \"warn\";\n    } else {\n      return \"error\";\n    }\n  }\n\n  /**\n   * Set the allowed log level. Any log calls with severity \"below\" this one will be ignored.\n   *\n   * i.e. setting a level of \"warn\" will ignore any \"info\" or \"debug\" logs\n   */\n  public setLevel(level: LogLevel): void {\n    this.debug = noop;\n    this.info = noop;\n    this.warn = noop;\n    this.error = noop;\n\n    switch (level) {\n      case \"debug\":\n        this.debug = console.debug.bind(global.console);\n        this.info = console.info.bind(global.console);\n        this.warn = console.warn.bind(global.console);\n        this.error = console.error.bind(global.console);\n        break;\n      case \"info\":\n        this.info = console.info.bind(global.console);\n        this.warn = console.warn.bind(global.console);\n        this.error = console.error.bind(global.console);\n        break;\n      case \"warn\":\n        this.warn = console.warn.bind(global.console);\n        this.error = console.error.bind(global.console);\n        break;\n      case \"error\":\n        this.error = console.error.bind(global.console);\n        break;\n    }\n  }\n\n  public debug(..._args: unknown[]): void {}\n  public info(..._args: unknown[]): void {}\n  public warn(..._args: unknown[]): void {}\n  public error(..._args: unknown[]): void {}\n\n  // create a new logger under this logger's namespace\n  public getLogger(name: string): Logger {\n    const shortName = name.replace(/^.+\\.(asar|webpack)[\\\\/\\\\]/, \"\").replace(/^(\\.\\.\\/)+/, \"\");\n    const channelName = this.#name.length > 0 ? `${this.#name}.${shortName}` : shortName;\n    const existing = channels.get(channelName);\n    if (existing) {\n      return existing;\n    }\n\n    const logger = new Logger(channelName);\n    channels.set(channelName, logger);\n    return logger;\n  }\n\n  // get all logging channels\n  public channels(): Logger[] {\n    return Array.from(channels.values());\n  }\n}\n\nfunction toLogLevel(maybeLevel: string): LogLevel {\n  switch (maybeLevel) {\n    case \"debug\":\n      return \"debug\";\n    case \"info\":\n      return \"info\";\n    case \"warn\":\n      return \"warn\";\n    case \"error\":\n      return \"error\";\n    default:\n      return \"warn\";\n  }\n}\n\nexport default Logger.default;\nexport { Logger, toLogLevel };\nexport type { LogLevel };\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { compare, add as addTime } from \"@foxglove/rostime\";\nimport { Time } from \"@foxglove/studio\";\n\nimport type { IMessageCursor, IteratorResult } from \"./IIterableSource\";\n\nconst TIME_ZERO = Object.freeze({ sec: 0, nsec: 0 });\n\n/// IteratorCursor implements a IMessageCursor interface on top of an AsyncIterable\nclass IteratorCursor implements IMessageCursor {\n  #iter: AsyncIterableIterator<Readonly<IteratorResult>>;\n  // readUntil reads from the iterator inclusive of end time. To do this, it reads from the iterator\n  // until it receives a receiveTime after end time to signal it has received all the messages\n  // inclusive of end time. Since iterators are read once, this last result must be stored for the\n  // next readUntil call otherwise it would be lost.\n  #lastIteratorResult?: IteratorResult;\n  #abort?: AbortSignal;\n\n  public constructor(\n    iterator: AsyncIterableIterator<Readonly<IteratorResult>>,\n    abort?: AbortSignal,\n  ) {\n    this.#iter = iterator;\n    this.#abort = abort;\n  }\n\n  public async next(): ReturnType<IMessageCursor[\"next\"]> {\n    if (this.#abort?.aborted === true) {\n      return undefined;\n    }\n\n    const result = await this.#iter.next();\n    return result.value;\n  }\n\n  public async nextBatch(durationMs: number): Promise<IteratorResult[] | undefined> {\n    const firstResult = await this.next();\n    if (!firstResult) {\n      return undefined;\n    }\n\n    if (firstResult.type === \"problem\") {\n      return [firstResult];\n    }\n\n    const results: IteratorResult[] = [firstResult];\n\n    let cutoffTime: Time = TIME_ZERO;\n    switch (firstResult.type) {\n      case \"stamp\":\n        cutoffTime = addTime(firstResult.stamp, { sec: 0, nsec: durationMs * 1e6 });\n        break;\n      case \"message-event\":\n        cutoffTime = addTime(firstResult.msgEvent.receiveTime, { sec: 0, nsec: durationMs * 1e6 });\n        break;\n    }\n\n    for (;;) {\n      const result = await this.next();\n      if (!result) {\n        return results;\n      }\n\n      results.push(result);\n\n      if (result.type === \"problem\") {\n        break;\n      }\n      if (result.type === \"stamp\" && compare(result.stamp, cutoffTime) > 0) {\n        break;\n      }\n      if (result.type === \"message-event\" && compare(result.msgEvent.receiveTime, cutoffTime) > 0) {\n        break;\n      }\n    }\n    return results;\n  }\n\n  public async readUntil(end: Time): ReturnType<IMessageCursor[\"readUntil\"]> {\n    // Assign to a variable to fool typescript control flow analysis which does not understand\n    // that this value could change after the _await_\n    const isAborted = this.#abort?.aborted;\n    if (isAborted === true) {\n      return undefined;\n    }\n\n    const results: IteratorResult[] = [];\n\n    // if the last result is still past end time, return empty results\n    if (\n      this.#lastIteratorResult?.type === \"stamp\" &&\n      compare(this.#lastIteratorResult.stamp, end) >= 0\n    ) {\n      return results;\n    }\n\n    if (\n      this.#lastIteratorResult?.type === \"message-event\" &&\n      compare(this.#lastIteratorResult.msgEvent.receiveTime, end) > 0\n    ) {\n      return results;\n    }\n\n    if (this.#lastIteratorResult) {\n      results.push(this.#lastIteratorResult);\n      this.#lastIteratorResult = undefined;\n    }\n\n    for (;;) {\n      const result = await this.#iter.next();\n      if (this.#abort?.aborted === true) {\n        return undefined;\n      }\n\n      if (result.done === true) {\n        break;\n      }\n\n      const value = result.value;\n      if (value.type === \"stamp\" && compare(value.stamp, end) >= 0) {\n        this.#lastIteratorResult = value;\n        break;\n      }\n      if (value.type === \"message-event\" && compare(value.msgEvent.receiveTime, end) > 0) {\n        this.#lastIteratorResult = value;\n        break;\n      }\n      results.push(value);\n    }\n\n    return results;\n  }\n\n  public async end(): ReturnType<IMessageCursor[\"end\"]> {\n    await this.#iter.return?.();\n  }\n}\n\nexport { IteratorCursor };\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport * as Comlink from \"comlink\";\n\nimport { abortSignalTransferHandler } from \"@foxglove/comlink-transfer-handlers\";\nimport { MessageEvent } from \"@foxglove/studio\";\n\nimport type {\n  GetBackfillMessagesArgs,\n  IIterableSource,\n  IMessageCursor,\n  Initalization,\n  IteratorResult,\n  MessageIteratorArgs,\n} from \"./IIterableSource\";\nimport { IteratorCursor } from \"./IteratorCursor\";\n\nexport class WorkerIterableSourceWorker implements IIterableSource {\n  protected _source: IIterableSource;\n\n  public constructor(source: IIterableSource) {\n    this._source = source;\n  }\n\n  public async initialize(): Promise<Initalization> {\n    return await this._source.initialize();\n  }\n\n  public messageIterator(\n    args: MessageIteratorArgs,\n  ): AsyncIterableIterator<Readonly<IteratorResult>> & Comlink.ProxyMarked {\n    return Comlink.proxy(this._source.messageIterator(args));\n  }\n\n  public async getBackfillMessages(\n    args: Omit<GetBackfillMessagesArgs, \"abortSignal\">,\n    // abortSignal is a separate argument so it can be proxied by comlink since AbortSignal is not\n    // clonable (and needs to signal across the worker boundary)\n    abortSignal?: AbortSignal,\n  ): Promise<MessageEvent[]> {\n    return await this._source.getBackfillMessages({\n      ...args,\n      abortSignal,\n    });\n  }\n\n  public getMessageCursor(\n    args: Omit<MessageIteratorArgs, \"abort\">,\n    abort?: AbortSignal,\n  ): IMessageCursor & Comlink.ProxyMarked {\n    const iter = this._source.messageIterator(args);\n    const cursor = new IteratorCursor(iter, abort);\n    return Comlink.proxy(cursor);\n  }\n}\n\nComlink.transferHandlers.set(\"abortsignal\", abortSignalTransferHandler);\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\nimport { EventEmitter } from \"eventemitter3\";\n\ntype EventTypes = {\n  data: (chunk: Uint8Array) => void;\n  end: () => void;\n  error: (err: Error) => void;\n};\n\n// An event-emitting wrapper for the Streams API:\n// https://developer.mozilla.org/en-US/docs/Web/API/Streams_API\nexport default class FetchReader extends EventEmitter<EventTypes> {\n  #response: Promise<Response>;\n  #reader?: ReadableStreamDefaultReader<Uint8Array>;\n  #controller: AbortController;\n  #aborted: boolean = false;\n  #url: string;\n\n  public constructor(url: string, options?: RequestInit) {\n    super();\n    this.#url = url;\n    this.#controller = new AbortController();\n    this.#response = fetch(url, { ...options, signal: this.#controller.signal });\n  }\n\n  // you can only call getReader once on a response body\n  // so keep a local copy of the reader and return it after the first call to get a reader\n  async #getReader(): Promise<ReadableStreamDefaultReader<Uint8Array> | undefined> {\n    if (this.#reader) {\n      return this.#reader;\n    }\n    let data: Response;\n    try {\n      data = await this.#response;\n    } catch (err) {\n      this.emit(\"error\", new Error(`GET <${this.#url}> failed: ${err}`));\n      return undefined;\n    }\n    if (!data.ok) {\n      const errMsg = data.statusText;\n      this.emit(\n        \"error\",\n        new Error(\n          `GET <$${this.#url}> failed with status ${data.status}${errMsg ? ` (${errMsg})` : ``}`,\n        ),\n      );\n      return undefined;\n    }\n\n    if (!data.body) {\n      this.emit(\"error\", new Error(`GET <${this.#url}> succeeded, but returned no data`));\n      return undefined;\n    }\n\n    // The fetch succeeded, but there might still be an error streaming.\n    try {\n      // When a stream is closed or errors, any reader it is locked to is released.\n      // If the getReader method is called on an already locked stream, an exception will be thrown.\n      // This is caused by server-side errors, but we should catch it anyway.\n      this.#reader = data.body.getReader();\n    } catch (err) {\n      this.emit(\"error\", new Error(`GET <${this.#url}> succeeded, but failed to stream`));\n      return undefined;\n    }\n\n    return this.#reader;\n  }\n\n  public read(): void {\n    this.#getReader()\n      .then((reader) => {\n        // if no reader is returned then we've encountered an error\n        if (!reader) {\n          return;\n        }\n        reader\n          .read()\n          .then(({ done, value }) => {\n            // no more to read, signal stream is finished\n            if (done) {\n              this.emit(\"end\");\n              return;\n            }\n            this.emit(\"data\", value);\n            this.read();\n          })\n          .catch((unk) => {\n            // canceling the xhr request causes the promise to reject\n            if (this.#aborted) {\n              this.emit(\"end\");\n              return;\n            }\n            const err = unk instanceof Error ? unk : new Error(unk as string);\n            this.emit(\"error\", err);\n          });\n      })\n      .catch((unk) => {\n        const err = unk instanceof Error ? unk : new Error(unk as string);\n        this.emit(\"error\", err);\n      });\n  }\n\n  public destroy(): void {\n    this.#aborted = true;\n    this.#controller.abort();\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nexport default function isDesktopApp(): boolean {\n  return Boolean((global as unknown as { desktopBridge: unknown }).desktopBridge);\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\n\nimport { FileReader, FileStream } from \"@foxglove/studio-base/util/CachedFilelike\";\nimport FetchReader from \"@foxglove/studio-base/util/FetchReader\";\nimport isDesktopApp from \"@foxglove/studio-base/util/isDesktopApp\";\n\n// A file reader that reads from a remote HTTP URL, for usage in the browser (not for node.js).\nexport default class BrowserHttpReader implements FileReader {\n  #url: string;\n\n  public constructor(url: string) {\n    this.#url = url;\n  }\n\n  public async open(): Promise<{ size: number; identifier?: string }> {\n    let response: Response;\n    try {\n      // Make a GET request and then immediately cancel it. This is more robust than a HEAD request,\n      // since the server might not accept HEAD requests (e.g. when using S3 presigned URLs that\n      // only work for one particular method like GET).\n      // Note that we cannot use `range: \"bytes=0-1\"` or so, because then we can't get the actual\n      // file size without making Content-Range a CORS header, therefore making all this a bit less\n      // robust.\n      // \"no-store\" forces an unconditional remote request. When the browser's cache is populated,\n      // it may add a `range` header to the request, which causes some servers to omit the\n      // `accept-ranges` header in the response.\n      const controller = new AbortController();\n      response = await fetch(this.#url, { signal: controller.signal, cache: \"no-store\" });\n      controller.abort();\n    } catch (error) {\n      let errMsg = `Fetching remote file failed. ${error}`;\n\n      if (!isDesktopApp()) {\n        errMsg +=\n          \"\\n\\nSometimes this is due to a CORS configuration error on the server. Make sure CORS is enabled.\";\n      }\n\n      throw new Error(errMsg);\n    }\n    if (!response.ok) {\n      throw new Error(\n        `Fetching remote file failed. <${this.#url}> Status code: ${response.status}.`,\n      );\n    }\n    if (response.headers.get(\"accept-ranges\") !== \"bytes\") {\n      let errMsg =\n        \"Support for HTTP Range requests was not detected on the remote file.\\n\\nConfirm the resource has an 'Accept-Ranges: bytes' header.\";\n\n      if (!isDesktopApp()) {\n        errMsg +=\n          \"\\n\\nSometimes this is due to a CORS configuration error on the server. Make sure CORS is enabled with Access-Control-Allow-Origin, and that Access-Control-Expose-Headers includes Accept-Ranges.\";\n      }\n\n      throw new Error(errMsg);\n    }\n    const size = response.headers.get(\"content-length\");\n    if (size == undefined) {\n      throw new Error(`Remote file is missing file size. <${this.#url}>`);\n    }\n    return {\n      size: parseInt(size),\n      identifier:\n        response.headers.get(\"etag\") ?? response.headers.get(\"last-modified\") ?? undefined,\n    };\n  }\n\n  public fetch(offset: number, length: number): FileStream {\n    const headers = new Headers({ range: `bytes=${offset}-${offset + (length - 1)}` });\n    const reader = new FetchReader(this.#url, { headers });\n    reader.read();\n    return reader;\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\nimport { complement, intersect, isBefore, isDuring } from \"intervals-fn\";\n\nexport type Range = {\n  /** inclusive */\n  start: number;\n  /** exclusive */\n  end: number;\n};\n\nexport function isRangeCoveredByRanges(\n  queryRange: Range,\n  nonOverlappingMergedAndSortedRanges: Range[],\n): boolean {\n  for (const range of nonOverlappingMergedAndSortedRanges) {\n    if (isBefore(queryRange, range)) {\n      return false;\n    }\n    if (isDuring(queryRange, range)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Get the ranges in `bounds` that are NOT covered by `ranges`.\nexport function missingRanges(bounds: Range, ranges: readonly Range[]): Range[] {\n  // `complement` works in unexpected ways when `ranges` has a range that exceeds `bounds`,\n  // so we first clip `ranges` to `bounds`.\n  return complement(bounds, intersect([bounds], ranges));\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\n\nimport { simplify, substract, unify } from \"intervals-fn\";\n\nimport { isRangeCoveredByRanges, Range } from \"./ranges\";\n\n// VirtualLRUBuffer works similarly to a regular Node.js `Buffer`, but it has some additional features:\n// 1. It can span buffers larger than `buffer.kMaxLength` (typically 2GiB).\n// 2. It can take up much less memory when needed by evicting its least recently used ranges from\n//    memory.\n//\n// This works by allocating multiple smaller buffers underneath, which we call \"blocks\". There are\n// two main operations:\n// - `VirtualLRUBuffer#slice`: works just like `Buffer#slice`, but stitches data together from the\n//    underlying blocks. It throws an error when the underlying data is not currently set, so be\n//    sure to check that first using `VirtualLRUBuffer#hasData`, because the underlying block might\n//    have been evicted.\n// - `VirtualLRUBuffer#copyFrom`: similar to `Buffer#copy`. Will set `VirtualLRUBuffer#hasData` to true\n//    for the range that you copied in, until the data gets evicted through subsequent\n//    `VirtualLRUBuffer#copyFrom` calls.\n//\n// As said above, you can use `VirtualLRUBuffer#hasData` to see if a range can be sliced out. You can\n// also use `VirtualLRUBuffer#getRangesWithData` to get the full list of ranges for which data is set,\n// as an array of `Range` objects with `start` (inclusive) and `end` (exclusive) numbers.\n//\n// Create a new instance by calling `new VirtualLRUBuffer({ size })`. By default this will not do any\n// eviction, and so it will take up `size` bytes of memory.\n//\n// To limit the memory usage, you can pass in a additional options to the constructor: `blockSize`\n// (in bytes) and `numberOfBlocks`. The least recently used block will get evicted when writing to\n// an unallocated block using `VirtualLRUBuffer.copyFrom`.\n\nconst kMaxLength = Math.pow(2, 32);\n\nexport default class VirtualLRUBuffer {\n  public readonly byteLength: number; // How many bytes does this buffer represent.\n  #blocks: Uint8Array[] = []; // Actual `Buffer` for each block.\n  // How many bytes is each block. This used to work up to 2GiB minus a byte, and now seems to crash\n  // past 2GiB minus 4KiB. Default to 1GiB so we don't get caught out next time the limit drops.\n  #blockSize: number = Math.trunc(kMaxLength / 2);\n  #numberOfBlocks: number = Infinity; // How many blocks are we allowed to have at any time.\n  #lastAccessedBlockIndices: number[] = []; // Indexes of blocks, from least to most recently accessed.\n  #rangesWithData: Range[] = []; // Ranges for which we have data copied in (and have not been evicted).\n\n  public constructor(options: { size: number; blockSize?: number; numberOfBlocks?: number }) {\n    this.byteLength = options.size;\n    this.#blockSize = options.blockSize ?? this.#blockSize;\n    this.#numberOfBlocks = options.numberOfBlocks ?? this.#numberOfBlocks;\n  }\n\n  // Check if the range between `start` (inclusive) and `end` (exclusive) fully contains data\n  // copied in through `VirtualLRUBuffer#copyFrom`.\n  public hasData(start: number, end: number): boolean {\n    return isRangeCoveredByRanges({ start, end }, this.#rangesWithData);\n  }\n\n  // Get the minimal number of start-end pairs for which `VirtualLRUBuffer#hasData` will return true.\n  // The array is sorted by `start`.\n  public getRangesWithData(): Range[] {\n    return this.#rangesWithData;\n  }\n\n  // Copy data from the `source` buffer to the byte at `targetStart` in the VirtualLRUBuffer.\n  public copyFrom(source: Uint8Array, targetStart: number): void {\n    if (targetStart < 0 || targetStart >= this.byteLength) {\n      throw new Error(\"VirtualLRUBuffer#copyFrom invalid input\");\n    }\n\n    const range = { start: targetStart, end: targetStart + source.byteLength };\n\n    // Walk through the blocks and copy the data over. If the input buffer is too large we will\n    // currently just evict the earliest copied in data.\n    let position = range.start;\n    while (position < range.end) {\n      const { blockIndex, positionInBlock, remainingBytesInBlock } =\n        this.#calculatePosition(position);\n      copy(source, this.#getBlock(blockIndex), positionInBlock, position - targetStart);\n      position += remainingBytesInBlock;\n    }\n\n    this.#rangesWithData = simplify(unify([range], this.#rangesWithData));\n  }\n\n  // Get a slice of data. Throws if `VirtualLRUBuffer#hasData(start, end)` is false, so be sure to check\n  // that first. Will use an efficient `slice` instead of a copy if all the data happens to\n  // be contained in one block.\n  public slice(start: number, end: number): Uint8Array {\n    const size = end - start;\n    if (start < 0 || end > this.byteLength || size <= 0 || size > kMaxLength) {\n      throw new Error(\"VirtualLRUBuffer#slice invalid input\");\n    }\n    if (!this.hasData(start, end)) {\n      throw new Error(\"VirtualLRUBuffer#slice range has no data set\");\n    }\n\n    const startPositionData = this.#calculatePosition(start);\n    if (size <= startPositionData.remainingBytesInBlock) {\n      // If the entire range that we care about are contained in one block, do an efficient\n      // `Buffer#slice` instead of copying data to a new Buffer.\n      const { blockIndex, positionInBlock } = startPositionData;\n      return this.#getBlock(blockIndex).slice(positionInBlock, positionInBlock + size);\n    }\n\n    const result = new Uint8Array(size);\n    let position = start;\n    while (position < end) {\n      const { blockIndex, positionInBlock, remainingBytesInBlock } =\n        this.#calculatePosition(position);\n      // Note that these calls to `_getBlock` will never cause any eviction, since we verified using\n      // the `VirtualLRUBuffer#hasData` precondition that all these buffers exist already.\n      copy(this.#getBlock(blockIndex), result, position - start, positionInBlock);\n      position += remainingBytesInBlock;\n    }\n    return result;\n  }\n\n  // Get a reference to a block, and mark it as most recently used. Might evict older blocks.\n  #getBlock(index: number): Uint8Array {\n    if (!this.#blocks[index]) {\n      // If a block is not allocated yet, do so.\n      let size = this.#blockSize;\n      if ((index + 1) * this.#blockSize > this.byteLength) {\n        size = this.byteLength % this.#blockSize; // Trim the last block to match the total size.\n      }\n      // It's okay to use `allocUnsafe` because we don't allow reading data from ranges that have\n      // not explicitly be filled using `VirtualLRUBuffer#copyFrom`.\n      this.#blocks[index] = new Uint8Array(size);\n    }\n    // Put the current index to the end of the list, while avoiding duplicates.\n    this.#lastAccessedBlockIndices = [\n      ...this.#lastAccessedBlockIndices.filter((idx) => idx !== index),\n      index,\n    ];\n    if (this.#lastAccessedBlockIndices.length > this.#numberOfBlocks) {\n      // If we have too many blocks, remove the least recently used one.\n      // Note that we don't reuse blocks, since other code might still hold a reference to it\n      // via the `VirtualLRUBuffer#slice` method.\n      const deleteIndex = this.#lastAccessedBlockIndices.shift();\n      if (deleteIndex != undefined) {\n        delete this.#blocks[deleteIndex];\n        // Remove the range that we evicted from `_rangesWithData`, since the range doesn't have data now.\n        this.#rangesWithData = simplify(\n          substract(this.#rangesWithData, [\n            { start: deleteIndex * this.#blockSize, end: (deleteIndex + 1) * this.#blockSize },\n          ]),\n        );\n      }\n    }\n    const block = this.#blocks[index];\n    if (!block) {\n      throw new Error(\"invariant violation - no block at index\");\n    }\n    return block;\n  }\n\n  // For a given position, calculate `blockIndex` (which block is this position in);\n  // `positionInBlock` (byte index of `position` within that block); and `remainingBytesInBlock`\n  // (how many bytes are there in that block after that position).\n  #calculatePosition(position: number) {\n    if (position < 0 || position >= this.byteLength) {\n      throw new Error(\"VirtualLRUBuffer#_calculatePosition invalid input\");\n    }\n    const blockIndex = Math.floor(position / this.#blockSize);\n    const positionInBlock = position - blockIndex * this.#blockSize;\n    const remainingBytesInBlock = this.#getBlock(blockIndex).byteLength - positionInBlock;\n    return { blockIndex, positionInBlock, remainingBytesInBlock };\n  }\n}\n\n/**\n * Copy part of a Uint8Array into another Uint8Array\n * @param source Source to copy from\n * @param target Destination to copy to\n * @param targetStart Index to start copying bytes to in `target`\n * @param sourceStart Index to start copying bytes from in `source`\n * @param sourceEnd Index to stop copying bytes from in `source`\n */\nfunction copy(\n  source: Uint8Array,\n  target: Uint8Array,\n  targetStart: number,\n  sourceStart: number,\n  sourceEnd?: number,\n): void {\n  const count = (sourceEnd ?? source.byteLength) - sourceStart;\n  for (let i = 0; i < count; i++) {\n    target[targetStart + i] = source[sourceStart + i]!;\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\nimport { isOverlapping } from \"intervals-fn\";\n\nimport { Range, isRangeCoveredByRanges, missingRanges } from \"./ranges\";\n\n// Based on a number of properties this function determines if a new connection should be opened or\n// not. It can be used for any type of ranges, be it bytes, timestamps, or something else.\nexport function getNewConnection(options: {\n  currentRemainingRange?: Range; // The remaining range that the current connection (if any) is going to download.\n  readRequestRange?: Range; // The range of the read request that we're trying to satisfy.\n  downloadedRanges: Range[]; // Array of ranges that have been downloaded already.\n  lastResolvedCallbackEnd?: number; // The range.end of the last read request that we resolved. Useful for reading ahead a bit.\n  maxRequestSize: number; // The cache size. If equal to or larger than `fileSize` we will attempt to download the whole file.\n  fileSize: number; // Size of the file.\n  continueDownloadingThreshold: number; // Amount we're willing to wait downloading before opening a new connection.\n}): Range | undefined {\n  const { readRequestRange, currentRemainingRange, ...otherOptions } = options;\n  if (readRequestRange) {\n    return getNewConnectionWithExistingReadRequest({\n      readRequestRange,\n      currentRemainingRange,\n      ...otherOptions,\n    });\n  } else if (!currentRemainingRange) {\n    return getNewConnectionWithoutExistingConnection(otherOptions);\n  }\n  return undefined;\n}\n\nfunction getNewConnectionWithExistingReadRequest({\n  currentRemainingRange,\n  readRequestRange,\n  downloadedRanges,\n  maxRequestSize,\n  fileSize,\n  continueDownloadingThreshold,\n}: {\n  currentRemainingRange?: Range;\n  readRequestRange: Range;\n  downloadedRanges: Range[];\n  lastResolvedCallbackEnd?: number;\n  maxRequestSize: number;\n  fileSize: number;\n  continueDownloadingThreshold: number;\n}): Range | undefined {\n  // We have a requested range that we're trying to download.\n  if (readRequestRange.end - readRequestRange.start > maxRequestSize) {\n    // This should have been caught way earlier, but just as a sanity check.\n    throw new Error(\n      `Range ${readRequestRange.start}-${readRequestRange.end} exceeds max request size ${maxRequestSize} (file size ${fileSize})`,\n    );\n  }\n\n  // Get the parts of the requested range that have not been downloaded yet.\n  const notDownloadedRanges = missingRanges(readRequestRange, downloadedRanges);\n\n  if (!notDownloadedRanges[0]) {\n    // If there aren't any, then we should have never passed in `readRequestRange`.\n    throw new Error(\n      \"Range for the first read request is fully downloaded, so it should have been deleted\",\n    );\n  }\n\n  // We want to start a new connection if:\n  const startNewConnection = // 1. There is no current connection.\n    !currentRemainingRange || // 2. Or if there is no overlap between the current connection and the requested range.\n    !isOverlapping(notDownloadedRanges, [currentRemainingRange]) || // 3. Or if we'll reach the requested range at some point, but that would take too long.\n    currentRemainingRange.start + continueDownloadingThreshold < notDownloadedRanges[0].start;\n\n  if (!startNewConnection) {\n    return;\n  }\n  if (maxRequestSize >= fileSize) {\n    // If we're trying to download the whole file, read all the way up to the next range that we have already downloaded.\n    const range = { start: notDownloadedRanges[0].start, end: fileSize };\n    return missingRanges(range, downloadedRanges)[0];\n  }\n\n  if (notDownloadedRanges[0].end === readRequestRange.end) {\n    // If we're downloading to the end of our range, do some reading ahead while we're at it.\n    // Note that we might have already downloaded parts of this range, but we don't know when\n    // they get evicted, so for now we just the entire range again.\n    return {\n      ...notDownloadedRanges[0],\n      end: Math.min(readRequestRange.start + maxRequestSize, fileSize),\n    };\n  }\n\n  // Otherwise, start reading from the first non-downloaded range.\n  return notDownloadedRanges[0];\n}\n\nfunction getNewConnectionWithoutExistingConnection({\n  downloadedRanges,\n  lastResolvedCallbackEnd,\n  maxRequestSize,\n  fileSize,\n}: {\n  downloadedRanges: Range[];\n  lastResolvedCallbackEnd?: number;\n  maxRequestSize: number;\n  fileSize: number;\n}): Range | undefined {\n  // If we don't have any read requests, and we also don't have an active connection, then start\n  // reading ahead as much data as we can!\n  let readAheadRange: Range | undefined;\n  if (maxRequestSize >= fileSize) {\n    // If we have an unlimited cache, we want to read the entire file, but still prefer downloading\n    // first near where the last request happened.\n    const potentialRange = { start: lastResolvedCallbackEnd ?? 0, end: fileSize };\n    if (!isRangeCoveredByRanges(potentialRange, downloadedRanges)) {\n      readAheadRange = potentialRange;\n    } else {\n      readAheadRange = { start: 0, end: fileSize };\n    }\n  } else if (lastResolvedCallbackEnd != undefined) {\n    // Otherwise, if we have a limited cache, we want to read the data right after the last\n    // read request, because usually read requests are sequential without gaps.\n    readAheadRange = {\n      start: lastResolvedCallbackEnd,\n      end: Math.min(lastResolvedCallbackEnd + maxRequestSize, fileSize),\n    };\n  }\n  if (readAheadRange) {\n    // If we have a range that we want to read ahead, then create a new connection for the range\n    // within it that has not already been downloaded.\n    return missingRanges(readAheadRange, downloadedRanges)[0];\n  }\n  return undefined;\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\nimport { round } from \"lodash\";\n\nimport Logger from \"@foxglove/log\";\nimport { Filelike } from \"@foxglove/rosbag\";\n\nimport VirtualLRUBuffer from \"./VirtualLRUBuffer\";\nimport { getNewConnection } from \"./getNewConnection\";\nimport { Range } from \"./ranges\";\n\n// CachedFilelike is a `Filelike` that attempts to do as much caching of the file in memory as\n// possible. It takes in 3 named arguments to its constructor:\n// - fileReader: a `FileReader` instance (defined below). This essentially does the streamed\n//     fetching of ranges from our file.\n// - cacheSizeInBytes (optional): how many bytes we're allowed to cache. Defaults to infinite\n//     caching (meaning that the cache will be as big as the file size). `cacheSizeInBytes` also\n//     becomes the largest range of data that can be requested.\n// - logFn (optional): a log function. Useful for logging in a particular format. Defaults to\n//     `console.log`.\n// - keepReconnectingCallback (optional): if set, we assume that we want to keep retrying on connection\n//     error, in which case the callback gets called with an update on whether we are currently\n//     reconnecting. This is useful when the connection is expected to be spotty, e.g. when\n//     running this code in a browser instead of on a server. If omitted, we will retry for a short\n//     amount of time and then reject read requests.\n//\n// Under the hood this uses a `VirtualLRUBuffer`, which represents the entire file in memory, even\n// though only parts of it may actually be stored in memory. It also manages evicting least recently\n// used blocks from memory.\n//\n// We keep a list of byte ranges that have been requested, and their associated callbacks. Typically\n// there will be only one such requested range at the time, as usually we need to parse some data\n// first before we can read more. We keep one stream from the `fileReader` open at a time, and we\n// serve the requested byte ranges in order.\n//\n// If there are currently no requested byte ranges, we try to intelligently load as much data as\n// possible into memory, with a preference given to ranges immediately following the last requested\n// byte range. If the cache spans the entire file size, we try to download the entire file.\n\nexport type FileStream = {\n  on<T>(event: \"data\", listener: (chunk: T) => void): void;\n  on(event: \"error\", listener: (err: Error) => void): void;\n  destroy: () => void;\n};\nexport interface FileReader {\n  open(): Promise<{ size: number }>;\n  fetch(offset: number, length: number): FileStream;\n}\n\nconst LOGGING_INTERVAL_IN_BYTES = 1024 * 1024 * 100; // Log every 100MiB to avoid cluttering the logs too much.\nconst CACHE_BLOCK_SIZE = 1024 * 1024 * 10; // 10MiB blocks.\n// Don't start a new connection if we're 5MiB away from downloading the requested byte.\nconst CLOSE_ENOUGH_BYTES_TO_NOT_START_NEW_CONNECTION = 1024 * 1024 * 5;\n\nconst log = Logger.getLogger(__filename);\n\ninterface ILogger {\n  debug(..._args: unknown[]): void;\n  info(..._args: unknown[]): void;\n  warn(..._args: unknown[]): void;\n  error(..._args: unknown[]): void;\n}\n\nexport default class CachedFilelike implements Filelike {\n  #fileReader: FileReader;\n  #cacheSizeInBytes: number = Infinity;\n  #fileSize?: number;\n  #virtualBuffer: VirtualLRUBuffer;\n  #log: ILogger;\n  #closed: boolean = false;\n  // eslint-disable-next-line @foxglove/no-boolean-parameters\n  #keepReconnectingCallback?: (reconnecting: boolean) => void;\n\n  // The current active connection, if there is one. `remainingRange.start` gets updated whenever\n  // we receive new data, so it truly is the remaining range that it is going to download.\n  #currentConnection: { stream: FileStream; remainingRange: Range } | undefined;\n\n  // A list of read requests and associated ranges for all read requests, in order.\n  #readRequests: {\n    range: Range;\n    resolve: (_: Uint8Array) => void;\n    reject: (_: Error) => void;\n    requestTime: number;\n  }[] = [];\n\n  // The range.end of the last read request that we resolved. Useful for reading ahead a bit.\n  #lastResolvedCallbackEnd?: number;\n\n  // The last time we've encountered an error;\n  #lastErrorTime?: number;\n\n  public constructor(options: {\n    fileReader: FileReader;\n    cacheSizeInBytes?: number;\n    log?: ILogger;\n    // eslint-disable-next-line @foxglove/no-boolean-parameters\n    keepReconnectingCallback?: (reconnecting: boolean) => void;\n  }) {\n    this.#fileReader = options.fileReader;\n    this.#cacheSizeInBytes = options.cacheSizeInBytes ?? this.#cacheSizeInBytes;\n    this.#keepReconnectingCallback = options.keepReconnectingCallback;\n    this.#log = options.log ?? log;\n    this.#virtualBuffer = new VirtualLRUBuffer({ size: 0 });\n  }\n\n  public async open(): Promise<void> {\n    if (this.#fileSize != undefined) {\n      return;\n    }\n    const { size } = await this.#fileReader.open();\n    this.#fileSize = size;\n    if (this.#cacheSizeInBytes >= size) {\n      // If we have a cache limit that exceeds the file size, then we don't need to limit ourselves\n      // to small blocks. This way `VirtualLRUBuffer#slice` will be faster since we'll almost always\n      // not need to copy from multiple blocks into a new `Buffer` instance.\n      this.#virtualBuffer = new VirtualLRUBuffer({ size });\n    } else {\n      this.#virtualBuffer = new VirtualLRUBuffer({\n        size,\n        blockSize: CACHE_BLOCK_SIZE,\n        // Rather create too many blocks than too few (Math.ceil), and always add one block,\n        // to allow for a read range not starting or ending perfectly at a block boundary.\n        numberOfBlocks: Math.ceil(this.#cacheSizeInBytes / CACHE_BLOCK_SIZE) + 2,\n      });\n    }\n    this.#log.info(`Opening file with size ${bytesToMiB(this.#fileSize)}MiB`);\n  }\n\n  // Get the file size. Requires a call to `open()` or `read()` first.\n  public size(): number {\n    if (this.#fileSize == undefined) {\n      throw new Error(\"CachedFilelike has not been opened\");\n    }\n    return this.#fileSize;\n  }\n\n  // Potentially performance-sensitive; await can be expensive\n  // eslint-disable-next-line @typescript-eslint/promise-function-async\n  public read(offset: number, length: number): Promise<Uint8Array> {\n    if (length === 0) {\n      return Promise.resolve(new Uint8Array());\n    }\n\n    const range = { start: offset, end: offset + length };\n\n    if (offset < 0 || length < 0) {\n      throw new Error(\"CachedFilelike#read invalid input\");\n    }\n    if (length > this.#cacheSizeInBytes) {\n      throw new Error(`Requested more data than cache size: ${length} > ${this.#cacheSizeInBytes}`);\n    }\n\n    // Potentially performance-sensitive; await can be expensive\n    return new Promise((resolve, reject) => {\n      this.open()\n        .then(() => {\n          const size = this.size();\n          if (range.end > size) {\n            reject(new Error(`CachedFilelike#read past size`));\n            return;\n          }\n\n          this.#readRequests.push({ range, resolve, reject, requestTime: Date.now() });\n          this.#updateState();\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  // Gets called any time our connection or read requests change.\n  #updateState(): void {\n    if (this.#closed) {\n      return;\n    }\n\n    // First, see if there are any read requests that we can resolve now.\n    this.#readRequests = this.#readRequests.filter(({ range, resolve }) => {\n      if (!this.#virtualBuffer.hasData(range.start, range.end)) {\n        return true;\n      }\n\n      this.#lastResolvedCallbackEnd = range.end;\n      const buffer = this.#virtualBuffer.slice(range.start, range.end);\n\n      resolve(buffer);\n      return false;\n    });\n\n    const size = this.size();\n\n    // Then see if we need to set a new connection based on the new connection and read requests state.\n    const newConnection = getNewConnection({\n      currentRemainingRange: this.#currentConnection\n        ? this.#currentConnection.remainingRange\n        : undefined,\n      readRequestRange: this.#readRequests[0] ? this.#readRequests[0].range : undefined,\n      downloadedRanges: this.#virtualBuffer.getRangesWithData(),\n      lastResolvedCallbackEnd: this.#lastResolvedCallbackEnd,\n      maxRequestSize: this.#cacheSizeInBytes,\n      fileSize: size,\n      continueDownloadingThreshold: CLOSE_ENOUGH_BYTES_TO_NOT_START_NEW_CONNECTION,\n    });\n    if (newConnection) {\n      this.#setConnection(newConnection);\n    }\n  }\n\n  // Replace the current connection with a new one, spanning a certain range.\n  #setConnection(range: Range): void {\n    this.#log.debug(`Setting new connection @ ${rangeToString(range)}`);\n\n    if (this.#currentConnection) {\n      // Destroy the current connection if there is one.\n      const currentConnection = this.#currentConnection;\n      currentConnection.stream.destroy();\n      this.#log.debug(\n        `Destroyed current connection @ ${rangeToString(currentConnection.remainingRange)}`,\n      );\n    }\n\n    // Start the stream, and update the current connection state.\n    const stream = this.#fileReader.fetch(range.start, range.end - range.start);\n    this.#currentConnection = { stream, remainingRange: range };\n\n    stream.on(\"error\", (error: Error) => {\n      const currentConnection = this.#currentConnection;\n      if (!currentConnection || stream !== currentConnection.stream) {\n        return; // Ignore errors from old streams.\n      }\n\n      if (this.#keepReconnectingCallback) {\n        // If this callback is set, just keep retrying.\n        if (this.#lastErrorTime == undefined) {\n          // And if this is the first error, let the callback know.\n          this.#keepReconnectingCallback(true);\n        }\n      } else {\n        // Otherwise, if we get two errors in a short timespan (100ms) then there is probably a\n        // serious error, we resolve all remaining callbacks with errors and close out.\n        const lastErrorTime = this.#lastErrorTime;\n        if (lastErrorTime != undefined && Date.now() - lastErrorTime < 100) {\n          this.#log.error(\n            `Connection @ ${rangeToString(\n              range,\n            )} threw another error; closing: ${error.toString()}`,\n          );\n\n          this.#closed = true;\n          for (const request of this.#readRequests) {\n            request.reject(error);\n          }\n          return;\n        }\n      }\n\n      // When we encounter an error there is usually a bad connection or timeout or so, so just\n      // mark the current connection as destroyed, and try again.\n      this.#log.info(\n        `Connection @ ${rangeToString(range)} threw error; trying to continue: ${error.toString()}`,\n      );\n      this.#lastErrorTime = Date.now();\n      currentConnection.stream.destroy();\n      this.#currentConnection = undefined;\n      this.#updateState();\n    });\n\n    // Handle the data stream.\n    const startTime = Date.now();\n    let bytesRead = 0;\n    let lastReportedBytesRead = 0;\n    stream.on(\"data\", (chunk: Uint8Array) => {\n      const currentConnection = this.#currentConnection;\n      if (!currentConnection || stream !== currentConnection.stream) {\n        return; // Ignore data from old streams.\n      }\n\n      if (this.#lastErrorTime != undefined) {\n        // If we had an error before, then that has clearly been resolved since we received some data.\n        this.#lastErrorTime = undefined;\n        if (this.#keepReconnectingCallback) {\n          // And if we had a callback, let it know that the issue has been resolved.\n          this.#keepReconnectingCallback(false);\n        }\n      }\n\n      // Copy the data into the VirtualLRUBuffer.\n      this.#virtualBuffer.copyFrom(chunk, currentConnection.remainingRange.start);\n      bytesRead += chunk.byteLength;\n\n      // Every now and then, do some logging of the current download speed.\n      if (bytesRead - lastReportedBytesRead > LOGGING_INTERVAL_IN_BYTES) {\n        lastReportedBytesRead = bytesRead;\n        const sec = (Date.now() - startTime) / 1000;\n\n        const mibibytes = bytesToMiB(bytesRead);\n        const speed = round(mibibytes / sec, 2);\n        this.#log.debug(\n          `Connection @ ${rangeToString(\n            currentConnection.remainingRange,\n          )} downloading at ${speed} MiB/s`,\n        );\n      }\n\n      if (this.#virtualBuffer.hasData(range.start, range.end)) {\n        // If the requested range has been downloaded, we're done!\n        this.#log.info(`Connection @ ${rangeToString(currentConnection.remainingRange)} finished!`);\n        stream.destroy();\n        this.#currentConnection = undefined;\n      } else {\n        // Otherwise, update `remainingRange`.\n        this.#currentConnection = {\n          stream,\n          remainingRange: { start: range.start + bytesRead, end: range.end },\n        };\n      }\n\n      // Always call `_updateState` so it can decide to create new connections, resolve callbacks, etc.\n      this.#updateState();\n    });\n  }\n}\n\n// Some formatting functions.\nfunction bytesToMiB(bytes: number) {\n  return round(bytes / 1024 / 1024, 3);\n}\nfunction rangeToString(range: Range) {\n  return `${bytesToMiB(range.start)}-${bytesToMiB(range.end)}MiB`;\n}\n"],"names":["abortSignalTransferHandler","val","aborted","msgPort","controller","abortSignal","port1","port2","channels","noop","Logger","#name","name","level","_args","shortName","channelName","existing","logger","toLogLevel","maybeLevel","TIME_ZERO","IteratorCursor","#iter","#lastIteratorResult","#abort","iterator","abort","durationMs","firstResult","results","cutoffTime","result","end","value","WorkerIterableSourceWorker","source","args","iter","cursor","FetchReader","#response","#reader","#controller","#aborted","#url","url","options","#getReader","data","err","errMsg","reader","done","unk","isDesktopApp","BrowserHttpReader","response","error","size","offset","length","headers","isRangeCoveredByRanges","queryRange","nonOverlappingMergedAndSortedRanges","range","missingRanges","bounds","ranges","kMaxLength","VirtualLRUBuffer","#blocks","#blockSize","#numberOfBlocks","#lastAccessedBlockIndices","#rangesWithData","start","targetStart","position","blockIndex","positionInBlock","remainingBytesInBlock","#calculatePosition","copy","#getBlock","startPositionData","index","idx","deleteIndex","block","target","sourceStart","sourceEnd","count","i","getNewConnection","readRequestRange","currentRemainingRange","otherOptions","getNewConnectionWithExistingReadRequest","getNewConnectionWithoutExistingConnection","downloadedRanges","maxRequestSize","fileSize","continueDownloadingThreshold","notDownloadedRanges","lastResolvedCallbackEnd","readAheadRange","potentialRange","LOGGING_INTERVAL_IN_BYTES","CACHE_BLOCK_SIZE","CLOSE_ENOUGH_BYTES_TO_NOT_START_NEW_CONNECTION","log","CachedFilelike","#fileReader","#cacheSizeInBytes","#fileSize","#virtualBuffer","#log","#closed","#keepReconnectingCallback","#currentConnection","#readRequests","#lastResolvedCallbackEnd","#lastErrorTime","bytesToMiB","resolve","reject","#updateState","buffer","newConnection","#setConnection","rangeToString","currentConnection","stream","lastErrorTime","request","startTime","bytesRead","lastReportedBytesRead","chunk","sec","mibibytes","speed","bytes"],"sourceRoot":""}