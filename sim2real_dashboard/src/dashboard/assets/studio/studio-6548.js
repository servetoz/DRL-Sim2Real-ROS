(()=>{var O={80859:(e,r,t)=>{"use strict";var f=t(90758),o=t(41253),i=t(16514),h=t(13791),w=t(17417),v=t(92897),y=t(44668),j=t(20865),P=t(88499);function R(b){const c=b.slice().sort((d,a)=>(0,y.compare)(d.startTime,a.startTime));let l={sec:-1/0,nsec:0},u=0;return c.forEach(({startTime:d,endTime:a})=>{(0,y.isLessThan)(d,l)&&(u+=1),(0,y.isGreaterThan)(a,l)&&(l=a)}),u}var _=t(94789),x=t(3400),E=t.n(x);class z{#t;#e;#s=new Map;#r=new Map;constructor(c){this.#t=c}async initialize(){await E().isLoaded;const c=await _.default.init();let l;if(this.#t.type==="remote"){const p=this.#t.url,n=new j.Z(p),g=new P.Z({fileReader:n,cacheSizeInBytes:1024*1024*200,keepReconnectingCallback:T=>{}});await g.open(),l=g}else l=new h.BlobReader(this.#t.file);this.#e=new i.N(l,{parse:!1,decompress:{bz2:(p,n)=>c.decompress(p,n,{small:!1}),lz4:(p,n)=>E()(p,n)}}),await this.#e.open();const u=[],d=R(this.#e.chunkInfos);if(d>this.#e.chunkInfos.length*.25){const p=`This bag has many overlapping chunks (${d} out of ${this.#e.chunkInfos.length}). This results in more memory use during playback.`,n="Re-sort the messages in your bag by receive time.";u.push({severity:"warn",message:p,tip:n})}const a=new Array(this.#e.connections.size).fill(0);this.#e.chunkInfos.forEach(p=>{p.connections.forEach(({conn:n,count:g})=>{a[n]+=g})});const m=new Map,k=new Map,C=new Map,M=new Map;for(const[p,n]of this.#e.connections){const g=n.type;if(!g)continue;let T=M.get(n.topic);T||(T=new Set,M.set(n.topic,T)),T.add(n.callerid??String(n.conn));const I=k.get(n.topic);I&&I.schemaName!==g&&u.push({severity:"warn",message:`Conflicting datatypes on topic (${n.topic}): ${g}, ${I.schemaName}`,tip:`Studio requires all connections on a topic to have the same datatype. Make sure all your nodes are publishing the same message on ${n.topic}.`}),I||k.set(n.topic,{name:n.topic,schemaName:g});const N=(C.get(n.topic)?.numMessages??0)+(a[n.conn]??0);C.set(n.topic,{numMessages:N});const $=(0,w.parse)(n.messageDefinition),A=new v.MessageReader($);this.#s.set(p,A),this.#r.set(p,g);for(const S of $)S.name?m.set(S.name,S):m.set(g,S)}return{topics:Array.from(k.values()),topicStats:C,start:this.#e.startTime??{sec:0,nsec:0},end:this.#e.endTime??{sec:0,nsec:0},problems:u,profile:"ros1",datatypes:m,publishersByTopic:M}}async*messageIterator(c){yield*this.#n({...c,reverse:!1})}async*#n(c){if(!this.#e)throw new Error("Invariant: uninitialized");const l=c.end,u=this.#e.messageIterator({topics:c.topics,reverse:c.reverse,start:c.start}),d=this.#s;for await(const a of u){const m=a.connectionId,k=d.get(m);if(l&&(0,y.compare)(a.timestamp,l)>0)return;const C=this.#r.get(m);if(!C){yield{type:"problem",connectionId:m,problem:{severity:"error",message:`Cannot missing datatype for connection id ${m}`,tip:"Check that your bag file is well-formed. It should have a connection record for every connection id referenced from a message record."}};return}if(k){const M=a.data.slice(),p=k.readMessage(M);yield{type:"message-event",connectionId:m,msgEvent:{topic:a.topic,receiveTime:a.timestamp,sizeInBytes:a.data.byteLength,message:p,schemaName:C}}}else yield{type:"problem",connectionId:m,problem:{severity:"error",message:`Cannot deserialize message for missing connection id ${m}`,tip:"Check that your bag file is well-formed. It should have a connection record for every connection id referenced from a message record."}}}}async getBackfillMessages({topics:c,time:l}){const u=[];for(const d of c)for await(const a of this.#n({topics:[d],start:l,reverse:!0})){a.type==="message-event"&&u.push(a.msgEvent);break}return u.sort((d,a)=>(0,y.compare)(d.receiveTime,a.receiveTime)),u}}function L(b){if(b.file){const c=new z({type:"file",file:b.file}),l=new o.a(c);return f.sj(l)}else if(b.url){const c=new z({type:"remote",url:b.url}),l=new o.a(c);return f.sj(l)}throw new Error("file or url required")}f.Jj(L)},63136:(e,r,t)=>{"use strict";t.d(r,{Z:()=>o});const o={nextTick:(i,...h)=>{queueMicrotask(()=>{i(...h)})},title:"browser",browser:!0,env:{},argv:[]}},62891:()=>{},16471:()=>{}},B={};function s(e){var r=B[e];if(r!==void 0)return r.exports;var t=B[e]={id:e,loaded:!1,exports:{}};return O[e].call(t.exports,t,t.exports,s),t.loaded=!0,t.exports}s.m=O,s.x=()=>{var e=s.O(void 0,[8981,7979,4432,7372,2984,1343,4812],()=>s(80859));return e=s.O(e),e},(()=>{var e=[];s.O=(r,t,f,o)=>{if(t){o=o||0;for(var i=e.length;i>0&&e[i-1][2]>o;i--)e[i]=e[i-1];e[i]=[t,f,o];return}for(var h=1/0,i=0;i<e.length;i++){for(var[t,f,o]=e[i],w=!0,v=0;v<t.length;v++)(o&!1||h>=o)&&Object.keys(s.O).every(x=>s.O[x](t[v]))?t.splice(v--,1):(w=!1,o<h&&(h=o));if(w){e.splice(i--,1);var y=f();y!==void 0&&(r=y)}}return r}})(),s.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return s.d(r,{a:r}),r},s.d=(e,r)=>{for(var t in r)s.o(r,t)&&!s.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:r[t]})},s.f={},s.e=e=>Promise.all(Object.keys(s.f).reduce((r,t)=>(s.f[t](e,r),r),[])),s.u=e=>"studio-"+e+".js",s.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),s.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),s.r=e=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e;s.g.importScripts&&(e=s.g.location+"");var r=s.g.document;if(!e&&r&&(r.currentScript&&(e=r.currentScript.src),!e)){var t=r.getElementsByTagName("script");if(t.length)for(var f=t.length-1;f>-1&&!e;)e=t[f--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),s.p=e})(),(()=>{var e={6548:1,4334:1},r=o=>{var[i,h,w]=o;for(var v in h)s.o(h,v)&&(s.m[v]=h[v]);for(w&&w(s);i.length;)e[i.pop()]=1;f(o)};s.f.i=(o,i)=>{e[o]||importScripts(s.p+s.u(o))};var t=self.webpackChunk=self.webpackChunk||[],f=t.push.bind(t);t.push=r})(),(()=>{var e=s.x;s.x=()=>Promise.all([8981,7979,4432,7372,2984,1343,4812].map(s.e,s)).then(e)})();var F=s.x()})();

//# sourceMappingURL=studio-6548.js.map