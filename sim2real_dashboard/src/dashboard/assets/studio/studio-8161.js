"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8161],{18161:(ge,ye,l)=>{var M=l(90758),A=l(41253),R=l(25811),O=l(23503),C=l(87026);function X(t,e){const n=new Map;function s(o,d,m){let a=c=>c;const u=[];if(o.type!=="object")throw new Error(`Expected "type": "object" for schema ${d}, got ${JSON.stringify(o.type)}`);for(const[c,f]of Object.entries(o.properties)){if(Array.isArray(f.oneOf))if(f.oneOf.every(h=>typeof h.const=="number")){for(const h of f.oneOf)u.push({name:h.title,type:"uint32",isConstant:!0,value:h.const});u.push({name:c,type:"uint32"});continue}else throw new Error(`Unsupported type for ${m.concat(c).join(".")}: oneOf alternatives must have number values`);switch(f.type){case"boolean":u.push({name:c,type:"bool"});break;case"string":switch(f.contentEncoding){case void 0:u.push({name:c,type:"string"});break;case"base64":{u.push({name:c,type:"uint8",isArray:!0});const h=a;a=w=>{const g=w[c];if(typeof g=="string"){const b=new Uint8Array(C.length(g));if(C.decode(g,b,0)!==b.byteLength)throw new Error(`Failed to decode base64 data for ${m.concat(c).join(".")}`);w[c]=b}return h(w)};break}default:throw new Error(`Unsupported contentEncoding ${JSON.stringify(f.contentEncoding)} in ${m.concat(c).join(".")}`)}break;case"number":case"integer":u.push({name:c,type:"float64"});break;case"object":{const h=`${d}.${c}`,w=s(f,h,m.concat(c)),g=a;a=b=>{const v=b[c];return v!=null&&typeof v=="object"&&(b[c]=w(v)),g(b)},u.push({name:c,type:h,isComplex:!0});break}case"array":{const h=f.items;switch(h.type){case"boolean":u.push({name:c,type:"bool",isArray:!0});break;case"string":if(h.contentEncoding!=null)throw new Error(`Unsupported contentEncoding ${JSON.stringify(h.contentEncoding)} for array item ${m.concat(c).join(".")}`);u.push({name:c,type:"string",isArray:!0});break;case"number":case"integer":u.push({name:c,type:"float64",isArray:!0});break;case"object":{const w=`${d}.${c}`,g=s(f.items,w,m.concat(c)),b=a;a=v=>{const z=v[c];return Array.isArray(z)&&(v[c]=z.map(g)),b(v)},u.push({name:c,type:w,isComplex:!0,isArray:!0});break}default:throw new Error(`Unsupported type ${JSON.stringify(h.type)} for array item ${m.concat(c).join(".")}`)}break}case"null":default:throw new Error(`Unsupported type ${JSON.stringify(f.type)} for ${m.concat(c).join(".")}`)}}return n.set(d,{definitions:u}),a}const r=s(t,e,[]);return{datatypes:n,postprocessValue:r}}var Y=l(11168),x=l.n(Y);function K(t){switch(t){case"double":return"float64";case"float":return"float32";case"int32":case"sint32":case"sfixed32":return"int32";case"uint32":case"fixed32":return"uint32";case"int64":case"sint64":case"sfixed64":return"int64";case"uint64":case"fixed64":return"uint64";case"bool":return"bool";case"string":return"string"}throw new Error(`Expected protobuf scalar type, got ${t}`)}function N(t){return t.replace(/^\./,"")}function U(t,e){const n=[];t.set(N(e.fullName),{definitions:n});for(const s of e.fieldsArray)if(s.resolvedType instanceof x().Enum){for(const[r,o]of Object.entries(s.resolvedType.values))n.push({name:r,type:"int32",isConstant:!0,value:o});n.push({type:"int32",name:s.name})}else if(s.resolvedType){const r=N(s.resolvedType.fullName);n.push({type:r,name:s.name,isComplex:!0,isArray:s.repeated}),t.has(r)||U(t,s.resolvedType)}else if(s.type==="bytes"){if(s.repeated)throw new Error("Repeated bytes are not currently supported");n.push({type:"uint8",name:s.name,isArray:!0})}else n.push({type:K(s.type),name:s.name,isArray:s.repeated})}var j=l(17417),Q=l(92897),q=l(62098),D=l(15356),i=l(98357);function L(t){switch(t){case i.rB.Bool:return"bool";case i.rB.Byte:return"int8";case i.rB.UType:case i.rB.UByte:return"uint8";case i.rB.Short:return"int16";case i.rB.UShort:return"uint16";case i.rB.Int:return"int32";case i.rB.UInt:return"uint32";case i.rB.Long:return"int64";case i.rB.ULong:return"uint64";case i.rB.Float:return"float32";case i.rB.Double:return"float64";case i.rB.String:return"string";case i.rB.Vector:case i.rB.Obj:case i.rB.Union:case i.rB.Array:throw new Error(`${t} is not a simple type.`);case i.rB.None:case i.rB.MaxBaseType:throw new Error("None is not a valid type.")}}function T(t){if(typeof t=="string")return t;throw new Error(`Expected string, found ${typeof t}`)}function _(t,e){const n=[];switch(e.type?.baseType){case i.rB.UType:case i.rB.Bool:case i.rB.Byte:case i.rB.UByte:case i.rB.Short:case i.rB.UShort:case i.rB.Int:case i.rB.UInt:case i.rB.Long:case i.rB.ULong:case i.rB.Float:case i.rB.Double:case i.rB.String:case i.rB.None:{const s=L(e.type.baseType);if(e.type.index!==-1){const r=t.enums[e.type.index]?.values;if(r==null)throw new Error(`Invalid schema, missing enum values for field type ${t.enums[e.type.index]?.name}`);for(const o of r)n.push({name:T(o.name),type:s,isConstant:!0,value:o.value})}n.push({name:T(e.name),type:s});break}case i.rB.Vector:switch(e.type.element){case i.rB.Vector:case i.rB.Union:case i.rB.Array:case i.rB.None:throw new Error("Vectors of vectors, unions, arrays, and None's are unsupported.");case i.rB.Obj:n.push({name:T(e.name),type:T(t.objects[e.type.index]?.name),isComplex:!0,isArray:!0});break;default:{const s=L(e.type.element);if(e.type.index!==-1){const r=t.enums[e.type.index]?.values;if(r==null)throw new Error("Invalid schema");for(const o of r)n.push({name:T(o.name),type:s,isConstant:!0,value:o.value})}n.push({name:T(e.name),type:s,isArray:!0});break}}break;case i.rB.Obj:n.push({name:T(e.name),type:T(t.objects[e.type.index]?.name),isComplex:!0});break;case i.rB.Union:case i.rB.Array:case i.rB.MaxBaseType:case void 0:throw new Error("Unions and Arrays are not supported in mcap-support currently.")}return n}function ee(t,e){const n=new Map,s=new D.cZ(e),r=i.V_.getRootAsSchema(s),o=r.unpack();let d=-1;for(let c=0;c<o.objects.length;++c){const f=o.objects[c];f?.name===t&&(d=c);let h=[];if(f?.fields!=null){for(const w of f.fields)h=h.concat(_(o,w));n.set(T(f.name),{definitions:h})}}if(d===-1&&o.rootTable?.name!==t)throw new Error(`Type "${t}" is not available in the schema for "${o.rootTable?.name}".`);const a=new i._b(r).toObjectLambda(d,!0);return{datatypes:n,deserialize:c=>{const f=new D.cZ(new Uint8Array(c.buffer,c.byteOffset,c.byteLength)),h=new i.iA(f,d,f.readInt32(f.position())+f.position(),!1);return a(h)}}}var te=l(70943);function se(t,e){const n=te.FileDescriptorSet.decode(e),s=x().Root.fromDescriptor(n);s.resolveAll();const r=s.lookupType(t),o=a=>{if(!a||!(a instanceof x().Type))return;for(const f of a.fieldsArray)f.name==="seconds"?f.name="sec":f.name==="nanos"&&(f.name="nsec");a.setup();const u=a.toObject,c=(f,h)=>{const w=u.call(a,f,h),{sec:g,nsec:b}=w;if(typeof g!="bigint"||typeof b!="number")return w;if(g>BigInt(Number.MAX_SAFE_INTEGER))throw new Error(`Timestamps with seconds greater than 2^53-1 are not supported (found seconds=${g}, nanos=${b})`);return{sec:Number(g),nsec:b}};a.toObject=c};o(s.lookup(".google.protobuf.Timestamp")),o(s.lookup(".google.protobuf.Duration"));const d=a=>r.toObject(r.decode(new Uint8Array(a.buffer,a.byteOffset,a.byteLength)),{defaults:!0}),m=new Map;if(U(m,r),!m.has(t))throw new Error(`Protobuf schema does not contain an entry for '${t}'. The schema name should be fully-qualified, e.g. '${N(r.fullName)}'.`);return{deserialize:d,datatypes:m}}function F(t,e){const n=new Map;return t.forEach(({name:s,definitions:r},o)=>{o===0?n.set(e,{name:e,definitions:r}):s!=null&&n.set(s,{name:s,definitions:r})}),n}function k(t){if(t.messageEncoding==="json"){if(t.schema!=null&&t.schema.encoding!=="jsonschema")throw new Error(`Message encoding ${t.messageEncoding} with schema encoding '${t.schema.encoding}' is not supported (expected jsonschema or no schema)`);const e=new TextDecoder;let n=new Map,s=r=>JSON.parse(e.decode(r));if(t.schema!=null){const r=t.schema.data.length>0?JSON.parse(e.decode(t.schema.data)):void 0;if(r!=null){if(typeof r!="object")throw new Error(`Invalid schema, expected JSON object, got ${typeof r}`);const{datatypes:o,postprocessValue:d}=X(r,t.schema.name);n=o,s=m=>d(JSON.parse(e.decode(m)))}}return{deserialize:s,datatypes:n}}if(t.messageEncoding==="flatbuffer"){if(t.schema?.encoding!=="flatbuffer")throw new Error(`Message encoding ${t.messageEncoding} with ${t.schema==null?"no encoding":`schema encoding '${t.schema.encoding}'`} is not supported (expected flatbuffer)`);return ee(t.schema.name,t.schema.data)}if(t.messageEncoding==="protobuf"){if(t.schema?.encoding!=="protobuf")throw new Error(`Message encoding ${t.messageEncoding} with ${t.schema==null?"no encoding":`schema encoding '${t.schema.encoding}'`} is not supported (expected protobuf)`);return se(t.schema.name,t.schema.data)}if(t.messageEncoding==="ros1"){if(t.schema?.encoding!=="ros1msg")throw new Error(`Message encoding ${t.messageEncoding} with ${t.schema==null?"no encoding":`schema encoding '${t.schema.encoding}'`} is not supported (expected ros1msg)`);const e=new TextDecoder().decode(t.schema.data),n=(0,j.parse)(e),s=new Q.MessageReader(n);return{datatypes:F(n,t.schema.name),deserialize:r=>s.readMessage(r)}}if(t.messageEncoding==="cdr"){if(t.schema?.encoding!=="ros2msg"&&t.schema?.encoding!=="ros2idl")throw new Error(`Message encoding ${t.messageEncoding} with ${t.schema==null?"no encoding":`schema encoding '${t.schema.encoding}'`} is not supported (expected "ros2msg" or "ros2idl")`);const e=new TextDecoder().decode(t.schema.data),s=t.schema.encoding==="ros2idl"?(0,j.parseRos2idl)(e):(0,j.parse)(e,{ros2:!0}),r=new q.MessageReader(s);return{datatypes:F(s,t.schema.name),deserialize:o=>r.readMessage(o)}}throw new Error(`Unsupported encoding ${t.messageEncoding}`)}let ne;async function J(){return await(ne??=re())}async function re(){const[t,e,n]=await Promise.all([Promise.all([l.e(7372),l.e(3349)]).then(l.t.bind(l,3349,23)).then(async s=>(await s.isLoaded,s.decompress)),Promise.all([l.e(7372),l.e(3400)]).then(l.t.bind(l,3400,23)).then(async s=>(await s.default.isLoaded,s.default)),Promise.all([l.e(2984),l.e(3463)]).then(l.bind(l,94789)).then(async s=>await s.default.init())]);return{lz4:(s,r)=>e(s,Number(r)),bz2:(s,r)=>n.decompress(s,Number(r),{small:!1}),zstd:(s,r)=>t(s,Number(r))}}class ae{file;constructor(e){this.file=e}async size(){return BigInt(this.file.size)}async read(e,n){if(e+n>this.file.size)throw new Error(`Read of ${n} bytes at offset ${e} exceeds file size ${this.file.size}`);return new Uint8Array(await this.file.slice(Number(e),Number(e+n)).arrayBuffer())}}var y=l(44668),oe="../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIndexedIterableSource.ts";const V=O.ZP.getLogger(oe);class P{#e;#t=new Map;#s;#n;constructor(e){this.#e=e}async initialize(){let e,n;for(const a of this.#e.chunkIndexes)(e==null||a.messageStartTime<e)&&(e=a.messageStartTime),(n==null||a.messageEndTime>n)&&(n=a.messageEndTime);const s=new Map,r=new Map,o=new Map,d=[],m=new Map;for(const a of this.#e.channelsById.values()){const u=this.#e.schemasById.get(a.schemaId);if(a.schemaId!==0&&u==null){d.push({severity:"error",message:`Missing schema info for schema id ${a.schemaId} (channel ${a.id}, topic ${a.topic})`});continue}let c;try{c=k({messageEncoding:a.messageEncoding,schema:u})}catch(g){d.push({severity:"error",message:`Error in topic ${a.topic} (channel ${a.id}): ${g.message}`,error:g});continue}this.#t.set(a.id,{channel:a,parsedChannel:c,schemaName:u?.name});let f=r.get(a.topic);if(!f){f={name:a.topic,schemaName:u?.name},r.set(a.topic,f);const g=this.#e.statistics?.channelMessageCounts.get(a.id);g!=null&&s.set(a.topic,{numMessages:Number(g)})}const h=a.metadata.get("callerid")??String(a.id);let w=m.get(a.topic);w||(w=new Set,m.set(a.topic,w)),w.add(h);for(const[g,b]of c.datatypes)o.set(g,b)}return this.#s=(0,y.fromNanoSec)(e??0n),this.#n=(0,y.fromNanoSec)(n??e??0n),{start:this.#s,end:this.#n,topics:[...r.values()],datatypes:o,profile:this.#e.header.profile,problems:d,publishersByTopic:m,topicStats:s}}async*messageIterator(e){const n=e.topics,s=e.start??this.#s,r=e.end??this.#n;if(!(n.length===0||!s||!r))for await(const o of this.#e.readMessages({startTime:(0,y.toNanoSec)(s),endTime:(0,y.toNanoSec)(r),topics:n})){const d=this.#t.get(o.channelId);if(!d){yield{type:"problem",problem:{message:`Received message on channel ${o.channelId} without prior channel info`,severity:"error"}};continue}try{yield{type:"message-event",msgEvent:{topic:d.channel.topic,receiveTime:(0,y.fromNanoSec)(o.logTime),publishTime:(0,y.fromNanoSec)(o.publishTime),message:d.parsedChannel.deserialize(o.data),sizeInBytes:o.data.byteLength,schemaName:d.schemaName??""}}}catch(m){yield{type:"problem",problem:{message:`Error decoding message on ${d.channel.topic}`,error:m,severity:"error"}}}}}async getBackfillMessages(e){const{topics:n,time:s}=e,r=[];for(const o of n)for await(const d of this.#e.readMessages({endTime:(0,y.toNanoSec)(s),topics:[o],reverse:!0})){const m=this.#t.get(d.channelId);if(!m){V.error(`Missing channel info for channel: ${d.channelId} on topic: ${o}`);continue}try{r.push({topic:m.channel.topic,receiveTime:(0,y.fromNanoSec)(d.logTime),publishTime:(0,y.fromNanoSec)(d.publishTime),message:m.parsedChannel.deserialize(d.data),sizeInBytes:d.data.byteLength,schemaName:m.schemaName??""})}catch(a){V.error(a)}break}return r.sort((o,d)=>(0,y.compare)(o.receiveTime,d.receiveTime)),r}}var Z=l(76635);const ie=365*24*60*60;class H{#e;#t;#s;#n;constructor(e){this.#e=e}async initialize(){if(this.#e.size>1024*1024*1024)throw new Error("Unable to open unindexed MCAP file; unindexed files are limited to 1GB");const e=await J(),n=this.#e.stream.getReader(),s=[],r=new Set,o=new Map,d=new Map,m=new Map;let a,u,c;function f(p){switch(p.type){default:break;case"Header":{c=p.profile;break}case"Schema":{const E=d.get(p.id);if(E&&!(0,Z.isEqual)(E,p))throw new Error(`differing schemas for id ${p.id}`);d.set(p.id,p);break}case"Channel":{const E=m.get(p.id);if(E){if(!(0,Z.isEqual)(E.channel,p))throw new Error(`differing channel infos for id ${p.id}`);break}if(r.has(p.id))break;const B=d.get(p.schemaId);if(p.schemaId!==0&&!B)throw new Error(`Encountered channel with schema id ${p.schemaId} but no prior schema`);try{const I=k({messageEncoding:p.messageEncoding,schema:B});m.set(p.id,{channel:p,parsedChannel:I,schemaName:B?.name}),o.set(p.id,[])}catch(I){r.add(p.id),s.push({severity:"error",message:`Error in topic ${p.topic} (channel ${p.id}): ${I.message}`,error:I})}break}case"Message":{const E=p.channelId,B=m.get(E),I=o.get(E);if(!B||!I){if(r.has(E))break;throw new Error(`message for channel ${E} with no prior channel info`)}const S=(0,y.fromNanoSec)(p.logTime);(!a||(0,y.isLessThan)(S,a))&&(a=S),(!u||(0,y.isGreaterThan)(S,u))&&(u=S),I.push({topic:B.channel.topic,receiveTime:S,publishTime:(0,y.fromNanoSec)(p.publishTime),message:B.parsedChannel.deserialize(p.data),sizeInBytes:p.data.byteLength,schemaName:B.schemaName??""});break}}}const h=new R.c1({decompressHandlers:e});for(let p;p=await n.read(),!p.done;){h.append(p.value);for(let E;E=h.nextRecord();)f(E)}this.#t=o;const w=[],g=new Map,b=new Map,v=new Map;for(const{channel:p,parsedChannel:E,schemaName:B}of m.values()){w.push({name:p.topic,schemaName:B});const I=o.get(p.id)?.length;I!=null&&g.set(p.topic,{numMessages:I});const S=p.metadata.get("callerid")??String(p.id);let $=v.get(p.topic);$||($=new Set,v.set(p.topic,$)),$.add(S);for(const[ue,he]of E.datatypes)b.set(ue,he)}if(this.#s=a??{sec:0,nsec:0},this.#n=u??{sec:0,nsec:0},(0,y.toSec)((0,y.subtract)(this.#n,this.#s))>ie){const p=(0,y.toRFC3339String)(this.#s),E=(0,y.toRFC3339String)(this.#n);s.push({message:"This file has an abnormally long duration.",tip:`The start ${p} and end ${E} are greater than a year.`,severity:"warn"})}return s.push({message:"This file is unindexed. Unindexed files may have degraded performance.",tip:"See the mcap spec: https://mcap.dev/specification/index.html#summary-section",severity:"warn"}),{start:this.#s,end:this.#n,topics:w,datatypes:b,profile:c,problems:s,publishersByTopic:v,topicStats:g}}async*messageIterator(e){if(!this.#t)throw new Error("initialization not completed");const n=e.topics,s=e.start??this.#s,r=e.end??this.#n;if(n.length===0||!s||!r)return;const o=new Set(n),d=[];for(const[m,a]of this.#t)for(const u of a)(0,y.isTimeInRangeInclusive)(u.receiveTime,s,r)&&o.has(u.topic)&&d.push({type:"message-event",connectionId:m,msgEvent:u});d.sort((m,a)=>(0,y.compare)(m.msgEvent.receiveTime,a.msgEvent.receiveTime)),yield*d}async getBackfillMessages(e){if(!this.#t)throw new Error("initialization not completed");const n=e.topics,s=new Map;for(const[r,o]of this.#t)for(const d of o)(0,y.compare)(d.receiveTime,e.time)<=0&&n.includes(d.topic)&&s.set(d.topic,d);return[...s.values()]}}var ce=l(20865),de=l(88499);class pe{#e;constructor(e){const n=new ce.Z(e);this.#e=new de.Z({fileReader:n,cacheSizeInBytes:1024*1024*200})}async open(){await this.#e.open()}async size(){return BigInt(this.#e.size())}async read(e,n){if(e+n>Number.MAX_SAFE_INTEGER)throw new Error(`Read too large: offset ${e}, size ${n}`);return await this.#e.read(Number(e),Number(n))}}var me="../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIterableSource.ts";const fe=O.ZP.getLogger(me);async function G(t){const e=await J();try{const n=await R.RS.Initialize({readable:t,decompressHandlers:e});return n.chunkIndexes.length===0||n.channelsById.size===0?void 0:n}catch(n){fe.error(n);return}}class W{#e;#t;constructor(e){this.#e=e}async initialize(){const e=this.#e;switch(e.type){case"file":{await e.file.slice(0,1).arrayBuffer();const n=new ae(e.file),s=await G(n);s?this.#t=new P(s):this.#t=new H({size:e.file.size,stream:e.file.stream()});break}case"url":{const n=new pe(e.url);await n.open();const s=await G(n);if(s)this.#t=new P(s);else{const r=await fetch(e.url);if(!r.body)throw new Error(`Unable to stream remote file. <${e.url}>`);const o=r.headers.get("content-length");if(o==null)throw new Error(`Remote file is missing Content-Length header. <${e.url}>`);this.#t=new H({size:parseInt(o),stream:r.body})}break}}return await this.#t.initialize()}messageIterator(e){if(!this.#t)throw new Error("Invariant: uninitialized");return this.#t.messageIterator(e)}async getBackfillMessages(e){if(!this.#t)throw new Error("Invariant: uninitialized");return await this.#t.getBackfillMessages(e)}}function le(t){if(t.file){const e=new W({type:"file",file:t.file}),n=new A.a(e);return M.sj(n)}else if(t.url){const e=new W({type:"url",url:t.url}),n=new A.a(e);return M.sj(n)}throw new Error("file or url required")}M.Jj(le)}}]);

//# sourceMappingURL=studio-8161.js.map