{"version":3,"file":"studio-8161.js","mappings":"kJAaO,SAASA,EACdC,EACAC,EAAoB,CAUpB,MAAMC,EAAkC,IAAI,IAE5C,SAASC,EACPC,EACAC,EACAC,EAAiB,CAEjB,IAAIC,EAAkEC,GAAUA,EAChF,MAAMC,EAAmC,CAAC,EAC1C,GAAIL,EAAO,OAAS,SAClB,MAAM,IAAI,MACR,wCAAwCC,UAAiB,KAAK,UAAUD,EAAO,IAAI,GAAG,EAG1F,SAAW,CAACM,EAAWC,CAAW,IAAK,OAAO,QAC5CP,EAAO,UAAqD,EAC3D,CACD,GAAI,MAAM,QAAQO,EAAY,KAAK,EACjC,GAAIA,EAAY,MAAM,MAAOC,GAAgB,OAAOA,EAAY,OAAU,QAAQ,EAAG,CACnF,UAAWA,KAAeD,EAAY,MACpCF,EAAO,KAAK,CACV,KAAMG,EAAY,MAClB,KAAM,SACN,WAAY,GACZ,MAAOA,EAAY,K,CACpB,EAEHH,EAAO,KAAK,CAAE,KAAMC,EAAW,KAAM,QAAS,CAAC,EAC/C,Q,KAEA,OAAM,IAAI,MACR,wBAAwBJ,EACrB,OAAOI,CAAS,EAChB,KAAK,GAAG,+CAA+C,EAIhE,OAAQC,EAAY,KAAM,CACxB,IAAK,UACHF,EAAO,KAAK,CAAE,KAAMC,EAAW,KAAM,MAAO,CAAC,EAC7C,MACF,IAAK,SACH,OAAQC,EAAY,gBAAiB,CACnC,KAAK,OACHF,EAAO,KAAK,CAAE,KAAMC,EAAW,KAAM,QAAS,CAAC,EAC/C,MACF,IAAK,SAAU,CACbD,EAAO,KAAK,CAAE,KAAMC,EAAW,KAAM,QAAS,QAAS,EAAK,CAAC,EAC7D,MAAMG,EAAkBN,EACxBA,EAAqBC,GAAU,CAC7B,MAAMM,EAAMN,EAAME,CAAS,EAC3B,GAAI,OAAOI,GAAQ,SAAU,CAC3B,MAAMC,EAAU,IAAI,WAAWC,EAAO,OAAOF,CAAG,CAAC,EACjD,GAAIE,EAAO,OAAOF,EAAKC,EAAS,CAAC,IAAMA,EAAQ,WAC7C,MAAM,IAAI,MACR,oCAAoCT,EAAQ,OAAOI,CAAS,EAAE,KAAK,GAAG,GAAG,EAG7EF,EAAME,CAAS,EAAIK,C,CAErB,OAAOF,EAAgBL,CAAK,CAC9B,EACA,K,CAEF,QACE,MAAM,IAAI,MACR,+BAA+B,KAAK,UAClCG,EAAY,eAAe,QACrBL,EAAQ,OAAOI,CAAS,EAAE,KAAK,GAAG,GAAG,C,CAGnD,MACF,IAAK,SACL,IAAK,UACHD,EAAO,KAAK,CAAE,KAAMC,EAAW,KAAM,SAAU,CAAC,EAChD,MACF,IAAK,SAAU,CACb,MAAMO,EAAiB,GAAGZ,KAAYK,IAChCQ,EAA0Bf,EAC9BQ,EACAM,EACAX,EAAQ,OAAOI,CAAS,CAAC,EAErBG,EAAkBN,EACxBA,EAAqBC,GAAU,CAC7B,MAAMW,EAAaX,EAAME,CAAS,EAClC,OAAIS,GAAc,MAAa,OAAOA,GAAe,WACnDX,EAAME,CAAS,EAAIQ,EAAwBC,CAAqC,GAE3EN,EAAgBL,CAAK,CAC9B,EACAC,EAAO,KAAK,CAAE,KAAMC,EAAW,KAAMO,EAAgB,UAAW,EAAK,CAAC,EACtE,K,CAEF,IAAK,QAAS,CACZ,MAAMG,EAAaT,EAAY,MAC/B,OAAQS,EAAW,KAAM,CACvB,IAAK,UACHX,EAAO,KAAK,CAAE,KAAMC,EAAW,KAAM,OAAQ,QAAS,EAAK,CAAC,EAC5D,MACF,IAAK,SACH,GAAIU,EAAW,iBAAmB,KAChC,MAAM,IAAI,MACR,+BAA+B,KAAK,UAClCA,EAAW,eAAe,oBACRd,EAAQ,OAAOI,CAAS,EAAE,KAAK,GAAG,GAAG,EAG7DD,EAAO,KAAK,CAAE,KAAMC,EAAW,KAAM,SAAU,QAAS,EAAK,CAAC,EAC9D,MACF,IAAK,SACL,IAAK,UACHD,EAAO,KAAK,CAAE,KAAMC,EAAW,KAAM,UAAW,QAAS,EAAK,CAAC,EAC/D,MACF,IAAK,SAAU,CACb,MAAMO,EAAiB,GAAGZ,KAAYK,IAChCW,EAAuBlB,EAC3BQ,EAAY,MACZM,EACAX,EAAQ,OAAOI,CAAS,CAAC,EAErBG,EAAkBN,EACxBA,EAAqBC,GAAU,CAC7B,MAAMc,EAAMd,EAAME,CAAS,EAC3B,OAAI,MAAM,QAAQY,CAAG,IACnBd,EAAME,CAAS,EAAIY,EAAI,IAAID,CAAoB,GAE1CR,EAAgBL,CAAK,CAC9B,EACAC,EAAO,KAAK,CACV,KAAMC,EACN,KAAMO,EACN,UAAW,GACX,QAAS,E,CACV,EACD,K,CAEF,QACE,MAAM,IAAI,MACR,oBAAoB,KAAK,UAAUG,EAAW,IAAI,oBAAoBd,EACnE,OAAOI,CAAS,EAChB,KAAK,GAAG,GAAG,C,CAGpB,K,CAEF,IAAK,OACL,QACE,MAAM,IAAI,MACR,oBAAoB,KAAK,UAAUC,EAAY,IAAI,SAASL,EACzD,OAAOI,CAAS,EAChB,KAAK,GAAG,GAAG,C,EAItB,OAAAR,EAAU,IAAIG,EAAU,CAAE,YAAaI,CAAO,CAAC,EACxCF,CACT,CAEA,MAAMgB,EAAmBpB,EAAmBH,EAAgBC,EAAc,CAAC,CAAC,EAC5E,MAAO,CAAE,UAAAC,EAAW,iBAAAqB,CAAiB,CACvC,C,wBCjLA,SAASC,EAA6BC,EAAY,CAChD,OAAQA,EAAM,CACZ,IAAK,SACH,MAAO,UACT,IAAK,QACH,MAAO,UACT,IAAK,QACL,IAAK,SACL,IAAK,WACH,MAAO,QACT,IAAK,SACL,IAAK,UACH,MAAO,SACT,IAAK,QACL,IAAK,SACL,IAAK,WACH,MAAO,QACT,IAAK,SACL,IAAK,UACH,MAAO,SACT,IAAK,OACH,MAAO,OACT,IAAK,SACH,MAAO,Q,CAEX,MAAM,IAAI,MAAM,sCAAsCA,GAAM,CAC9D,CAEO,SAASC,EAAgBrB,EAAgB,CAC9C,OAAOA,EAAS,QAAQ,MAAO,EAAE,CACnC,CAEO,SAASsB,EACdzB,EACAuB,EAAqB,CAErB,MAAMG,EAAwC,CAAC,EAE/C1B,EAAU,IAAIwB,EAAgBD,EAAK,QAAQ,EAAG,CAAE,YAAAG,CAAY,CAAC,EAC7D,UAAWC,KAASJ,EAAK,YACvB,GAAII,EAAM,wBAAwB,SAAiB,CACjD,SAAW,CAACC,EAAMtB,CAAK,IAAK,OAAO,QAAQqB,EAAM,aAAa,MAAM,EAIlED,EAAY,KAAK,CAAE,KAAAE,EAAM,KAAM,QAAS,WAAY,GAAM,MAAAtB,CAAM,CAAC,EAEnEoB,EAAY,KAAK,CAAE,KAAM,QAAS,KAAMC,EAAM,IAAK,CAAC,C,SAC3CA,EAAM,aAAc,CAC7B,MAAME,EAAWL,EAAgBG,EAAM,aAAa,QAAQ,EAC5DD,EAAY,KAAK,CACf,KAAMG,EACN,KAAMF,EAAM,KACZ,UAAW,GACX,QAASA,EAAM,Q,CAChB,EAII3B,EAAU,IAAI6B,CAAQ,GACzBJ,EAA+BzB,EAAW2B,EAAM,YAAY,C,SAErDA,EAAM,OAAS,QAAS,CACjC,GAAIA,EAAM,SACR,MAAM,IAAI,MAAM,4CAA4C,EAE9DD,EAAY,KAAK,CAAE,KAAM,QAAS,KAAMC,EAAM,KAAM,QAAS,EAAK,CAAC,C,MAEnED,EAAY,KAAK,CACf,KAAMJ,EAA6BK,EAAM,IAAI,EAC7C,KAAMA,EAAM,KACZ,QAASA,EAAM,Q,CAChB,CAGP,C,2DCzEA,SAASG,EAAmBP,EAAc,CACxC,OAAQA,EAAM,CACZ,KAAK,KAAS,KACZ,MAAO,OACT,KAAK,KAAS,KACZ,MAAO,OACT,KAAK,KAAS,MACd,KAAK,KAAS,MACZ,MAAO,QACT,KAAK,KAAS,MACZ,MAAO,QACT,KAAK,KAAS,OACZ,MAAO,SACT,KAAK,KAAS,IACZ,MAAO,QACT,KAAK,KAAS,KACZ,MAAO,SACT,KAAK,KAAS,KACZ,MAAO,QACT,KAAK,KAAS,MACZ,MAAO,SACT,KAAK,KAAS,MACZ,MAAO,UACT,KAAK,KAAS,OACZ,MAAO,UACT,KAAK,KAAS,OACZ,MAAO,SACT,KAAK,KAAS,OACd,KAAK,KAAS,IACd,KAAK,KAAS,MACd,KAAK,KAAS,MACZ,MAAM,IAAI,MAAM,GAAGA,yBAA4B,EACjD,KAAK,KAAS,KACd,KAAK,KAAS,YACZ,MAAM,IAAI,MAAM,2BAA2B,C,CAEjD,CAGA,SAASQ,EAAiBC,EAAiD,CACzE,GAAI,OAAOA,GAAc,SACvB,OAAOA,EAET,MAAM,IAAI,MAAM,0BAA0B,OAAOA,GAAW,CAC9D,CAEA,SAASC,EAAa/B,EAAiByB,EAAa,CAClD,MAAMpB,EAAmC,CAAC,EAC1C,OAAQoB,EAAM,MAAM,SAAU,CAC5B,KAAK,KAAS,MACd,KAAK,KAAS,KACd,KAAK,KAAS,KACd,KAAK,KAAS,MACd,KAAK,KAAS,MACd,KAAK,KAAS,OACd,KAAK,KAAS,IACd,KAAK,KAAS,KACd,KAAK,KAAS,KACd,KAAK,KAAS,MACd,KAAK,KAAS,MACd,KAAK,KAAS,OACd,KAAK,KAAS,OACd,KAAK,KAAS,KAAM,CAClB,MAAMO,EAAaJ,EAAmBH,EAAM,KAAK,QAAQ,EAGzD,GAAIA,EAAM,KAAK,QAAU,GAAI,CAC3B,MAAMQ,EAAQjC,EAAO,MAAMyB,EAAM,KAAK,KAAK,GAAG,OAC9C,GAAIQ,GAAS,KACX,MAAM,IAAI,MACR,sDACEjC,EAAO,MAAMyB,EAAM,KAAK,KAAK,GAAG,MAChC,EAGN,UAAWS,KAAWD,EACpB5B,EAAO,KAAK,CACV,KAAMwB,EAAiBK,EAAQ,IAAI,EACnC,KAAMF,EACN,WAAY,GACZ,MAAOE,EAAQ,K,CAChB,C,CAGL7B,EAAO,KAAK,CAAE,KAAMwB,EAAiBJ,EAAM,IAAI,EAAG,KAAMO,CAAW,CAAC,EACpE,K,CAEF,KAAK,KAAS,OACZ,OAAQP,EAAM,KAAK,QAAS,CAC1B,KAAK,KAAS,OACd,KAAK,KAAS,MACd,KAAK,KAAS,MACd,KAAK,KAAS,KACZ,MAAM,IAAI,MAAM,iEAAiE,EACnF,KAAK,KAAS,IACZpB,EAAO,KAAK,CACV,KAAMwB,EAAiBJ,EAAM,IAAI,EACjC,KAAMI,EAAiB7B,EAAO,QAAQyB,EAAM,KAAK,KAAK,GAAG,IAAI,EAC7D,UAAW,GACX,QAAS,E,CACV,EACD,MACF,QAAS,CACP,MAAMJ,EAAOO,EAAmBH,EAAM,KAAK,OAAO,EAGlD,GAAIA,EAAM,KAAK,QAAU,GAAI,CAC3B,MAAMQ,EAAQjC,EAAO,MAAMyB,EAAM,KAAK,KAAK,GAAG,OAC9C,GAAIQ,GAAS,KACX,MAAM,IAAI,MAAM,gBAAgB,EAElC,UAAWC,KAAWD,EACpB5B,EAAO,KAAK,CACV,KAAMwB,EAAiBK,EAAQ,IAAI,EACnC,KAAAb,EACA,WAAY,GACZ,MAAOa,EAAQ,K,CAChB,C,CAGL7B,EAAO,KAAK,CAAE,KAAMwB,EAAiBJ,EAAM,IAAI,EAAG,KAAAJ,EAAM,QAAS,EAAK,CAAC,EACvE,K,EAGJ,MACF,KAAK,KAAS,IACZhB,EAAO,KAAK,CACV,KAAMwB,EAAiBJ,EAAM,IAAI,EACjC,KAAMI,EAAiB7B,EAAO,QAAQyB,EAAM,KAAK,KAAK,GAAG,IAAI,EAC7D,UAAW,E,CACZ,EACD,MACF,KAAK,KAAS,MACd,KAAK,KAAS,MACd,KAAK,KAAS,YACd,KAAK,OACH,MAAM,IAAI,MAAM,gEAAgE,C,CAEpF,OAAOpB,CACT,CAQO,SAAS8B,GACdC,EACAC,EAAuB,CAKvB,MAAMvC,EAAkC,IAAI,IACtCwC,EAAe,IAAI,KAAWD,CAAW,EACzCE,EAAY,KAAO,gBAAgBD,CAAY,EAC/CtC,EAASuC,EAAU,OAAO,EAEhC,IAAIC,EAAY,GAChB,QAASC,EAAc,EAAGA,EAAczC,EAAO,QAAQ,OAAQ,EAAEyC,EAAa,CAC5E,MAAMC,EAAS1C,EAAO,QAAQyC,CAAW,EACrCC,GAAQ,OAASN,IACnBI,EAAYC,GAEd,IAAIpC,EAAmC,CAAC,EACxC,GAAIqC,GAAQ,QAAU,KAGtB,WAAWjB,KAASiB,EAAO,OACzBrC,EAASA,EAAO,OAAO0B,EAAa/B,EAAQyB,CAAK,CAAC,EAEpD3B,EAAU,IAAI+B,EAAiBa,EAAO,IAAI,EAAG,CAAE,YAAarC,CAAO,CAAC,E,CAEtE,GAAImC,IAAc,IACZxC,EAAO,WAAW,OAASoC,EAC7B,MAAM,IAAI,MACR,SAASA,0CAAmDpC,EAAO,WAAW,QAAQ,EAS5F,MAAM2C,EALS,IAAI,KAAOJ,CAAS,EAKX,eAAeC,EAA6B,EAAI,EAaxE,MAAO,CAAE,UAAA1C,EAAW,YAZC8C,GAA4B,CAC/C,MAAMC,EAAa,IAAI,KACrB,IAAI,WAAWD,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,CAAC,EAE/DE,EAAQ,IAAI,KAChBD,EACAL,EACAK,EAAW,UAAUA,EAAW,SAAS,CAAC,EAAIA,EAAW,SAAS,EAClE,EAAK,EAEP,OAAOF,EAASG,CAAK,CACvB,CACgC,CAClC,C,gBCrMO,SAASC,GACdX,EACAY,EAAsB,CAKtB,MAAMC,EAAgB,qBAAkB,OAAOD,CAAU,EAEnDE,EAAO,SAAgB,eAAeD,CAAa,EACzDC,EAAK,WAAW,EAChB,MAAMC,EAAWD,EAAK,WAAWd,CAAU,EAMrCgB,EACJ/B,GACG,CACH,GAAI,CAACA,GAAQ,EAAEA,aAAgB,UAC7B,OAGF,UAAWI,KAASJ,EAAK,YACnBI,EAAM,OAAS,UACjBA,EAAM,KAAO,MACJA,EAAM,OAAS,UACxBA,EAAM,KAAO,QAGjBJ,EAAK,MAAM,EACX,MAAMgC,EAAehC,EAAK,SACpBiC,EAAmC,CAACC,EAASC,IAAY,CAC7D,MAAMC,EAASJ,EAAa,KAAKhC,EAAMkC,EAASC,CAAO,EACjD,CAAE,IAAAE,EAAK,KAAAC,CAAK,EAAIF,EACtB,GAAI,OAAOC,GAAQ,UAAY,OAAOC,GAAS,SAC7C,OAAOF,EAET,GAAIC,EAAM,OAAO,OAAO,gBAAgB,EACtC,MAAM,IAAI,MACR,gFAAgFA,YAAcC,IAAO,EAGzG,MAAO,CAAE,IAAK,OAAOD,CAAG,EAAG,KAAAC,CAAK,CAClC,EACAtC,EAAK,SAAWiC,CAClB,EAEAF,EAAYF,EAAK,OAAO,4BAA4B,CAAC,EACrDE,EAAYF,EAAK,OAAO,2BAA2B,CAAC,EAEpD,MAAMU,EAAeC,GACZV,EAAS,SACdA,EAAS,OAAO,IAAI,WAAWU,EAAK,OAAQA,EAAK,WAAYA,EAAK,UAAU,CAAC,EAC7E,CAAE,SAAU,EAAK,CAAC,EAIhB/D,EAAkC,IAAI,IAG5C,GAFAyB,EAA+BzB,EAAWqD,CAAQ,EAE9C,CAACrD,EAAU,IAAIsC,CAAU,EAC3B,MAAM,IAAI,MACR,kDAAkDA,wDAAiEd,EACjH6B,EAAS,QAAQ,KACd,EAIT,MAAO,CAAE,YAAAS,EAAa,UAAA9D,CAAU,CAClC,CC7DA,SAASgE,EACPC,EACAC,EAAgB,CAEhB,MAAMlE,EAAkC,IAAI,IAC5C,OAAAiE,EAAkB,QAAQ,CAAC,CAAE,KAAArC,EAAM,YAAAF,CAAY,EAAGyC,IAAU,CACtDA,IAAU,EACZnE,EAAU,IAAIkE,EAAU,CAAE,KAAMA,EAAU,YAAAxC,CAAY,CAAC,EAC9CE,GAAQ,MACjB5B,EAAU,IAAI4B,EAAM,CAAE,KAAAA,EAAM,YAAAF,CAAY,CAAC,CAE7C,CAAC,EACM1B,CACT,CAUO,SAASoE,EAAaC,EAAgB,CAC3C,GAAIA,EAAQ,kBAAoB,OAAQ,CACtC,GAAIA,EAAQ,QAAU,MAAaA,EAAQ,OAAO,WAAa,aAC7D,MAAM,IAAI,MACR,oBAAoBA,EAAQ,yCAAyCA,EAAQ,OAAO,+DAA+D,EAGvJ,MAAMC,EAAc,IAAI,YACxB,IAAItE,EAAkC,IAAI,IACtC8D,EAAeC,GAA0B,KAAK,MAAMO,EAAY,OAAOP,CAAI,CAAC,EAChF,GAAIM,EAAQ,QAAU,KAAW,CAC/B,MAAMnE,EACJmE,EAAQ,OAAO,KAAK,OAAS,EACzB,KAAK,MAAMC,EAAY,OAAOD,EAAQ,OAAO,IAAI,CAAC,EAClD,OACN,GAAInE,GAAU,KAAW,CACvB,GAAI,OAAOA,GAAW,SACpB,MAAM,IAAI,MAAM,6CAA6C,OAAOA,GAAQ,EAE9E,KAAM,CAAE,UAAWqE,EAAiB,iBAAAlD,CAAiB,EAAIxB,EACvDK,EACAmE,EAAQ,OAAO,IAAI,EAErBrE,EAAYuE,EACZT,EAAeC,GACb1C,EAAiB,KAAK,MAAMiD,EAAY,OAAOP,CAAI,CAAC,CAA4B,C,EAGtF,MAAO,CAAE,YAAAD,EAAa,UAAA9D,CAAU,C,CAGlC,GAAIqE,EAAQ,kBAAoB,aAAc,CAC5C,GAAIA,EAAQ,QAAQ,WAAa,aAC/B,MAAM,IAAI,MACR,oBAAoBA,EAAQ,wBAC1BA,EAAQ,QAAU,KACd,cACA,oBAAoBA,EAAQ,OAAO,oDACA,EAG7C,OAAOhC,GAAsBgC,EAAQ,OAAO,KAAMA,EAAQ,OAAO,IAAI,C,CAGvE,GAAIA,EAAQ,kBAAoB,WAAY,CAC1C,GAAIA,EAAQ,QAAQ,WAAa,WAC/B,MAAM,IAAI,MACR,oBAAoBA,EAAQ,wBAC1BA,EAAQ,QAAU,KACd,cACA,oBAAoBA,EAAQ,OAAO,kDACF,EAG3C,OAAOpB,GAAoBoB,EAAQ,OAAO,KAAMA,EAAQ,OAAO,IAAI,C,CAGrE,GAAIA,EAAQ,kBAAoB,OAAQ,CACtC,GAAIA,EAAQ,QAAQ,WAAa,UAC/B,MAAM,IAAI,MACR,oBAAoBA,EAAQ,wBAC1BA,EAAQ,QAAU,KACd,cACA,oBAAoBA,EAAQ,OAAO,iDACH,EAG1C,MAAMnE,EAAS,IAAI,YAAY,EAAE,OAAOmE,EAAQ,OAAO,IAAI,EACrDJ,KAAoB,SAAuB/D,CAAM,EACjDsE,EAAS,IAAI,gBAAcP,CAAiB,EAClD,MAAO,CACL,UAAWD,EAA6BC,EAAmBI,EAAQ,OAAO,IAAI,EAC9E,YAAcN,GAASS,EAAO,YAAYT,CAAI,C,EAIlD,GAAIM,EAAQ,kBAAoB,MAAO,CACrC,GAAIA,EAAQ,QAAQ,WAAa,WAAaA,EAAQ,QAAQ,WAAa,UACzE,MAAM,IAAI,MACR,oBAAoBA,EAAQ,wBAC1BA,EAAQ,QAAU,KACd,cACA,oBAAoBA,EAAQ,OAAO,gEACY,EAGzD,MAAMnE,EAAS,IAAI,YAAY,EAAE,OAAOmE,EAAQ,OAAO,IAAI,EAGrDJ,EAFQI,EAAQ,OAAO,WAAa,aAGtC,gBAAanE,CAAM,KACnB,SAAuBA,EAAQ,CAAE,KAAM,EAAK,CAAC,EAE3CsE,EAAS,IAAI,gBAAkBP,CAAiB,EACtD,MAAO,CACL,UAAWD,EAA6BC,EAAmBI,EAAQ,OAAO,IAAI,EAC9E,YAAcN,GAASS,EAAO,YAAYT,CAAI,C,EAIlD,MAAM,IAAI,MAAM,wBAAwBM,EAAQ,iBAAiB,CACnE,CC9IA,IAAII,GACG,eAAeC,GAAsB,CAC1C,OAAO,MAAOD,KAAoBE,GAAwB,EAC5D,CAGA,eAAeA,IAAuB,CACpC,KAAM,CAACC,EAAgBC,EAAeC,CAAK,EAAI,MAAM,QAAQ,IAAI,CAC/D,6DAA8B,KAAK,MAAOC,IACxC,MAAMA,EAAI,SACHA,EAAI,WACZ,EACD,6DAA6B,KAAK,MAAOA,IACvC,MAAMA,EAAI,QAAQ,SACXA,EAAI,QACZ,EACD,yDAA6B,KAAK,MAAOA,GAAQ,MAAMA,EAAI,QAAQ,KAAK,CAAC,C,CAC1E,EAED,MAAO,CACL,IAAK,CAACjC,EAAQkC,IAAqBH,EAAc/B,EAAQ,OAAOkC,CAAgB,CAAC,EAEjF,IAAK,CAAClC,EAAQkC,IACZF,EAAM,WAAWhC,EAAQ,OAAOkC,CAAgB,EAAG,CAAE,MAAO,EAAM,CAAC,EAErE,KAAM,CAAClC,EAAQkC,IAAqBJ,EAAe9B,EAAQ,OAAOkC,CAAgB,CAAC,C,CAEvF,CC7BO,MAAMC,EAAa,CACG,KAA3B,YAA2BC,EAAY,CAAZ,UAAAA,CAAa,CACjC,MAAM,MAAI,CACf,OAAO,OAAO,KAAK,KAAK,IAAI,CAC9B,CACO,MAAM,KAAKC,EAAgBC,EAAY,CAC5C,GAAID,EAASC,EAAO,KAAK,KAAK,KAC5B,MAAM,IAAI,MACR,WAAWA,qBAAwBD,uBAA4B,KAAK,KAAK,MAAM,EAGnF,OAAO,IAAI,WACT,MAAM,KAAK,KAAK,MAAM,OAAOA,CAAM,EAAG,OAAOA,EAASC,CAAI,CAAC,EAAE,YAAY,CAAC,CAE9E,C,6GCEF,MAAMC,EAAM,KAAO,UAAU,EAAU,EAEhC,MAAMC,CAA0B,CACrCC,GACAC,GAAmB,IAAI,IAIvBC,GACAC,GAEA,YAAmBlB,EAA2B,CAC5C,KAAKe,GAAUf,CACjB,CAEO,MAAM,YAAU,CACrB,IAAImB,EACAC,EACJ,UAAWC,KAAS,KAAKN,GAAQ,cAC3BI,GAAa,MAAaE,EAAM,iBAAmBF,KACrDA,EAAYE,EAAM,mBAEhBD,GAAW,MAAaC,EAAM,eAAiBD,KACjDA,EAAUC,EAAM,gBAIpB,MAAMC,EAAa,IAAI,IACjBC,EAAe,IAAI,IACnB/F,EAA0B,IAAI,IAC9BgG,EAA4B,CAAC,EAC7BC,EAAoB,IAAI,IAE9B,UAAW5B,KAAW,KAAKkB,GAAQ,aAAa,OAAO,EAAG,CACxD,MAAMrF,EAAS,KAAKqF,GAAQ,YAAY,IAAIlB,EAAQ,QAAQ,EAC5D,GAAIA,EAAQ,WAAa,GAAKnE,GAAU,KAAW,CACjD8F,EAAS,KAAK,CACZ,SAAU,QACV,QAAS,qCAAqC3B,EAAQ,qBAAqBA,EAAQ,aAAaA,EAAQ,Q,CACzG,EACD,Q,CAGF,IAAI6B,EACJ,GAAI,CACFA,EAAgB9B,EAAa,CAAE,gBAAiBC,EAAQ,gBAAiB,OAAAnE,CAAO,CAAC,C,OAC1EiG,EAAP,CACAH,EAAS,KAAK,CACZ,SAAU,QACV,QAAS,kBAAkB3B,EAAQ,kBAAkBA,EAAQ,QAAQ8B,EAAM,UAC3E,MAAAA,C,CACD,EACD,Q,CAEF,KAAKX,GAAiB,IAAInB,EAAQ,GAAI,CAAE,QAAAA,EAAS,cAAA6B,EAAe,WAAYhG,GAAQ,IAAK,CAAC,EAE1F,IAAIkG,EAAQL,EAAa,IAAI1B,EAAQ,KAAK,EAC1C,GAAI,CAAC+B,EAAO,CACVA,EAAQ,CAAE,KAAM/B,EAAQ,MAAO,WAAYnE,GAAQ,IAAK,EACxD6F,EAAa,IAAI1B,EAAQ,MAAO+B,CAAK,EAErC,MAAMC,EAAc,KAAKd,GAAQ,YAAY,qBAAqB,IAAIlB,EAAQ,EAAE,EAC5EgC,GAAe,MACjBP,EAAW,IAAIzB,EAAQ,MAAO,CAAE,YAAa,OAAOgC,CAAW,CAAE,CAAC,C,CAOtE,MAAMC,EAAcjC,EAAQ,SAAS,IAAI,UAAU,GAAK,OAAOA,EAAQ,EAAE,EACzE,IAAIkC,EAAaN,EAAkB,IAAI5B,EAAQ,KAAK,EAC/CkC,IACHA,EAAa,IAAI,IACjBN,EAAkB,IAAI5B,EAAQ,MAAOkC,CAAU,GAEjDA,EAAW,IAAID,CAAW,EAG1B,SAAW,CAAC1E,EAAM4E,CAAQ,IAAKN,EAAc,UAC3ClG,EAAU,IAAI4B,EAAM4E,CAAQ,C,CAIhC,YAAKf,MAAS,eAAYE,GAAa,EAAE,EACzC,KAAKD,MAAO,eAAYE,GAAWD,GAAa,EAAE,EAE3C,CACL,MAAO,KAAKF,GACZ,IAAK,KAAKC,GACV,OAAQ,CAAC,GAAGK,EAAa,OAAO,CAAC,EACjC,UAAA/F,EACA,QAAS,KAAKuF,GAAQ,OAAO,QAC7B,SAAAS,EACA,kBAAAC,EACA,WAAAH,C,CAEJ,CAEO,MAAO,gBACZW,EAAyB,CAEzB,MAAMC,EAASD,EAAK,OACdE,EAAQF,EAAK,OAAS,KAAKhB,GAC3BmB,EAAMH,EAAK,KAAO,KAAKf,GAE7B,GAAI,EAAAgB,EAAO,SAAW,GAAK,CAACC,GAAS,CAACC,GAItC,gBAAiBnD,KAAW,KAAK8B,GAAQ,aAAa,CACpD,aAAW,aAAUoB,CAAK,EAC1B,WAAS,aAAUC,CAAG,EACtB,OAAAF,C,CACD,EAAG,CACF,MAAMG,EAAc,KAAKrB,GAAiB,IAAI/B,EAAQ,SAAS,EAC/D,GAAI,CAACoD,EAAa,CAChB,KAAM,CACJ,KAAM,UACN,QAAS,CACP,QAAS,+BAA+BpD,EAAQ,uCAChD,SAAU,O,GAGd,Q,CAEF,GAAI,CACF,KAAM,CACJ,KAAM,gBACN,SAAU,CACR,MAAOoD,EAAY,QAAQ,MAC3B,eAAa,eAAYpD,EAAQ,OAAO,EACxC,eAAa,eAAYA,EAAQ,WAAW,EAC5C,QAASoD,EAAY,cAAc,YAAYpD,EAAQ,IAAI,EAC3D,YAAaA,EAAQ,KAAK,WAC1B,WAAYoD,EAAY,YAAc,E,SAGnCV,EAAP,CACA,KAAM,CACJ,KAAM,UACN,QAAS,CACP,QAAS,6BAA6BU,EAAY,QAAQ,QAC1D,MAAAV,EACA,SAAU,O,IAKpB,CAEO,MAAM,oBAAoBM,EAA6B,CAC5D,KAAM,CAAE,OAAAC,EAAQ,KAAAI,CAAK,EAAIL,EAEnBM,EAA2B,CAAC,EAClC,UAAWX,KAASM,EAIlB,gBAAiBjD,KAAW,KAAK8B,GAAQ,aAAa,CACpD,WAAS,aAAUuB,CAAI,EACvB,OAAQ,CAACV,CAAK,EACd,QAAS,E,CACV,EAAG,CACF,MAAMS,EAAc,KAAKrB,GAAiB,IAAI/B,EAAQ,SAAS,EAC/D,GAAI,CAACoD,EAAa,CAChBxB,EAAI,MAAM,qCAAqC5B,EAAQ,uBAAuB2C,GAAO,EACrF,Q,CAGF,GAAI,CACFW,EAAS,KAAK,CACZ,MAAOF,EAAY,QAAQ,MAC3B,eAAa,eAAYpD,EAAQ,OAAO,EACxC,eAAa,eAAYA,EAAQ,WAAW,EAC5C,QAASoD,EAAY,cAAc,YAAYpD,EAAQ,IAAI,EAC3D,YAAaA,EAAQ,KAAK,WAC1B,WAAYoD,EAAY,YAAc,E,CACvC,C,OACMG,EAAP,CACA3B,EAAI,MAAM2B,CAAG,C,CAGf,K,CAGJ,OAAAD,EAAS,KAAK,CAACE,EAAGC,OAAM,WAAQD,EAAE,YAAaC,EAAE,WAAW,CAAC,EACtDH,CACT,C,gBClLF,MAAMI,GAAoB,IAAM,GAAK,GAAK,GAKnC,MAAMC,CAA4B,CACvCC,GACAC,GACA7B,GACAC,GAEA,YAAmBhC,EAAkB,CACnC,KAAK2D,GAAW3D,CAClB,CAEO,MAAM,YAAU,CACrB,GAAI,KAAK2D,GAAS,KAAO,KAAO,KAAO,KAGrC,MAAM,IAAI,MAAM,wEAAwE,EAE1F,MAAME,EAAqB,MAAM7C,EAAuB,EAElD8C,EAAe,KAAKH,GAAS,OAAO,UAAU,EAE9CrB,EAA4B,CAAC,EAC7ByB,EAAuB,IAAI,IAE3BC,EAAoB,IAAI,IACxBC,EAAc,IAAI,IAClBC,EAAkB,IAAI,IAK5B,IAAIjC,EACAC,EACAiC,EACJ,SAASC,EAAcC,EAAmC,CACxD,OAAQA,EAAO,KAAM,CACnB,QACE,MAEF,IAAK,SAAU,CACbF,EAAUE,EAAO,QACjB,K,CAGF,IAAK,SAAU,CACb,MAAMC,EAAiBL,EAAY,IAAII,EAAO,EAAE,EAChD,GAAIC,GACE,IAAC,WAAQA,EAAgBD,CAAM,EACjC,MAAM,IAAI,MAAM,4BAA4BA,EAAO,IAAI,EAG3DJ,EAAY,IAAII,EAAO,GAAIA,CAAM,EACjC,K,CAGF,IAAK,UAAW,CACd,MAAME,EAAeL,EAAgB,IAAIG,EAAO,EAAE,EAClD,GAAIE,EAAc,CAChB,GAAI,IAAC,WAAQA,EAAa,QAASF,CAAM,EACvC,MAAM,IAAI,MAAM,kCAAkCA,EAAO,IAAI,EAE/D,K,CAEF,GAAIN,EAAqB,IAAIM,EAAO,EAAE,EACpC,MAEF,MAAM7H,EAASyH,EAAY,IAAII,EAAO,QAAQ,EAC9C,GAAIA,EAAO,WAAa,GAAK,CAAC7H,EAC5B,MAAM,IAAI,MACR,sCAAsC6H,EAAO,8BAA8B,EAI/E,GAAI,CACF,MAAM7B,EAAgB9B,EAAa,CAAE,gBAAiB2D,EAAO,gBAAiB,OAAA7H,CAAO,CAAC,EACtF0H,EAAgB,IAAIG,EAAO,GAAI,CAC7B,QAASA,EACT,cAAA7B,EACA,WAAYhG,GAAQ,I,CACrB,EACDwH,EAAkB,IAAIK,EAAO,GAAI,CAAC,CAAC,C,OAC5B5B,EAAP,CACAsB,EAAqB,IAAIM,EAAO,EAAE,EAClC/B,EAAS,KAAK,CACZ,SAAU,QACV,QAAS,kBAAkB+B,EAAO,kBAAkBA,EAAO,QAAQ5B,EAAM,UACzE,MAAAA,C,CACD,C,CAEH,K,CAGF,IAAK,UAAW,CACd,MAAM+B,EAAYH,EAAO,UACnBlB,EAAce,EAAgB,IAAIM,CAAS,EAC3CnB,EAAWW,EAAkB,IAAIQ,CAAS,EAChD,GAAI,CAACrB,GAAe,CAACE,EAAU,CAC7B,GAAIU,EAAqB,IAAIS,CAAS,EACpC,MAEF,MAAM,IAAI,MAAM,uBAAuBA,8BAAsC,C,CAE/E,MAAMC,KAAc,eAAYJ,EAAO,OAAO,GAC1C,CAACpC,MAAa,cAAWwC,EAAaxC,CAAS,KACjDA,EAAYwC,IAEV,CAACvC,MAAW,iBAAcuC,EAAavC,CAAO,KAChDA,EAAUuC,GAGZpB,EAAS,KAAK,CACZ,MAAOF,EAAY,QAAQ,MAC3B,YAAAsB,EACA,eAAa,eAAYJ,EAAO,WAAW,EAC3C,QAASlB,EAAY,cAAc,YAAYkB,EAAO,IAAI,EAC1D,YAAaA,EAAO,KAAK,WACzB,WAAYlB,EAAY,YAAc,E,CACvC,EACD,K,EAGN,CAEA,MAAMrC,EAAS,IAAI,KAAiB,CAAE,mBAAA+C,CAAmB,CAAC,EAC1D,QAAS5D,EAASA,EAAS,MAAM6D,EAAa,KAAK,EAAI,CAAC7D,EAAO,MAAQ,CACrEa,EAAO,OAAOb,EAAO,KAAK,EAC1B,QAASoE,EAASA,EAASvD,EAAO,WAAW,GAC3CsD,EAAcC,CAAM,C,CAIxB,KAAKT,GAAsBI,EAE3B,MAAMhB,EAAkB,CAAC,EACnBZ,EAAa,IAAI,IACjB9F,EAA0B,IAAI,IAC9BiG,EAAoB,IAAI,IAE9B,SAAW,CAAE,QAAA5B,EAAS,cAAA6B,EAAe,WAAA5D,CAAW,IAAKsF,EAAgB,OAAO,EAAG,CAC7ElB,EAAO,KAAK,CAAE,KAAMrC,EAAQ,MAAO,WAAA/B,CAAW,CAAC,EAC/C,MAAM+D,EAAcqB,EAAkB,IAAIrD,EAAQ,EAAE,GAAG,OACnDgC,GAAe,MACjBP,EAAW,IAAIzB,EAAQ,MAAO,CAAE,YAAAgC,CAAY,CAAC,EAM/C,MAAMC,EAAcjC,EAAQ,SAAS,IAAI,UAAU,GAAK,OAAOA,EAAQ,EAAE,EACzE,IAAIkC,EAAaN,EAAkB,IAAI5B,EAAQ,KAAK,EAC/CkC,IACHA,EAAa,IAAI,IACjBN,EAAkB,IAAI5B,EAAQ,MAAOkC,CAAU,GAEjDA,EAAW,IAAID,CAAW,EAG1B,SAAW,CAAC1E,GAAM4E,EAAQ,IAAKN,EAAc,UAC3ClG,EAAU,IAAI4B,GAAM4E,EAAQ,C,CAQhC,GAJA,KAAKf,GAASE,GAAa,CAAE,IAAK,EAAG,KAAM,CAAE,EAC7C,KAAKD,GAAOE,GAAW,CAAE,IAAK,EAAG,KAAM,CAAE,KAEpB,YAAM,YAAS,KAAKF,GAAM,KAAKD,EAAM,CAAC,EACxC0B,GAAmB,CACpC,MAAMiB,KAAW,mBAAgB,KAAK3C,EAAM,EACtC4C,KAAS,mBAAgB,KAAK3C,EAAI,EAExCM,EAAS,KAAK,CACZ,QAAS,6CACT,IAAK,aAAaoC,aAAoBC,6BACtC,SAAU,M,CACX,C,CAGH,OAAArC,EAAS,KAAK,CACZ,QAAS,yEACT,IAAK,+EACL,SAAU,M,CACX,EAEM,CACL,MAAO,KAAKP,GACZ,IAAK,KAAKC,GACV,OAAAgB,EACA,UAAA1G,EACA,QAAA6H,EACA,SAAA7B,EACA,kBAAAC,EACA,WAAAH,C,CAEJ,CAEO,MAAO,gBACZW,EAAyB,CAEzB,GAAI,CAAC,KAAKa,GACR,MAAM,IAAI,MAAM,8BAA8B,EAGhD,MAAMZ,EAASD,EAAK,OACdE,EAAQF,EAAK,OAAS,KAAKhB,GAC3BmB,EAAMH,EAAK,KAAO,KAAKf,GAE7B,GAAIgB,EAAO,SAAW,GAAK,CAACC,GAAS,CAACC,EACpC,OAGF,MAAM0B,EAAY,IAAI,IAAI5B,CAAM,EAC1B6B,EAAiB,CAAC,EAExB,SAAW,CAACL,EAAWM,CAAS,IAAK,KAAKlB,GACxC,UAAWmB,KAAYD,KAEnB,0BAAuBC,EAAS,YAAa9B,EAAOC,CAAG,GACvD0B,EAAU,IAAIG,EAAS,KAAK,GAE5BF,EAAe,KAAK,CAClB,KAAM,gBACN,aAAcL,EACd,SAAAO,C,CACD,EAMPF,EAAe,KAAK,CAACtB,EAAGC,OAAM,WAAQD,EAAE,SAAS,YAAaC,EAAE,SAAS,WAAW,CAAC,EAErF,MAAOqB,CACT,CAEO,MAAM,oBAAoB9B,EAA6B,CAC5D,GAAI,CAAC,KAAKa,GACR,MAAM,IAAI,MAAM,8BAA8B,EAGhD,MAAMoB,EAAajC,EAAK,OAClBkC,EAAmB,IAAI,IAC7B,SAAW,CAACC,EAAGJ,CAAS,IAAK,KAAKlB,GAChC,UAAWmB,KAAYD,KACjB,WAAQC,EAAS,YAAahC,EAAK,IAAI,GAAK,GAAKiC,EAAW,SAASD,EAAS,KAAK,GACrFE,EAAiB,IAAIF,EAAS,MAAOA,CAAQ,EAInD,MAAO,CAAC,GAAGE,EAAiB,OAAO,CAAC,CACtC,C,6BCpRK,MAAME,EAAmB,CAC9BC,GAEA,YAAmBC,EAAa,CAC9B,MAAMC,EAAa,IAAIC,GAAA,EAAkBF,CAAG,EAC5C,KAAKD,GAAgB,IAAII,GAAA,EAAe,CACtC,WAAAF,EACA,iBAAkB,KAAO,KAAO,G,CACjC,CACH,CAEO,MAAM,MAAI,CACf,MAAM,KAAKF,GAAc,KAAK,CAChC,CAEO,MAAM,MAAI,CACf,OAAO,OAAO,KAAKA,GAAc,KAAK,CAAC,CACzC,CACO,MAAM,KAAK3D,EAAgBC,EAAY,CAC5C,GAAID,EAASC,EAAO,OAAO,iBACzB,MAAM,IAAI,MAAM,0BAA0BD,WAAgBC,GAAM,EAElE,OAAO,MAAM,KAAK0D,GAAc,KAAK,OAAO3D,CAAM,EAAG,OAAOC,CAAI,CAAC,CACnE,C,2FCRF,MAAM,GAAM,KAAI,UAAU,EAAU,EAIpC,eAAe+D,EAAuBC,EAA+B,CACnE,MAAM7B,EAAqB,MAAM7C,EAAuB,EACxD,GAAI,CACF,MAAMF,EAAS,MAAM,KAAkB,WAAW,CAAE,SAAA4E,EAAU,mBAAA7B,CAAmB,CAAC,EAElF,OAAI/C,EAAO,aAAa,SAAW,GAAKA,EAAO,aAAa,OAAS,EACnE,OAEKA,C,OACAwC,EAAP,CACA,GAAI,MAAMA,CAAG,EACb,M,CAEJ,CAEO,MAAMqC,CAAmB,CAC9BC,GACAC,GAEA,YAAmBC,EAAoB,CACrC,KAAKF,GAAUE,CACjB,CAEO,MAAM,YAAU,CACrB,MAAMA,EAAS,KAAKF,GAEpB,OAAQE,EAAO,KAAM,CACnB,IAAK,OAAQ,CAIX,MAAMA,EAAO,KAAK,MAAM,EAAG,CAAC,EAAE,YAAY,EAE1C,MAAMJ,EAAW,IAAInE,GAAauE,EAAO,IAAI,EACvChF,EAAS,MAAM2E,EAAuBC,CAAQ,EAChD5E,EACF,KAAK+E,GAAc,IAAIjE,EAA0Bd,CAAM,EAEvD,KAAK+E,GAAc,IAAInC,EAA4B,CACjD,KAAMoC,EAAO,KAAK,KAClB,OAAQA,EAAO,KAAK,OAAO,C,CAC5B,EAEH,K,CAEF,IAAK,MAAO,CACV,MAAMJ,EAAW,IAAIP,GAAmBW,EAAO,GAAG,EAClD,MAAMJ,EAAS,KAAK,EACpB,MAAM5E,EAAS,MAAM2E,EAAuBC,CAAQ,EACpD,GAAI5E,EACF,KAAK+E,GAAc,IAAIjE,EAA0Bd,CAAM,MAClD,CACL,MAAMiF,EAAW,MAAM,MAAMD,EAAO,GAAG,EACvC,GAAI,CAACC,EAAS,KACZ,MAAM,IAAI,MAAM,kCAAkCD,EAAO,MAAM,EAEjE,MAAMpE,EAAOqE,EAAS,QAAQ,IAAI,gBAAgB,EAClD,GAAIrE,GAAQ,KACV,MAAM,IAAI,MAAM,kDAAkDoE,EAAO,MAAM,EAGjF,KAAKD,GAAc,IAAInC,EAA4B,CACjD,KAAM,SAAShC,CAAI,EACnB,OAAQqE,EAAS,I,CAClB,C,CAEH,K,EAIJ,OAAO,MAAM,KAAKF,GAAY,WAAW,CAC3C,CAEO,gBACLG,EAAwB,CAExB,GAAI,CAAC,KAAKH,GACR,MAAM,IAAI,MAAM,0BAA0B,EAG5C,OAAO,KAAKA,GAAY,gBAAgBG,CAAG,CAC7C,CAEO,MAAM,oBAAoBjD,EAA6B,CAC5D,GAAI,CAAC,KAAK8C,GACR,MAAM,IAAI,MAAM,0BAA0B,EAG5C,OAAO,MAAM,KAAKA,GAAY,oBAAoB9C,CAAI,CACxD,C,CCxGK,SAASkD,GAAWlD,EAAkC,CAC3D,GAAIA,EAAK,KAAM,CACb,MAAM+C,EAAS,IAAIH,EAAmB,CAAE,KAAM,OAAQ,KAAM5C,EAAK,IAAK,CAAC,EACjEmD,EAAU,IAAIC,EAAA,EAA2BL,CAAM,EACrD,OAAO,KAAcI,CAAO,C,SACnBnD,EAAK,IAAK,CACnB,MAAM+C,EAAS,IAAIH,EAAmB,CAAE,KAAM,MAAO,IAAK5C,EAAK,GAAI,CAAC,EAC9DmD,EAAU,IAAIC,EAAA,EAA2BL,CAAM,EACrD,OAAO,KAAcI,CAAO,C,CAG9B,MAAM,IAAI,MAAM,sBAAsB,CACxC,CAEA,KAAeD,EAAU,C","sources":["webpack:///../../packages/mcap-support/src/parseJsonSchema.ts","webpack:///../../packages/mcap-support/src/protobufDefinitionsToDatatypes.ts","webpack:///../../packages/mcap-support/src/parseFlatbufferSchema.ts","webpack:///../../packages/mcap-support/src/parseProtobufSchema.ts","webpack:///../../packages/mcap-support/src/parseChannel.ts","webpack:///../../packages/mcap-support/src/decompressHandlers.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/FileReadable.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIndexedIterableSource.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/McapUnindexedIterableSource.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/RemoteFileReadable.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIterableSource.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIterableSourceWorker.worker.ts"],"sourcesContent":["// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport * as base64 from \"@protobufjs/base64\";\n\nimport { MessageDefinitionField } from \"@foxglove/message-definition\";\n\nimport { MessageDefinitionMap } from \"./types\";\n\n/**\n * Parse a JSON Schema and produce datatypes and a deserializer function.\n */\nexport function parseJsonSchema(\n  rootJsonSchema: Record<string, unknown>,\n  rootTypeName: string,\n): {\n  datatypes: MessageDefinitionMap;\n\n  /**\n   * A function that should be called after parsing a value from a JSON string to do any necessary\n   * post-processing (e.g. base64 decoding)\n   */\n  postprocessValue: (value: Record<string, unknown>) => unknown;\n} {\n  const datatypes: MessageDefinitionMap = new Map();\n\n  function addFieldsRecursive(\n    schema: Record<string, unknown>,\n    typeName: string,\n    keyPath: string[],\n  ): (value: Record<string, unknown>) => unknown {\n    let postprocessObject: (value: Record<string, unknown>) => unknown = (value) => value;\n    const fields: MessageDefinitionField[] = [];\n    if (schema.type !== \"object\") {\n      throw new Error(\n        `Expected \"type\": \"object\" for schema ${typeName}, got ${JSON.stringify(schema.type)}`,\n      );\n    }\n    for (const [fieldName, fieldSchema] of Object.entries(\n      schema.properties as Record<string, Record<string, unknown>>,\n    )) {\n      if (Array.isArray(fieldSchema.oneOf)) {\n        if (fieldSchema.oneOf.every((alternative) => typeof alternative.const === \"number\")) {\n          for (const alternative of fieldSchema.oneOf) {\n            fields.push({\n              name: alternative.title,\n              type: \"uint32\",\n              isConstant: true,\n              value: alternative.const,\n            });\n          }\n          fields.push({ name: fieldName, type: \"uint32\" });\n          continue;\n        } else {\n          throw new Error(\n            `Unsupported type for ${keyPath\n              .concat(fieldName)\n              .join(\".\")}: oneOf alternatives must have number values`,\n          );\n        }\n      }\n      switch (fieldSchema.type) {\n        case \"boolean\":\n          fields.push({ name: fieldName, type: \"bool\" });\n          break;\n        case \"string\":\n          switch (fieldSchema.contentEncoding) {\n            case undefined:\n              fields.push({ name: fieldName, type: \"string\" });\n              break;\n            case \"base64\": {\n              fields.push({ name: fieldName, type: \"uint8\", isArray: true });\n              const prevPostprocess = postprocessObject;\n              postprocessObject = (value) => {\n                const str = value[fieldName];\n                if (typeof str === \"string\") {\n                  const decoded = new Uint8Array(base64.length(str));\n                  if (base64.decode(str, decoded, 0) !== decoded.byteLength) {\n                    throw new Error(\n                      `Failed to decode base64 data for ${keyPath.concat(fieldName).join(\".\")}`,\n                    );\n                  }\n                  value[fieldName] = decoded;\n                }\n                return prevPostprocess(value);\n              };\n              break;\n            }\n            default:\n              throw new Error(\n                `Unsupported contentEncoding ${JSON.stringify(\n                  fieldSchema.contentEncoding,\n                )} in ${keyPath.concat(fieldName).join(\".\")}`,\n              );\n          }\n          break;\n        case \"number\":\n        case \"integer\":\n          fields.push({ name: fieldName, type: \"float64\" });\n          break;\n        case \"object\": {\n          const nestedTypeName = `${typeName}.${fieldName}`;\n          const postprocessNestedObject = addFieldsRecursive(\n            fieldSchema,\n            nestedTypeName,\n            keyPath.concat(fieldName),\n          );\n          const prevPostprocess = postprocessObject;\n          postprocessObject = (value) => {\n            const fieldValue = value[fieldName];\n            if (fieldValue != undefined && typeof fieldValue === \"object\") {\n              value[fieldName] = postprocessNestedObject(fieldValue as Record<string, unknown>);\n            }\n            return prevPostprocess(value);\n          };\n          fields.push({ name: fieldName, type: nestedTypeName, isComplex: true });\n          break;\n        }\n        case \"array\": {\n          const itemSchema = fieldSchema.items as Record<string, unknown>;\n          switch (itemSchema.type) {\n            case \"boolean\":\n              fields.push({ name: fieldName, type: \"bool\", isArray: true });\n              break;\n            case \"string\":\n              if (itemSchema.contentEncoding != undefined) {\n                throw new Error(\n                  `Unsupported contentEncoding ${JSON.stringify(\n                    itemSchema.contentEncoding,\n                  )} for array item ${keyPath.concat(fieldName).join(\".\")}`,\n                );\n              }\n              fields.push({ name: fieldName, type: \"string\", isArray: true });\n              break;\n            case \"number\":\n            case \"integer\":\n              fields.push({ name: fieldName, type: \"float64\", isArray: true });\n              break;\n            case \"object\": {\n              const nestedTypeName = `${typeName}.${fieldName}`;\n              const postprocessArrayItem = addFieldsRecursive(\n                fieldSchema.items as Record<string, unknown>,\n                nestedTypeName,\n                keyPath.concat(fieldName),\n              );\n              const prevPostprocess = postprocessObject;\n              postprocessObject = (value) => {\n                const arr = value[fieldName];\n                if (Array.isArray(arr)) {\n                  value[fieldName] = arr.map(postprocessArrayItem);\n                }\n                return prevPostprocess(value);\n              };\n              fields.push({\n                name: fieldName,\n                type: nestedTypeName,\n                isComplex: true,\n                isArray: true,\n              });\n              break;\n            }\n            default:\n              throw new Error(\n                `Unsupported type ${JSON.stringify(itemSchema.type)} for array item ${keyPath\n                  .concat(fieldName)\n                  .join(\".\")}`,\n              );\n          }\n          break;\n        }\n        case \"null\":\n        default:\n          throw new Error(\n            `Unsupported type ${JSON.stringify(fieldSchema.type)} for ${keyPath\n              .concat(fieldName)\n              .join(\".\")}`,\n          );\n      }\n    }\n    datatypes.set(typeName, { definitions: fields });\n    return postprocessObject;\n  }\n\n  const postprocessValue = addFieldsRecursive(rootJsonSchema, rootTypeName, []);\n  return { datatypes, postprocessValue };\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\nimport protobufjs from \"protobufjs\";\n\nimport { MessageDefinitionField } from \"@foxglove/message-definition\";\n\nimport { MessageDefinitionMap } from \"./types\";\n\nfunction protobufScalarToRosPrimitive(type: string): string {\n  switch (type) {\n    case \"double\":\n      return \"float64\";\n    case \"float\":\n      return \"float32\";\n    case \"int32\":\n    case \"sint32\":\n    case \"sfixed32\":\n      return \"int32\";\n    case \"uint32\":\n    case \"fixed32\":\n      return \"uint32\";\n    case \"int64\":\n    case \"sint64\":\n    case \"sfixed64\":\n      return \"int64\";\n    case \"uint64\":\n    case \"fixed64\":\n      return \"uint64\";\n    case \"bool\":\n      return \"bool\";\n    case \"string\":\n      return \"string\";\n  }\n  throw new Error(`Expected protobuf scalar type, got ${type}`);\n}\n\nexport function stripLeadingDot(typeName: string): string {\n  return typeName.replace(/^\\./, \"\");\n}\n\nexport function protobufDefinitionsToDatatypes(\n  datatypes: MessageDefinitionMap,\n  type: protobufjs.Type,\n): void {\n  const definitions: MessageDefinitionField[] = [];\n  // The empty list reference is added to the map so a `.has` lookup below can prevent infinite recursion on cyclical types\n  datatypes.set(stripLeadingDot(type.fullName), { definitions });\n  for (const field of type.fieldsArray) {\n    if (field.resolvedType instanceof protobufjs.Enum) {\n      for (const [name, value] of Object.entries(field.resolvedType.values)) {\n        // Note: names from different enums might conflict. The player API will need to be updated\n        // to associate fields with enums (similar to the __foxglove_enum annotation hack).\n        // https://github.com/foxglove/studio/issues/2214\n        definitions.push({ name, type: \"int32\", isConstant: true, value });\n      }\n      definitions.push({ type: \"int32\", name: field.name });\n    } else if (field.resolvedType) {\n      const fullName = stripLeadingDot(field.resolvedType.fullName);\n      definitions.push({\n        type: fullName,\n        name: field.name,\n        isComplex: true,\n        isArray: field.repeated,\n      });\n\n      // If we've already processed this datatype we should skip it.\n      // This avoid infinite recursion with datatypes that reference themselves.\n      if (!datatypes.has(fullName)) {\n        protobufDefinitionsToDatatypes(datatypes, field.resolvedType);\n      }\n    } else if (field.type === \"bytes\") {\n      if (field.repeated) {\n        throw new Error(\"Repeated bytes are not currently supported\");\n      }\n      definitions.push({ type: \"uint8\", name: field.name, isArray: true });\n    } else {\n      definitions.push({\n        type: protobufScalarToRosPrimitive(field.type),\n        name: field.name,\n        isArray: field.repeated,\n      });\n    }\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { ByteBuffer } from \"flatbuffers\";\nimport { BaseType, Schema, SchemaT, FieldT, Parser, Table } from \"flatbuffers_reflection\";\n\nimport { MessageDefinitionField } from \"@foxglove/message-definition\";\n\nimport { MessageDefinitionMap } from \"./types\";\n\nfunction typeForSimpleField(type: BaseType): string {\n  switch (type) {\n    case BaseType.Bool:\n      return \"bool\";\n    case BaseType.Byte:\n      return \"int8\";\n    case BaseType.UType:\n    case BaseType.UByte:\n      return \"uint8\";\n    case BaseType.Short:\n      return \"int16\";\n    case BaseType.UShort:\n      return \"uint16\";\n    case BaseType.Int:\n      return \"int32\";\n    case BaseType.UInt:\n      return \"uint32\";\n    case BaseType.Long:\n      return \"int64\";\n    case BaseType.ULong:\n      return \"uint64\";\n    case BaseType.Float:\n      return \"float32\";\n    case BaseType.Double:\n      return \"float64\";\n    case BaseType.String:\n      return \"string\";\n    case BaseType.Vector:\n    case BaseType.Obj:\n    case BaseType.Union:\n    case BaseType.Array:\n      throw new Error(`${type} is not a simple type.`);\n    case BaseType.None:\n    case BaseType.MaxBaseType:\n      throw new Error(\"None is not a valid type.\");\n  }\n}\n\n// eslint-disable-next-line no-restricted-syntax\nfunction flatbufferString(unchecked: string | Uint8Array | null | undefined): string {\n  if (typeof unchecked === \"string\") {\n    return unchecked;\n  }\n  throw new Error(`Expected string, found ${typeof unchecked}`);\n}\n\nfunction typeForField(schema: SchemaT, field: FieldT): MessageDefinitionField[] {\n  const fields: MessageDefinitionField[] = [];\n  switch (field.type?.baseType) {\n    case BaseType.UType:\n    case BaseType.Bool:\n    case BaseType.Byte:\n    case BaseType.UByte:\n    case BaseType.Short:\n    case BaseType.UShort:\n    case BaseType.Int:\n    case BaseType.UInt:\n    case BaseType.Long:\n    case BaseType.ULong:\n    case BaseType.Float:\n    case BaseType.Double:\n    case BaseType.String:\n    case BaseType.None: {\n      const simpleType = typeForSimpleField(field.type.baseType);\n      // Enums have magic logic--the constants definitions for the enum values\n      // have to go right before the enum itself.\n      if (field.type.index !== -1) {\n        const enums = schema.enums[field.type.index]?.values;\n        if (enums == undefined) {\n          throw new Error(\n            `Invalid schema, missing enum values for field type ${\n              schema.enums[field.type.index]?.name\n            }`,\n          );\n        }\n        for (const enumVal of enums) {\n          fields.push({\n            name: flatbufferString(enumVal.name),\n            type: simpleType,\n            isConstant: true,\n            value: enumVal.value,\n          });\n        }\n      }\n      fields.push({ name: flatbufferString(field.name), type: simpleType });\n      break;\n    }\n    case BaseType.Vector:\n      switch (field.type.element) {\n        case BaseType.Vector:\n        case BaseType.Union:\n        case BaseType.Array:\n        case BaseType.None:\n          throw new Error(\"Vectors of vectors, unions, arrays, and None's are unsupported.\");\n        case BaseType.Obj:\n          fields.push({\n            name: flatbufferString(field.name),\n            type: flatbufferString(schema.objects[field.type.index]?.name),\n            isComplex: true,\n            isArray: true,\n          });\n          break;\n        default: {\n          const type = typeForSimpleField(field.type.element);\n          // Enums have magic logic--the constants definitions for the enum\n          // values have to go right before the enum itself.\n          if (field.type.index !== -1) {\n            const enums = schema.enums[field.type.index]?.values;\n            if (enums == undefined) {\n              throw new Error(\"Invalid schema\");\n            }\n            for (const enumVal of enums) {\n              fields.push({\n                name: flatbufferString(enumVal.name),\n                type,\n                isConstant: true,\n                value: enumVal.value,\n              });\n            }\n          }\n          fields.push({ name: flatbufferString(field.name), type, isArray: true });\n          break;\n        }\n      }\n      break;\n    case BaseType.Obj:\n      fields.push({\n        name: flatbufferString(field.name),\n        type: flatbufferString(schema.objects[field.type.index]?.name),\n        isComplex: true,\n      });\n      break;\n    case BaseType.Union:\n    case BaseType.Array:\n    case BaseType.MaxBaseType:\n    case undefined:\n      throw new Error(\"Unions and Arrays are not supported in mcap-support currently.\");\n  }\n  return fields;\n}\n\n/**\n * Parse a flatbuffer binary schema and produce datatypes and a deserializer function.\n *\n * Note: Currently this does not support \"lazy\" message reading in the style of the ros1 message\n * reader, and so will relatively inefficiently deserialize the entire flatbuffer message.\n */\nexport function parseFlatbufferSchema(\n  schemaName: string,\n  schemaArray: Uint8Array,\n): {\n  datatypes: MessageDefinitionMap;\n  deserialize: (buffer: ArrayBufferView) => unknown;\n} {\n  const datatypes: MessageDefinitionMap = new Map();\n  const schemaBuffer = new ByteBuffer(schemaArray);\n  const rawSchema = Schema.getRootAsSchema(schemaBuffer);\n  const schema = rawSchema.unpack();\n\n  let typeIndex = -1;\n  for (let schemaIndex = 0; schemaIndex < schema.objects.length; ++schemaIndex) {\n    const object = schema.objects[schemaIndex];\n    if (object?.name === schemaName) {\n      typeIndex = schemaIndex;\n    }\n    let fields: MessageDefinitionField[] = [];\n    if (object?.fields == undefined) {\n      continue;\n    }\n    for (const field of object.fields) {\n      fields = fields.concat(typeForField(schema, field));\n    }\n    datatypes.set(flatbufferString(object.name), { definitions: fields });\n  }\n  if (typeIndex === -1) {\n    if (schema.rootTable?.name !== schemaName) {\n      throw new Error(\n        `Type \"${schemaName}\" is not available in the schema for \"${schema.rootTable?.name}\".`,\n      );\n    }\n  }\n  const parser = new Parser(rawSchema);\n  // We set readDefaults=true to ensure that the reader receives default values for unset fields, or\n  // fields that were explicitly set but with ForceDefaults(false) on the writer side. This is\n  // necessary because `datatypes` does not include information about default values from the\n  // schema. See discussion: <https://github.com/foxglove/studio/pull/6256>\n  const toObject = parser.toObjectLambda(typeIndex, /*readDefaults=*/ true);\n  const deserialize = (buffer: ArrayBufferView) => {\n    const byteBuffer = new ByteBuffer(\n      new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength),\n    );\n    const table = new Table(\n      byteBuffer,\n      typeIndex,\n      byteBuffer.readInt32(byteBuffer.position()) + byteBuffer.position(),\n      false,\n    );\n    return toObject(table);\n  };\n  return { datatypes, deserialize };\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport protobufjs from \"protobufjs\";\nimport { FileDescriptorSet } from \"protobufjs/ext/descriptor\";\n\nimport { protobufDefinitionsToDatatypes, stripLeadingDot } from \"./protobufDefinitionsToDatatypes\";\nimport { MessageDefinitionMap } from \"./types\";\n\n/**\n * Parse a Protobuf binary schema (FileDescriptorSet) and produce datatypes and a deserializer\n * function.\n */\nexport function parseProtobufSchema(\n  schemaName: string,\n  schemaData: Uint8Array,\n): {\n  datatypes: MessageDefinitionMap;\n  deserialize: (buffer: ArrayBufferView) => unknown;\n} {\n  const descriptorSet = FileDescriptorSet.decode(schemaData);\n\n  const root = protobufjs.Root.fromDescriptor(descriptorSet);\n  root.resolveAll();\n  const rootType = root.lookupType(schemaName);\n\n  // Modify the definition of google.protobuf.Timestamp and Duration so they are interpreted as\n  // {sec: number, nsec: number}, compatible with the rest of Studio. The standard Protobuf types\n  // use different names (`seconds` and `nanos`), and `seconds` is an `int64`, which would be\n  // deserialized as a bigint by default.\n  const fixTimeType = (\n    type: protobufjs.ReflectionObject | null /* eslint-disable-line no-restricted-syntax */,\n  ) => {\n    if (!type || !(type instanceof protobufjs.Type)) {\n      return;\n    }\n    // Rename fields so that protobufDefinitionsToDatatypes uses the new names\n    for (const field of type.fieldsArray) {\n      if (field.name === \"seconds\") {\n        field.name = \"sec\";\n      } else if (field.name === \"nanos\") {\n        field.name = \"nsec\";\n      }\n    }\n    type.setup(); // ensure the original optimized toObject has been created\n    const prevToObject = type.toObject; // eslint-disable-line @typescript-eslint/unbound-method\n    const newToObject: typeof prevToObject = (message, options) => {\n      const result = prevToObject.call(type, message, options);\n      const { sec, nsec } = result as { sec: bigint; nsec: number };\n      if (typeof sec !== \"bigint\" || typeof nsec !== \"number\") {\n        return result;\n      }\n      if (sec > BigInt(Number.MAX_SAFE_INTEGER)) {\n        throw new Error(\n          `Timestamps with seconds greater than 2^53-1 are not supported (found seconds=${sec}, nanos=${nsec})`,\n        );\n      }\n      return { sec: Number(sec), nsec };\n    };\n    type.toObject = newToObject;\n  };\n\n  fixTimeType(root.lookup(\".google.protobuf.Timestamp\"));\n  fixTimeType(root.lookup(\".google.protobuf.Duration\"));\n\n  const deserialize = (data: ArrayBufferView) => {\n    return rootType.toObject(\n      rootType.decode(new Uint8Array(data.buffer, data.byteOffset, data.byteLength)),\n      { defaults: true },\n    );\n  };\n\n  const datatypes: MessageDefinitionMap = new Map();\n  protobufDefinitionsToDatatypes(datatypes, rootType);\n\n  if (!datatypes.has(schemaName)) {\n    throw new Error(\n      `Protobuf schema does not contain an entry for '${schemaName}'. The schema name should be fully-qualified, e.g. '${stripLeadingDot(\n        rootType.fullName,\n      )}'.`,\n    );\n  }\n\n  return { deserialize, datatypes };\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { MessageDefinition } from \"@foxglove/message-definition\";\nimport { parse as parseMessageDefinition, parseRos2idl } from \"@foxglove/rosmsg\";\nimport { MessageReader } from \"@foxglove/rosmsg-serialization\";\nimport { MessageReader as ROS2MessageReader } from \"@foxglove/rosmsg2-serialization\";\n\nimport { parseFlatbufferSchema } from \"./parseFlatbufferSchema\";\nimport { parseJsonSchema } from \"./parseJsonSchema\";\nimport { parseProtobufSchema } from \"./parseProtobufSchema\";\nimport { MessageDefinitionMap } from \"./types\";\n\ntype Channel = {\n  messageEncoding: string;\n  schema: { name: string; encoding: string; data: Uint8Array } | undefined;\n};\n\nexport type ParsedChannel = {\n  deserialize: (data: ArrayBufferView) => unknown;\n  datatypes: MessageDefinitionMap;\n};\n\nfunction parsedDefinitionsToDatatypes(\n  parsedDefinitions: MessageDefinition[],\n  rootName: string,\n): MessageDefinitionMap {\n  const datatypes: MessageDefinitionMap = new Map();\n  parsedDefinitions.forEach(({ name, definitions }, index) => {\n    if (index === 0) {\n      datatypes.set(rootName, { name: rootName, definitions });\n    } else if (name != undefined) {\n      datatypes.set(name, { name, definitions });\n    }\n  });\n  return datatypes;\n}\n\n/**\n * Process a channel/schema and extract information that can be used to deserialize messages on the\n * channel, and schemas in the format expected by Studio's RosDatatypes.\n *\n * See:\n * - https://github.com/foxglove/mcap/blob/main/docs/specification/well-known-message-encodings.md\n * - https://github.com/foxglove/mcap/blob/main/docs/specification/well-known-schema-encodings.md\n */\nexport function parseChannel(channel: Channel): ParsedChannel {\n  if (channel.messageEncoding === \"json\") {\n    if (channel.schema != undefined && channel.schema.encoding !== \"jsonschema\") {\n      throw new Error(\n        `Message encoding ${channel.messageEncoding} with schema encoding '${channel.schema.encoding}' is not supported (expected jsonschema or no schema)`,\n      );\n    }\n    const textDecoder = new TextDecoder();\n    let datatypes: MessageDefinitionMap = new Map();\n    let deserialize = (data: ArrayBufferView) => JSON.parse(textDecoder.decode(data));\n    if (channel.schema != undefined) {\n      const schema =\n        channel.schema.data.length > 0\n          ? JSON.parse(textDecoder.decode(channel.schema.data))\n          : undefined;\n      if (schema != undefined) {\n        if (typeof schema !== \"object\") {\n          throw new Error(`Invalid schema, expected JSON object, got ${typeof schema}`);\n        }\n        const { datatypes: parsedDatatypes, postprocessValue } = parseJsonSchema(\n          schema as Record<string, unknown>,\n          channel.schema.name,\n        );\n        datatypes = parsedDatatypes;\n        deserialize = (data) =>\n          postprocessValue(JSON.parse(textDecoder.decode(data)) as Record<string, unknown>);\n      }\n    }\n    return { deserialize, datatypes };\n  }\n\n  if (channel.messageEncoding === \"flatbuffer\") {\n    if (channel.schema?.encoding !== \"flatbuffer\") {\n      throw new Error(\n        `Message encoding ${channel.messageEncoding} with ${\n          channel.schema == undefined\n            ? \"no encoding\"\n            : `schema encoding '${channel.schema.encoding}'`\n        } is not supported (expected flatbuffer)`,\n      );\n    }\n    return parseFlatbufferSchema(channel.schema.name, channel.schema.data);\n  }\n\n  if (channel.messageEncoding === \"protobuf\") {\n    if (channel.schema?.encoding !== \"protobuf\") {\n      throw new Error(\n        `Message encoding ${channel.messageEncoding} with ${\n          channel.schema == undefined\n            ? \"no encoding\"\n            : `schema encoding '${channel.schema.encoding}'`\n        } is not supported (expected protobuf)`,\n      );\n    }\n    return parseProtobufSchema(channel.schema.name, channel.schema.data);\n  }\n\n  if (channel.messageEncoding === \"ros1\") {\n    if (channel.schema?.encoding !== \"ros1msg\") {\n      throw new Error(\n        `Message encoding ${channel.messageEncoding} with ${\n          channel.schema == undefined\n            ? \"no encoding\"\n            : `schema encoding '${channel.schema.encoding}'`\n        } is not supported (expected ros1msg)`,\n      );\n    }\n    const schema = new TextDecoder().decode(channel.schema.data);\n    const parsedDefinitions = parseMessageDefinition(schema);\n    const reader = new MessageReader(parsedDefinitions);\n    return {\n      datatypes: parsedDefinitionsToDatatypes(parsedDefinitions, channel.schema.name),\n      deserialize: (data) => reader.readMessage(data),\n    };\n  }\n\n  if (channel.messageEncoding === \"cdr\") {\n    if (channel.schema?.encoding !== \"ros2msg\" && channel.schema?.encoding !== \"ros2idl\") {\n      throw new Error(\n        `Message encoding ${channel.messageEncoding} with ${\n          channel.schema == undefined\n            ? \"no encoding\"\n            : `schema encoding '${channel.schema.encoding}'`\n        } is not supported (expected \"ros2msg\" or \"ros2idl\")`,\n      );\n    }\n    const schema = new TextDecoder().decode(channel.schema.data);\n    const isIdl = channel.schema.encoding === \"ros2idl\";\n\n    const parsedDefinitions = isIdl\n      ? parseRos2idl(schema)\n      : parseMessageDefinition(schema, { ros2: true });\n\n    const reader = new ROS2MessageReader(parsedDefinitions);\n    return {\n      datatypes: parsedDefinitionsToDatatypes(parsedDefinitions, channel.schema.name),\n      deserialize: (data) => reader.readMessage(data),\n    };\n  }\n\n  throw new Error(`Unsupported encoding ${channel.messageEncoding}`);\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { McapTypes } from \"@mcap/core\";\n\nlet handlersPromise: Promise<McapTypes.DecompressHandlers> | undefined;\nexport async function loadDecompressHandlers(): Promise<McapTypes.DecompressHandlers> {\n  return await (handlersPromise ??= _loadDecompressHandlers());\n}\n\n// eslint-disable-next-line no-underscore-dangle\nasync function _loadDecompressHandlers(): Promise<McapTypes.DecompressHandlers> {\n  const [decompressZstd, decompressLZ4, bzip2] = await Promise.all([\n    import(\"@foxglove/wasm-zstd\").then(async (mod) => {\n      await mod.isLoaded;\n      return mod.decompress;\n    }),\n    import(\"@foxglove/wasm-lz4\").then(async (mod) => {\n      await mod.default.isLoaded;\n      return mod.default;\n    }),\n    import(\"@foxglove/wasm-bz2\").then(async (mod) => await mod.default.init()),\n  ]);\n\n  return {\n    lz4: (buffer, decompressedSize) => decompressLZ4(buffer, Number(decompressedSize)),\n\n    bz2: (buffer, decompressedSize) =>\n      bzip2.decompress(buffer, Number(decompressedSize), { small: false }),\n\n    zstd: (buffer, decompressedSize) => decompressZstd(buffer, Number(decompressedSize)),\n  };\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nexport class FileReadable {\n  public constructor(private file: File) {}\n  public async size(): Promise<bigint> {\n    return BigInt(this.file.size);\n  }\n  public async read(offset: bigint, size: bigint): Promise<Uint8Array> {\n    if (offset + size > this.file.size) {\n      throw new Error(\n        `Read of ${size} bytes at offset ${offset} exceeds file size ${this.file.size}`,\n      );\n    }\n    return new Uint8Array(\n      await this.file.slice(Number(offset), Number(offset + size)).arrayBuffer(),\n    );\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { McapIndexedReader, McapTypes } from \"@mcap/core\";\n\nimport Logger from \"@foxglove/log\";\nimport { ParsedChannel, parseChannel } from \"@foxglove/mcap-support\";\nimport { Time, fromNanoSec, toNanoSec, compare } from \"@foxglove/rostime\";\nimport { MessageEvent } from \"@foxglove/studio\";\nimport {\n  GetBackfillMessagesArgs,\n  IIterableSource,\n  Initalization,\n  IteratorResult,\n  MessageIteratorArgs,\n} from \"@foxglove/studio-base/players/IterablePlayer/IIterableSource\";\nimport { PlayerProblem, Topic, TopicStats } from \"@foxglove/studio-base/players/types\";\nimport { RosDatatypes } from \"@foxglove/studio-base/types/RosDatatypes\";\n\nconst log = Logger.getLogger(__filename);\n\nexport class McapIndexedIterableSource implements IIterableSource {\n  #reader: McapIndexedReader;\n  #channelInfoById = new Map<\n    number,\n    { channel: McapTypes.Channel; parsedChannel: ParsedChannel; schemaName: string | undefined }\n  >();\n  #start?: Time;\n  #end?: Time;\n\n  public constructor(reader: McapIndexedReader) {\n    this.#reader = reader;\n  }\n\n  public async initialize(): Promise<Initalization> {\n    let startTime: bigint | undefined;\n    let endTime: bigint | undefined;\n    for (const chunk of this.#reader.chunkIndexes) {\n      if (startTime == undefined || chunk.messageStartTime < startTime) {\n        startTime = chunk.messageStartTime;\n      }\n      if (endTime == undefined || chunk.messageEndTime > endTime) {\n        endTime = chunk.messageEndTime;\n      }\n    }\n\n    const topicStats = new Map<string, TopicStats>();\n    const topicsByName = new Map<string, Topic>();\n    const datatypes: RosDatatypes = new Map();\n    const problems: PlayerProblem[] = [];\n    const publishersByTopic = new Map<string, Set<string>>();\n\n    for (const channel of this.#reader.channelsById.values()) {\n      const schema = this.#reader.schemasById.get(channel.schemaId);\n      if (channel.schemaId !== 0 && schema == undefined) {\n        problems.push({\n          severity: \"error\",\n          message: `Missing schema info for schema id ${channel.schemaId} (channel ${channel.id}, topic ${channel.topic})`,\n        });\n        continue;\n      }\n\n      let parsedChannel;\n      try {\n        parsedChannel = parseChannel({ messageEncoding: channel.messageEncoding, schema });\n      } catch (error) {\n        problems.push({\n          severity: \"error\",\n          message: `Error in topic ${channel.topic} (channel ${channel.id}): ${error.message}`,\n          error,\n        });\n        continue;\n      }\n      this.#channelInfoById.set(channel.id, { channel, parsedChannel, schemaName: schema?.name });\n\n      let topic = topicsByName.get(channel.topic);\n      if (!topic) {\n        topic = { name: channel.topic, schemaName: schema?.name };\n        topicsByName.set(channel.topic, topic);\n\n        const numMessages = this.#reader.statistics?.channelMessageCounts.get(channel.id);\n        if (numMessages != undefined) {\n          topicStats.set(channel.topic, { numMessages: Number(numMessages) });\n        }\n      }\n\n      // Track the publisher for this topic. \"callerid\" is defined in the MCAP ROS 1 Well-known\n      // profile at <https://mcap.dev/specification/appendix.html>. We skip the profile check to\n      // allow non-ROS profiles to utilize this functionality as well\n      const publisherId = channel.metadata.get(\"callerid\") ?? String(channel.id);\n      let publishers = publishersByTopic.get(channel.topic);\n      if (!publishers) {\n        publishers = new Set();\n        publishersByTopic.set(channel.topic, publishers);\n      }\n      publishers.add(publisherId);\n\n      // Final datatypes is an unholy union of schemas across all channels\n      for (const [name, datatype] of parsedChannel.datatypes) {\n        datatypes.set(name, datatype);\n      }\n    }\n\n    this.#start = fromNanoSec(startTime ?? 0n);\n    this.#end = fromNanoSec(endTime ?? startTime ?? 0n);\n\n    return {\n      start: this.#start,\n      end: this.#end,\n      topics: [...topicsByName.values()],\n      datatypes,\n      profile: this.#reader.header.profile,\n      problems,\n      publishersByTopic,\n      topicStats,\n    };\n  }\n\n  public async *messageIterator(\n    args: MessageIteratorArgs,\n  ): AsyncIterableIterator<Readonly<IteratorResult>> {\n    const topics = args.topics;\n    const start = args.start ?? this.#start;\n    const end = args.end ?? this.#end;\n\n    if (topics.length === 0 || !start || !end) {\n      return;\n    }\n\n    for await (const message of this.#reader.readMessages({\n      startTime: toNanoSec(start),\n      endTime: toNanoSec(end),\n      topics,\n    })) {\n      const channelInfo = this.#channelInfoById.get(message.channelId);\n      if (!channelInfo) {\n        yield {\n          type: \"problem\",\n          problem: {\n            message: `Received message on channel ${message.channelId} without prior channel info`,\n            severity: \"error\",\n          },\n        };\n        continue;\n      }\n      try {\n        yield {\n          type: \"message-event\",\n          msgEvent: {\n            topic: channelInfo.channel.topic,\n            receiveTime: fromNanoSec(message.logTime),\n            publishTime: fromNanoSec(message.publishTime),\n            message: channelInfo.parsedChannel.deserialize(message.data),\n            sizeInBytes: message.data.byteLength,\n            schemaName: channelInfo.schemaName ?? \"\",\n          },\n        };\n      } catch (error) {\n        yield {\n          type: \"problem\",\n          problem: {\n            message: `Error decoding message on ${channelInfo.channel.topic}`,\n            error,\n            severity: \"error\",\n          },\n        };\n      }\n    }\n  }\n\n  public async getBackfillMessages(args: GetBackfillMessagesArgs): Promise<MessageEvent[]> {\n    const { topics, time } = args;\n\n    const messages: MessageEvent[] = [];\n    for (const topic of topics) {\n      // NOTE: An iterator is made for each topic to get the latest message on that topic.\n      // An single iterator for all the topics could result in iterating through many\n      // irrelevant messages to get to an older message on a topic.\n      for await (const message of this.#reader.readMessages({\n        endTime: toNanoSec(time),\n        topics: [topic],\n        reverse: true,\n      })) {\n        const channelInfo = this.#channelInfoById.get(message.channelId);\n        if (!channelInfo) {\n          log.error(`Missing channel info for channel: ${message.channelId} on topic: ${topic}`);\n          continue;\n        }\n\n        try {\n          messages.push({\n            topic: channelInfo.channel.topic,\n            receiveTime: fromNanoSec(message.logTime),\n            publishTime: fromNanoSec(message.publishTime),\n            message: channelInfo.parsedChannel.deserialize(message.data),\n            sizeInBytes: message.data.byteLength,\n            schemaName: channelInfo.schemaName ?? \"\",\n          });\n        } catch (err) {\n          log.error(err);\n        }\n\n        break;\n      }\n    }\n    messages.sort((a, b) => compare(a.receiveTime, b.receiveTime));\n    return messages;\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { McapStreamReader, McapTypes } from \"@mcap/core\";\nimport { isEqual } from \"lodash\";\n\nimport { loadDecompressHandlers, parseChannel, ParsedChannel } from \"@foxglove/mcap-support\";\nimport {\n  Time,\n  isLessThan,\n  isGreaterThan,\n  isTimeInRangeInclusive,\n  fromNanoSec,\n  subtract,\n  toSec,\n  toRFC3339String,\n  compare,\n} from \"@foxglove/rostime\";\nimport { MessageEvent } from \"@foxglove/studio\";\nimport {\n  GetBackfillMessagesArgs,\n  IIterableSource,\n  Initalization,\n  IteratorResult,\n  MessageIteratorArgs,\n} from \"@foxglove/studio-base/players/IterablePlayer/IIterableSource\";\nimport { PlayerProblem, Topic, TopicStats } from \"@foxglove/studio-base/players/types\";\nimport { RosDatatypes } from \"@foxglove/studio-base/types/RosDatatypes\";\n\nconst DURATION_YEAR_SEC = 365 * 24 * 60 * 60;\n\ntype Options = { size: number; stream: ReadableStream<Uint8Array> };\n\n/** Only efficient for small files */\nexport class McapUnindexedIterableSource implements IIterableSource {\n  #options: Options;\n  #msgEventsByChannel?: Map<number, MessageEvent[]>;\n  #start?: Time;\n  #end?: Time;\n\n  public constructor(options: Options) {\n    this.#options = options;\n  }\n\n  public async initialize(): Promise<Initalization> {\n    if (this.#options.size > 1024 * 1024 * 1024) {\n      // This provider uses a simple approach of loading everything into memory up front, so we\n      // can't handle large files\n      throw new Error(\"Unable to open unindexed MCAP file; unindexed files are limited to 1GB\");\n    }\n    const decompressHandlers = await loadDecompressHandlers();\n\n    const streamReader = this.#options.stream.getReader();\n\n    const problems: PlayerProblem[] = [];\n    const channelIdsWithErrors = new Set<number>();\n\n    const messagesByChannel = new Map<number, MessageEvent[]>();\n    const schemasById = new Map<number, McapTypes.TypedMcapRecords[\"Schema\"]>();\n    const channelInfoById = new Map<\n      number,\n      { channel: McapTypes.Channel; parsedChannel: ParsedChannel; schemaName: string | undefined }\n    >();\n\n    let startTime: Time | undefined;\n    let endTime: Time | undefined;\n    let profile: string | undefined;\n    function processRecord(record: McapTypes.TypedMcapRecord) {\n      switch (record.type) {\n        default:\n          break;\n\n        case \"Header\": {\n          profile = record.profile;\n          break;\n        }\n\n        case \"Schema\": {\n          const existingSchema = schemasById.get(record.id);\n          if (existingSchema) {\n            if (!isEqual(existingSchema, record)) {\n              throw new Error(`differing schemas for id ${record.id}`);\n            }\n          }\n          schemasById.set(record.id, record);\n          break;\n        }\n\n        case \"Channel\": {\n          const existingInfo = channelInfoById.get(record.id);\n          if (existingInfo) {\n            if (!isEqual(existingInfo.channel, record)) {\n              throw new Error(`differing channel infos for id ${record.id}`);\n            }\n            break;\n          }\n          if (channelIdsWithErrors.has(record.id)) {\n            break;\n          }\n          const schema = schemasById.get(record.schemaId);\n          if (record.schemaId !== 0 && !schema) {\n            throw new Error(\n              `Encountered channel with schema id ${record.schemaId} but no prior schema`,\n            );\n          }\n\n          try {\n            const parsedChannel = parseChannel({ messageEncoding: record.messageEncoding, schema });\n            channelInfoById.set(record.id, {\n              channel: record,\n              parsedChannel,\n              schemaName: schema?.name,\n            });\n            messagesByChannel.set(record.id, []);\n          } catch (error) {\n            channelIdsWithErrors.add(record.id);\n            problems.push({\n              severity: \"error\",\n              message: `Error in topic ${record.topic} (channel ${record.id}): ${error.message}`,\n              error,\n            });\n          }\n          break;\n        }\n\n        case \"Message\": {\n          const channelId = record.channelId;\n          const channelInfo = channelInfoById.get(channelId);\n          const messages = messagesByChannel.get(channelId);\n          if (!channelInfo || !messages) {\n            if (channelIdsWithErrors.has(channelId)) {\n              break; // error has already been reported\n            }\n            throw new Error(`message for channel ${channelId} with no prior channel info`);\n          }\n          const receiveTime = fromNanoSec(record.logTime);\n          if (!startTime || isLessThan(receiveTime, startTime)) {\n            startTime = receiveTime;\n          }\n          if (!endTime || isGreaterThan(receiveTime, endTime)) {\n            endTime = receiveTime;\n          }\n\n          messages.push({\n            topic: channelInfo.channel.topic,\n            receiveTime,\n            publishTime: fromNanoSec(record.publishTime),\n            message: channelInfo.parsedChannel.deserialize(record.data),\n            sizeInBytes: record.data.byteLength,\n            schemaName: channelInfo.schemaName ?? \"\",\n          });\n          break;\n        }\n      }\n    }\n\n    const reader = new McapStreamReader({ decompressHandlers });\n    for (let result; (result = await streamReader.read()), !result.done; ) {\n      reader.append(result.value);\n      for (let record; (record = reader.nextRecord()); ) {\n        processRecord(record);\n      }\n    }\n\n    this.#msgEventsByChannel = messagesByChannel;\n\n    const topics: Topic[] = [];\n    const topicStats = new Map<string, TopicStats>();\n    const datatypes: RosDatatypes = new Map();\n    const publishersByTopic = new Map<string, Set<string>>();\n\n    for (const { channel, parsedChannel, schemaName } of channelInfoById.values()) {\n      topics.push({ name: channel.topic, schemaName });\n      const numMessages = messagesByChannel.get(channel.id)?.length;\n      if (numMessages != undefined) {\n        topicStats.set(channel.topic, { numMessages });\n      }\n\n      // Track the publisher for this topic. \"callerid\" is defined in the MCAP ROS 1 Well-known\n      // profile at <https://mcap.dev/specification/appendix.html>. We skip the profile check to\n      // allow non-ROS profiles to utilize this functionality as well\n      const publisherId = channel.metadata.get(\"callerid\") ?? String(channel.id);\n      let publishers = publishersByTopic.get(channel.topic);\n      if (!publishers) {\n        publishers = new Set();\n        publishersByTopic.set(channel.topic, publishers);\n      }\n      publishers.add(publisherId);\n\n      // Final datatypes is an unholy union of schemas across all channels\n      for (const [name, datatype] of parsedChannel.datatypes) {\n        datatypes.set(name, datatype);\n      }\n    }\n\n    this.#start = startTime ?? { sec: 0, nsec: 0 };\n    this.#end = endTime ?? { sec: 0, nsec: 0 };\n\n    const fileDuration = toSec(subtract(this.#end, this.#start));\n    if (fileDuration > DURATION_YEAR_SEC) {\n      const startRfc = toRFC3339String(this.#start);\n      const endRfc = toRFC3339String(this.#end);\n\n      problems.push({\n        message: \"This file has an abnormally long duration.\",\n        tip: `The start ${startRfc} and end ${endRfc} are greater than a year.`,\n        severity: \"warn\",\n      });\n    }\n\n    problems.push({\n      message: \"This file is unindexed. Unindexed files may have degraded performance.\",\n      tip: \"See the mcap spec: https://mcap.dev/specification/index.html#summary-section\",\n      severity: \"warn\",\n    });\n\n    return {\n      start: this.#start,\n      end: this.#end,\n      topics,\n      datatypes,\n      profile,\n      problems,\n      publishersByTopic,\n      topicStats,\n    };\n  }\n\n  public async *messageIterator(\n    args: MessageIteratorArgs,\n  ): AsyncIterableIterator<Readonly<IteratorResult>> {\n    if (!this.#msgEventsByChannel) {\n      throw new Error(\"initialization not completed\");\n    }\n\n    const topics = args.topics;\n    const start = args.start ?? this.#start;\n    const end = args.end ?? this.#end;\n\n    if (topics.length === 0 || !start || !end) {\n      return;\n    }\n\n    const topicsSet = new Set(topics);\n    const resultMessages = [];\n\n    for (const [channelId, msgEvents] of this.#msgEventsByChannel) {\n      for (const msgEvent of msgEvents) {\n        if (\n          isTimeInRangeInclusive(msgEvent.receiveTime, start, end) &&\n          topicsSet.has(msgEvent.topic)\n        ) {\n          resultMessages.push({\n            type: \"message-event\" as const,\n            connectionId: channelId,\n            msgEvent,\n          });\n        }\n      }\n    }\n\n    // Messages need to be yielded in receiveTime order\n    resultMessages.sort((a, b) => compare(a.msgEvent.receiveTime, b.msgEvent.receiveTime));\n\n    yield* resultMessages;\n  }\n\n  public async getBackfillMessages(args: GetBackfillMessagesArgs): Promise<MessageEvent[]> {\n    if (!this.#msgEventsByChannel) {\n      throw new Error(\"initialization not completed\");\n    }\n\n    const needTopics = args.topics;\n    const msgEventsByTopic = new Map<string, MessageEvent>();\n    for (const [_, msgEvents] of this.#msgEventsByChannel) {\n      for (const msgEvent of msgEvents) {\n        if (compare(msgEvent.receiveTime, args.time) <= 0 && needTopics.includes(msgEvent.topic)) {\n          msgEventsByTopic.set(msgEvent.topic, msgEvent);\n        }\n      }\n    }\n    return [...msgEventsByTopic.values()];\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport BrowserHttpReader from \"@foxglove/studio-base/util/BrowserHttpReader\";\nimport CachedFilelike from \"@foxglove/studio-base/util/CachedFilelike\";\n\nexport class RemoteFileReadable {\n  #remoteReader: CachedFilelike;\n\n  public constructor(url: string) {\n    const fileReader = new BrowserHttpReader(url);\n    this.#remoteReader = new CachedFilelike({\n      fileReader,\n      cacheSizeInBytes: 1024 * 1024 * 200, // 200MiB\n    });\n  }\n\n  public async open(): Promise<void> {\n    await this.#remoteReader.open(); // Important that we call this first, because it might throw an error if the file can't be read.\n  }\n\n  public async size(): Promise<bigint> {\n    return BigInt(this.#remoteReader.size());\n  }\n  public async read(offset: bigint, size: bigint): Promise<Uint8Array> {\n    if (offset + size > Number.MAX_SAFE_INTEGER) {\n      throw new Error(`Read too large: offset ${offset}, size ${size}`);\n    }\n    return await this.#remoteReader.read(Number(offset), Number(size));\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { McapIndexedReader, McapTypes } from \"@mcap/core\";\n\nimport Log from \"@foxglove/log\";\nimport { loadDecompressHandlers } from \"@foxglove/mcap-support\";\nimport { MessageEvent } from \"@foxglove/studio-base/players/types\";\n\nimport { FileReadable } from \"./FileReadable\";\nimport { McapIndexedIterableSource } from \"./McapIndexedIterableSource\";\nimport { McapUnindexedIterableSource } from \"./McapUnindexedIterableSource\";\nimport { RemoteFileReadable } from \"./RemoteFileReadable\";\nimport {\n  IIterableSource,\n  IteratorResult,\n  Initalization,\n  MessageIteratorArgs,\n  GetBackfillMessagesArgs,\n} from \"../IIterableSource\";\n\nconst log = Log.getLogger(__filename);\n\ntype McapSource = { type: \"file\"; file: File } | { type: \"url\"; url: string };\n\nasync function tryCreateIndexedReader(readable: McapTypes.IReadable) {\n  const decompressHandlers = await loadDecompressHandlers();\n  try {\n    const reader = await McapIndexedReader.Initialize({ readable, decompressHandlers });\n\n    if (reader.chunkIndexes.length === 0 || reader.channelsById.size === 0) {\n      return undefined;\n    }\n    return reader;\n  } catch (err) {\n    log.error(err);\n    return undefined;\n  }\n}\n\nexport class McapIterableSource implements IIterableSource {\n  #source: McapSource;\n  #sourceImpl: IIterableSource | undefined;\n\n  public constructor(source: McapSource) {\n    this.#source = source;\n  }\n\n  public async initialize(): Promise<Initalization> {\n    const source = this.#source;\n\n    switch (source.type) {\n      case \"file\": {\n        // Ensure the file is readable before proceeding (will throw in the event of a permission\n        // error). Workaround for the fact that `file.stream().getReader()` returns a generic\n        // \"network error\" in the event of a permission error.\n        await source.file.slice(0, 1).arrayBuffer();\n\n        const readable = new FileReadable(source.file);\n        const reader = await tryCreateIndexedReader(readable);\n        if (reader) {\n          this.#sourceImpl = new McapIndexedIterableSource(reader);\n        } else {\n          this.#sourceImpl = new McapUnindexedIterableSource({\n            size: source.file.size,\n            stream: source.file.stream(),\n          });\n        }\n        break;\n      }\n      case \"url\": {\n        const readable = new RemoteFileReadable(source.url);\n        await readable.open();\n        const reader = await tryCreateIndexedReader(readable);\n        if (reader) {\n          this.#sourceImpl = new McapIndexedIterableSource(reader);\n        } else {\n          const response = await fetch(source.url);\n          if (!response.body) {\n            throw new Error(`Unable to stream remote file. <${source.url}>`);\n          }\n          const size = response.headers.get(\"content-length\");\n          if (size == undefined) {\n            throw new Error(`Remote file is missing Content-Length header. <${source.url}>`);\n          }\n\n          this.#sourceImpl = new McapUnindexedIterableSource({\n            size: parseInt(size),\n            stream: response.body,\n          });\n        }\n        break;\n      }\n    }\n\n    return await this.#sourceImpl.initialize();\n  }\n\n  public messageIterator(\n    opt: MessageIteratorArgs,\n  ): AsyncIterableIterator<Readonly<IteratorResult>> {\n    if (!this.#sourceImpl) {\n      throw new Error(\"Invariant: uninitialized\");\n    }\n\n    return this.#sourceImpl.messageIterator(opt);\n  }\n\n  public async getBackfillMessages(args: GetBackfillMessagesArgs): Promise<MessageEvent[]> {\n    if (!this.#sourceImpl) {\n      throw new Error(\"Invariant: uninitialized\");\n    }\n\n    return await this.#sourceImpl.getBackfillMessages(args);\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport * as Comlink from \"comlink\";\n\nimport { IterableSourceInitializeArgs } from \"@foxglove/studio-base/players/IterablePlayer/IIterableSource\";\nimport { WorkerIterableSourceWorker } from \"@foxglove/studio-base/players/IterablePlayer/WorkerIterableSourceWorker\";\n\nimport { McapIterableSource } from \"./McapIterableSource\";\n\nexport function initialize(args: IterableSourceInitializeArgs): WorkerIterableSourceWorker {\n  if (args.file) {\n    const source = new McapIterableSource({ type: \"file\", file: args.file });\n    const wrapped = new WorkerIterableSourceWorker(source);\n    return Comlink.proxy(wrapped);\n  } else if (args.url) {\n    const source = new McapIterableSource({ type: \"url\", url: args.url });\n    const wrapped = new WorkerIterableSourceWorker(source);\n    return Comlink.proxy(wrapped);\n  }\n\n  throw new Error(\"file or url required\");\n}\n\nComlink.expose(initialize);\n"],"names":["parseJsonSchema","rootJsonSchema","rootTypeName","datatypes","addFieldsRecursive","schema","typeName","keyPath","postprocessObject","value","fields","fieldName","fieldSchema","alternative","prevPostprocess","str","decoded","base64","nestedTypeName","postprocessNestedObject","fieldValue","itemSchema","postprocessArrayItem","arr","postprocessValue","protobufScalarToRosPrimitive","type","stripLeadingDot","protobufDefinitionsToDatatypes","definitions","field","name","fullName","typeForSimpleField","flatbufferString","unchecked","typeForField","simpleType","enums","enumVal","parseFlatbufferSchema","schemaName","schemaArray","schemaBuffer","rawSchema","typeIndex","schemaIndex","object","toObject","buffer","byteBuffer","table","parseProtobufSchema","schemaData","descriptorSet","root","rootType","fixTimeType","prevToObject","newToObject","message","options","result","sec","nsec","deserialize","data","parsedDefinitionsToDatatypes","parsedDefinitions","rootName","index","parseChannel","channel","textDecoder","parsedDatatypes","reader","handlersPromise","loadDecompressHandlers","_loadDecompressHandlers","decompressZstd","decompressLZ4","bzip2","mod","decompressedSize","FileReadable","file","offset","size","log","McapIndexedIterableSource","#reader","#channelInfoById","#start","#end","startTime","endTime","chunk","topicStats","topicsByName","problems","publishersByTopic","parsedChannel","error","topic","numMessages","publisherId","publishers","datatype","args","topics","start","end","channelInfo","time","messages","err","a","b","DURATION_YEAR_SEC","McapUnindexedIterableSource","#options","#msgEventsByChannel","decompressHandlers","streamReader","channelIdsWithErrors","messagesByChannel","schemasById","channelInfoById","profile","processRecord","record","existingSchema","existingInfo","channelId","receiveTime","startRfc","endRfc","topicsSet","resultMessages","msgEvents","msgEvent","needTopics","msgEventsByTopic","_","RemoteFileReadable","#remoteReader","url","fileReader","BrowserHttpReader","CachedFilelike","tryCreateIndexedReader","readable","McapIterableSource","#source","#sourceImpl","source","response","opt","initialize","wrapped","WorkerIterableSourceWorker"],"sourceRoot":""}