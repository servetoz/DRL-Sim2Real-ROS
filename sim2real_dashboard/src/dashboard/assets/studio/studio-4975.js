(()=>{var k={85909:(e,a,s)=>{"use strict";var f=s(90758);const o={canHandle:p=>p instanceof AbortSignal,deserialize:([p,r])=>{const n=new AbortController;return p?n.abort():r.onmessage=()=>{n.abort()},n.signal},serialize:p=>{const{port1:r,port2:n}=new MessageChannel;return p.addEventListener("abort",()=>{r.postMessage("aborted")}),[[p.aborted,n],[n]]}};var c=s(44668);const g=Object.freeze({sec:0,nsec:0});class h{#t;#e;#s;constructor(r,n){this.#t=r,this.#s=n}async next(){return this.#s?.aborted===!0?void 0:(await this.#t.next()).value}async nextBatch(r){const n=await this.next();if(!n)return;if(n.type==="problem")return[n];const l=[n];let m=g;switch(n.type){case"stamp":m=(0,c.add)(n.stamp,{sec:0,nsec:r*1e6});break;case"message-event":m=(0,c.add)(n.msgEvent.receiveTime,{sec:0,nsec:r*1e6});break}for(;;){const i=await this.next();if(!i)return l;if(l.push(i),i.type==="problem"||i.type==="stamp"&&(0,c.compare)(i.stamp,m)>0||i.type==="message-event"&&(0,c.compare)(i.msgEvent.receiveTime,m)>0)break}return l}async readUntil(r){if(this.#s?.aborted===!0)return;const l=[];if(this.#e?.type==="stamp"&&(0,c.compare)(this.#e.stamp,r)>=0||this.#e?.type==="message-event"&&(0,c.compare)(this.#e.msgEvent.receiveTime,r)>0)return l;for(this.#e&&(l.push(this.#e),this.#e=void 0);;){const m=await this.#t.next();if(this.#s?.aborted===!0)return;if(m.done===!0)break;const i=m.value;if(i.type==="stamp"&&(0,c.compare)(i.stamp,r)>=0){this.#e=i;break}if(i.type==="message-event"&&(0,c.compare)(i.msgEvent.receiveTime,r)>0){this.#e=i;break}l.push(i)}return l}async end(){await this.#t.return?.()}}class v{_source;constructor(r){this._source=r}async initialize(){return await this._source.initialize()}messageIterator(r){return f.sj(this._source.messageIterator(r))}async getBackfillMessages(r,n){return await this._source.getBackfillMessages({...r,abortSignal:n})}getMessageCursor(r,n){const l=this._source.messageIterator(r),m=new h(l,n);return f.sj(m)}}f.Y6.set("abortsignal",o);var w=s(5952),A=s(17417);class I{#t;#e;#s={sec:0,nsec:0};#r={sec:0,nsec:0};constructor(r){this.#t=r}async initialize(){const n=await(await(await fetch(new URL(s(67460),s.b).toString())).blob()).arrayBuffer();await w.SqliteSqljs.Initialize({wasmBinary:n});const l=this.#t.map(d=>new w.SqliteSqljs(d)),m=new w.Rosbag2(l);await m.open(),this.#e=m;const[i,y]=await this.#e.timeRange(),b=await this.#e.readTopics(),S=await this.#e.messageCounts();let x=!1;for(const d of S.values())if(d>0){x=!0;break}if(!x)throw new Error("Bag contains no messages");const M=[],O=[],E=new Map,j=new Map,P={},z={};for(const d of b){const B=S.get(d.name);O.push({name:d.name,schemaName:d.type}),B!=null&&E.set(d.name,{numMessages:B});const _=w.ROS2_TO_DEFINITIONS.get(d.type);if(_==null){M.push({severity:"warn",message:`Topic "${d.name}" has unsupported datatype "${d.type}"`,tip:"ROS 2 .db3 files do not contain message definitions, so only well-known ROS types are supported in Foxglove Studio. As a workaround, you can convert the db3 file to mcap using the mcap CLI. For more information, see: https://foxglove.dev/docs/studio/connection/ros2"});continue}const C=[_],D=(0,A.stringify)(C);j.set(d.type,{name:d.type,definitions:_.definitions}),P[d.name]=D,z[d.name]=C}return this.#s=i,this.#r=y,{topics:Array.from(O.values()),topicStats:E,start:i,end:y,problems:M,profile:"ros2",datatypes:j,publishersByTopic:new Map}}async*messageIterator(r){if(this.#e==null)throw new Error("Rosbag2DataProvider is not initialized");const n=r.topics;if(n.length===0)return;const l=r.start??this.#s,m=r.end??this.#r,i=(0,c.add)(m,{sec:0,nsec:1}),y=this.#e.readMessages({startTime:l,endTime:i,topics:n});for await(const b of y)yield{type:"message-event",msgEvent:{topic:b.topic.name,receiveTime:b.timestamp,message:b.value,sizeInBytes:b.data.byteLength,schemaName:b.topic.type}}}async getBackfillMessages(r){return[]}}function R(p){const r=p.file?[p.file]:p.files;if(!r)throw new Error("files required");const n=new I(r),l=new v(n);return f.sj(l)}f.Jj(R)},63136:(e,a,s)=>{"use strict";s.d(a,{Z:()=>u});const u={nextTick:(o,...c)=>{queueMicrotask(()=>{o(...c)})},title:"browser",browser:!0,env:{},argv:[]}},28016:()=>{},33196:()=>{},38087:()=>{},8092:()=>{},50936:()=>{},27464:()=>{},39415:()=>{},87374:()=>{},29285:()=>{}},T={};function t(e){var a=T[e];if(a!==void 0)return a.exports;var s=T[e]={id:e,loaded:!1,exports:{}};return k[e].call(s.exports,s,s.exports,t),s.loaded=!0,s.exports}t.m=k,t.x=()=>{var e=t.O(void 0,[7979,670,7547,6788],()=>t(85909));return e=t.O(e),e},(()=>{var e=[];t.O=(a,s,f,u)=>{if(s){u=u||0;for(var o=e.length;o>0&&e[o-1][2]>u;o--)e[o]=e[o-1];e[o]=[s,f,u];return}for(var c=1/0,o=0;o<e.length;o++){for(var[s,f,u]=e[o],g=!0,h=0;h<s.length;h++)(u&!1||c>=u)&&Object.keys(t.O).every(p=>t.O[p](s[h]))?s.splice(h--,1):(g=!1,u<c&&(c=u));if(g){e.splice(o--,1);var v=f();v!==void 0&&(a=v)}}return a}})(),t.d=(e,a)=>{for(var s in a)t.o(a,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:a[s]})},t.f={},t.e=e=>Promise.all(Object.keys(t.f).reduce((a,s)=>(t.f[s](e,a),a),[])),t.u=e=>"studio-"+e+".js",t.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),t.o=(e,a)=>Object.prototype.hasOwnProperty.call(e,a),t.r=e=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e;t.g.importScripts&&(e=t.g.location+"");var a=t.g.document;if(!e&&a&&(a.currentScript&&(e=a.currentScript.src),!e)){var s=a.getElementsByTagName("script");if(s.length)for(var f=s.length-1;f>-1&&!e;)e=s[f--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),t.p=e})(),(()=>{t.b=self.location+"";var e={4975:1},a=u=>{var[o,c,g]=u;for(var h in c)t.o(c,h)&&(t.m[h]=c[h]);for(g&&g(t);o.length;)e[o.pop()]=1;f(u)};t.f.i=(u,o)=>{e[u]||importScripts(t.p+t.u(u))};var s=self.webpackChunk=self.webpackChunk||[],f=s.push.bind(s);s.push=a})(),(()=>{var e=t.x;t.x=()=>Promise.all([7979,670,7547,6788].map(t.e,t)).then(e)})();var F=t.x()})();

//# sourceMappingURL=studio-4975.js.map