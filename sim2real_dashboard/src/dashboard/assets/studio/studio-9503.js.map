{"version":3,"file":"studio-9503.js","mappings":"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","sources":["webpack:///../../node_modules/@foxglove/rosmsg2-serialization/dist/index.js","webpack:///../../node_modules/@foxglove/crc/dist/esm/src/index.js","webpack:///../../node_modules/heap-js/dist/heap-js.es5.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/getBigUint64.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/Reader.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/constants.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/parse.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/sortedIndexBy.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/ChunkCursor.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/McapIndexedReader.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/StreamBuffer.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/McapStreamReader.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/McapRecordBuilder.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/ChunkBuilder.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/McapWriter.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/hasMcapPrefix.js","webpack:///../../node_modules/flatbuffers_reflection/dist/esm/reflection_generated.js","webpack:///../../node_modules/flatbuffers_reflection/dist/esm/reflection.js","webpack:///../../node_modules/protobufjs/ext/descriptor/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./MessageReader\"), exports);\n__exportStar(require(\"./MessageWriter\"), exports);\n//# sourceMappingURL=index.js.map","/**\n * Compute CRC32 lookup tables as described at:\n * https://github.com/komrad36/CRC#option-6-1-byte-tabular\n *\n * An iteration of CRC computation can be performed on 8 bits of input at once. By pre-computing a\n * table of the values of CRC(?) for all 2^8 = 256 possible byte values, during the final\n * computation we can replace a loop over 8 bits with a single lookup in the table.\n *\n * For further speedup, we can also pre-compute the values of CRC(?0) for all possible bytes when a\n * zero byte is appended. Then we can process two bytes of input at once by computing CRC(AB) =\n * CRC(A0) ^ CRC(B), using one lookup in the CRC(?0) table and one lookup in the CRC(?) table.\n *\n * The same technique applies for any number of bytes to be processed at once, although the speed\n * improvements diminish.\n *\n * @param polynomial The binary representation of the polynomial to use (reversed, i.e. most\n * significant bit represents x^0).\n * @param numTables The number of bytes of input that will be processed at once.\n */\nexport function crc32GenerateTables({ polynomial, numTables, }) {\n    const table = new Uint32Array(256 * numTables);\n    for (let i = 0; i < 256; i++) {\n        let r = i;\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        table[i] = r;\n    }\n    for (let i = 256; i < table.length; i++) {\n        const value = table[i - 256];\n        table[i] = table[value & 0xff] ^ (value >>> 8);\n    }\n    return table;\n}\nconst CRC32_TABLE = crc32GenerateTables({ polynomial: 0xedb88320, numTables: 8 });\n/**\n * Initialize a CRC32 to all 1 bits.\n */\nexport function crc32Init() {\n    return ~0;\n}\n/**\n * Update a streaming CRC32 calculation.\n *\n * For performance, this implementation processes the data 8 bytes at a time, using the algorithm\n * presented at: https://github.com/komrad36/CRC#option-9-8-byte-tabular\n */\nexport function crc32Update(prev, data) {\n    const byteLength = data.byteLength;\n    const view = new DataView(data.buffer, data.byteOffset, byteLength);\n    let r = prev;\n    let offset = 0;\n    // Process bytes one by one until we reach 4-byte alignment, which will speed up uint32 access.\n    const toAlign = -view.byteOffset & 3;\n    for (; offset < toAlign && offset < byteLength; offset++) {\n        r = CRC32_TABLE[(r ^ view.getUint8(offset)) & 0xff] ^ (r >>> 8);\n    }\n    if (offset === byteLength) {\n        return r;\n    }\n    offset = toAlign;\n    // Process 8 bytes (2 uint32s) at a time.\n    let remainingBytes = byteLength - offset;\n    for (; remainingBytes >= 8; offset += 8, remainingBytes -= 8) {\n        r ^= view.getUint32(offset, true);\n        const r2 = view.getUint32(offset + 4, true);\n        r =\n            CRC32_TABLE[0 * 256 + ((r2 >>> 24) & 0xff)] ^\n                CRC32_TABLE[1 * 256 + ((r2 >>> 16) & 0xff)] ^\n                CRC32_TABLE[2 * 256 + ((r2 >>> 8) & 0xff)] ^\n                CRC32_TABLE[3 * 256 + ((r2 >>> 0) & 0xff)] ^\n                CRC32_TABLE[4 * 256 + ((r >>> 24) & 0xff)] ^\n                CRC32_TABLE[5 * 256 + ((r >>> 16) & 0xff)] ^\n                CRC32_TABLE[6 * 256 + ((r >>> 8) & 0xff)] ^\n                CRC32_TABLE[7 * 256 + ((r >>> 0) & 0xff)];\n    }\n    // Process any remaining bytes one by one. (Perf note: inexplicably, using a temporary variable\n    // `i` rather than reusing `offset` here is faster in V8.)\n    for (let i = offset; i < byteLength; i++) {\n        r = CRC32_TABLE[(r ^ view.getUint8(i)) & 0xff] ^ (r >>> 8);\n    }\n    return r;\n}\n/**\n * Finalize a CRC32 by inverting the output value. An unsigned right-shift of 0 is used to ensure the result is a positive number.\n */\nexport function crc32Final(prev) {\n    return (prev ^ ~0) >>> 0;\n}\n/**\n * Calculate a one-shot CRC32. If the data is being accumulated incrementally, use the functions\n * `crc32Init`, `crc32Update`, and `crc32Final` instead.\n */\nexport function crc32(data) {\n    return crc32Final(crc32Update(crc32Init(), data));\n}\n//# sourceMappingURL=index.js.map","var __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar toInt = function (n) { return ~~n; };\n/**\n * Heap\n * @type {Class}\n */\nvar Heap = /** @class */ (function () {\n    /**\n     * Heap instance constructor.\n     * @param  {Function} compare Optional comparison function, defaults to Heap.minComparator<number>\n     */\n    function Heap(compare) {\n        if (compare === void 0) { compare = Heap.minComparator; }\n        var _this = this;\n        this.compare = compare;\n        this.heapArray = [];\n        this._limit = 0;\n        /**\n         * Alias of add\n         */\n        this.offer = this.add;\n        /**\n         * Alias of peek\n         */\n        this.element = this.peek;\n        /**\n         * Alias of pop\n         */\n        this.poll = this.pop;\n        /**\n         * Returns the inverse to the comparison function.\n         * @return {Function}\n         */\n        this._invertedCompare = function (a, b) {\n            return -1 * _this.compare(a, b);\n        };\n    }\n    /*\n              Static methods\n     */\n    /**\n     * Gets children indices for given index.\n     * @param  {Number} idx     Parent index\n     * @return {Array(Number)}  Array of children indices\n     */\n    Heap.getChildrenIndexOf = function (idx) {\n        return [idx * 2 + 1, idx * 2 + 2];\n    };\n    /**\n     * Gets parent index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Parent index, -1 if idx is 0\n     */\n    Heap.getParentIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : 2;\n        return Math.floor((idx - whichChildren) / 2);\n    };\n    /**\n     * Gets sibling index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Sibling index, -1 if idx is 0\n     */\n    Heap.getSiblingIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : -1;\n        return idx + whichChildren;\n    };\n    /**\n     * Min heap comparison function, default.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.minComparator = function (a, b) {\n        if (a > b) {\n            return 1;\n        }\n        else if (a < b) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * Max heap comparison function.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.maxComparator = function (a, b) {\n        if (b > a) {\n            return 1;\n        }\n        else if (b < a) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * Min number heap comparison function, default.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.minComparatorNumber = function (a, b) {\n        return a - b;\n    };\n    /**\n     * Max number heap comparison function.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.maxComparatorNumber = function (a, b) {\n        return b - a;\n    };\n    /**\n     * Default equality function.\n     * @param  {any} a    First element\n     * @param  {any} b    Second element\n     * @return {Boolean}  True if equal, false otherwise\n     */\n    Heap.defaultIsEqual = function (a, b) {\n        return a === b;\n    };\n    /**\n     * Prints a heap.\n     * @param  {Heap} heap Heap to be printed\n     * @returns {String}\n     */\n    Heap.print = function (heap) {\n        function deep(i) {\n            var pi = Heap.getParentIndexOf(i);\n            return Math.floor(Math.log2(pi + 1));\n        }\n        function repeat(str, times) {\n            var out = '';\n            for (; times > 0; --times) {\n                out += str;\n            }\n            return out;\n        }\n        var node = 0;\n        var lines = [];\n        var maxLines = deep(heap.length - 1) + 2;\n        var maxLength = 0;\n        while (node < heap.length) {\n            var i = deep(node) + 1;\n            if (node === 0) {\n                i = 0;\n            }\n            // Text representation\n            var nodeText = String(heap.get(node));\n            if (nodeText.length > maxLength) {\n                maxLength = nodeText.length;\n            }\n            // Add to line\n            lines[i] = lines[i] || [];\n            lines[i].push(nodeText);\n            node += 1;\n        }\n        return lines\n            .map(function (line, i) {\n            var times = Math.pow(2, maxLines - i) - 1;\n            return (repeat(' ', Math.floor(times / 2) * maxLength) +\n                line\n                    .map(function (el) {\n                    // centered\n                    var half = (maxLength - el.length) / 2;\n                    return repeat(' ', Math.ceil(half)) + el + repeat(' ', Math.floor(half));\n                })\n                    .join(repeat(' ', times * maxLength)));\n        })\n            .join('\\n');\n    };\n    /*\n              Python style\n     */\n    /**\n     * Converts an array into an array-heap, in place\n     * @param  {Array}    arr      Array to be modified\n     * @param  {Function} compare  Optional compare function\n     * @return {Heap}              For convenience, it returns a Heap instance\n     */\n    Heap.heapify = function (arr, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = arr;\n        heap.init();\n        return heap;\n    };\n    /**\n     * Extract the peek of an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heappop = function (heapArr, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.pop();\n    };\n    /**\n     * Pushes a item into an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     */\n    Heap.heappush = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        heap.push(item);\n    };\n    /**\n     * Push followed by pop, faster\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heappushpop = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.pushpop(item);\n    };\n    /**\n     * Replace peek with item\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item as replacement\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heapreplace = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.replace(item);\n    };\n    /**\n     * Return the `n` most valuable elements of a heap-like Array\n     * @param  {Array}    heapArr  Array, should be an array-heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.heaptop = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.top(n);\n    };\n    /**\n     * Return the `n` least valuable elements of a heap-like Array\n     * @param  {Array}    heapArr  Array, should be an array-heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.heapbottom = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.bottom(n);\n    };\n    /**\n     * Return the `n` most valuable elements of an iterable\n     * @param  {number}   n        Max number of elements\n     * @param  {Iterable} Iterable Iterable list of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.nlargest = function (n, iterable, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = __spreadArray([], __read(iterable), false);\n        heap.init();\n        return heap.top(n);\n    };\n    /**\n     * Return the `n` least valuable elements of an iterable\n     * @param  {number}   n        Max number of elements\n     * @param  {Iterable} Iterable Iterable list of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.nsmallest = function (n, iterable, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = __spreadArray([], __read(iterable), false);\n        heap.init();\n        return heap.bottom(n);\n    };\n    /*\n              Instance methods\n     */\n    /**\n     * Adds an element to the heap. Aliases: `offer`.\n     * Same as: push(element)\n     * @param {any} element Element to be added\n     * @return {Boolean} true\n     */\n    Heap.prototype.add = function (element) {\n        this._sortNodeUp(this.heapArray.push(element) - 1);\n        this._applyLimit();\n        return true;\n    };\n    /**\n     * Adds an array of elements to the heap.\n     * Similar as: push(element, element, ...).\n     * @param {Array} elements Elements to be added\n     * @return {Boolean} true\n     */\n    Heap.prototype.addAll = function (elements) {\n        var _a;\n        var i = this.length;\n        (_a = this.heapArray).push.apply(_a, __spreadArray([], __read(elements), false));\n        for (var l = this.length; i < l; ++i) {\n            this._sortNodeUp(i);\n        }\n        this._applyLimit();\n        return true;\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype.bottom = function (n) {\n        if (n === void 0) { n = 1; }\n        if (this.heapArray.length === 0 || n <= 0) {\n            // Nothing to do\n            return [];\n        }\n        else if (this.heapArray.length === 1) {\n            // Just the peek\n            return [this.heapArray[0]];\n        }\n        else if (n >= this.heapArray.length) {\n            // The whole heap\n            return __spreadArray([], __read(this.heapArray), false);\n        }\n        else {\n            // Some elements\n            var result = this._bottomN_push(~~n);\n            return result;\n        }\n    };\n    /**\n     * Check if the heap is sorted, useful for testing purposes.\n     * @return {Undefined | Element}  Returns an element if something wrong is found, otherwise it's undefined\n     */\n    Heap.prototype.check = function () {\n        var _this = this;\n        return this.heapArray.find(function (el, j) { return !!_this.getChildrenOf(j).find(function (ch) { return _this.compare(el, ch) > 0; }); });\n    };\n    /**\n     * Remove all of the elements from this heap.\n     */\n    Heap.prototype.clear = function () {\n        this.heapArray = [];\n    };\n    /**\n     * Clone this heap\n     * @return {Heap}\n     */\n    Heap.prototype.clone = function () {\n        var cloned = new Heap(this.comparator());\n        cloned.heapArray = this.toArray();\n        cloned._limit = this._limit;\n        return cloned;\n    };\n    /**\n     * Returns the comparison function.\n     * @return {Function}\n     */\n    Heap.prototype.comparator = function () {\n        return this.compare;\n    };\n    /**\n     * Returns true if this queue contains the specified element.\n     * @param  {any}      o   Element to be found\n     * @param  {Function} fn  Optional comparison function, receives (element, needle)\n     * @return {Boolean}\n     */\n    Heap.prototype.contains = function (o, fn) {\n        if (fn === void 0) { fn = Heap.defaultIsEqual; }\n        return this.heapArray.findIndex(function (el) { return fn(el, o); }) >= 0;\n    };\n    /**\n     * Initialise a heap, sorting nodes\n     * @param  {Array} array Optional initial state array\n     */\n    Heap.prototype.init = function (array) {\n        if (array) {\n            this.heapArray = __spreadArray([], __read(array), false);\n        }\n        for (var i = Math.floor(this.heapArray.length); i >= 0; --i) {\n            this._sortNodeDown(i);\n        }\n        this._applyLimit();\n    };\n    /**\n     * Test if the heap has no elements.\n     * @return {Boolean} True if no elements on the heap\n     */\n    Heap.prototype.isEmpty = function () {\n        return this.length === 0;\n    };\n    /**\n     * Get the leafs of the tree (no children nodes)\n     */\n    Heap.prototype.leafs = function () {\n        if (this.heapArray.length === 0) {\n            return [];\n        }\n        var pi = Heap.getParentIndexOf(this.heapArray.length - 1);\n        return this.heapArray.slice(pi + 1);\n    };\n    Object.defineProperty(Heap.prototype, \"length\", {\n        /**\n         * Length of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this.heapArray.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heap.prototype, \"limit\", {\n        /**\n         * Get length limit of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this._limit;\n        },\n        /**\n         * Set length limit of the heap.\n         * @return {Number}\n         */\n        set: function (_l) {\n            this._limit = ~~_l;\n            this._applyLimit();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Top node. Aliases: `element`.\n     * Same as: `top(1)[0]`\n     * @return {any} Top node\n     */\n    Heap.prototype.peek = function () {\n        return this.heapArray[0];\n    };\n    /**\n     * Extract the top node (root). Aliases: `poll`.\n     * @return {any} Extracted top node, undefined if empty\n     */\n    Heap.prototype.pop = function () {\n        var last = this.heapArray.pop();\n        if (this.length > 0 && last !== undefined) {\n            return this.replace(last);\n        }\n        return last;\n    };\n    /**\n     * Pushes element(s) to the heap.\n     * @param  {...any} elements Elements to insert\n     * @return {Boolean} True if elements are present\n     */\n    Heap.prototype.push = function () {\n        var elements = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            elements[_i] = arguments[_i];\n        }\n        if (elements.length < 1) {\n            return false;\n        }\n        else if (elements.length === 1) {\n            return this.add(elements[0]);\n        }\n        else {\n            return this.addAll(elements);\n        }\n    };\n    /**\n     * Same as push & pop in sequence, but faster\n     * @param  {any} element Element to insert\n     * @return {any}  Extracted top node\n     */\n    Heap.prototype.pushpop = function (element) {\n        var _a;\n        if (this.compare(this.heapArray[0], element) < 0) {\n            _a = __read([this.heapArray[0], element], 2), element = _a[0], this.heapArray[0] = _a[1];\n            this._sortNodeDown(0);\n        }\n        return element;\n    };\n    /**\n     * Remove an element from the heap.\n     * @param  {any}   o      Element to be found\n     * @param  {Function} fn  Optional function to compare\n     * @return {Boolean}      True if the heap was modified\n     */\n    Heap.prototype.remove = function (o, fn) {\n        if (fn === void 0) { fn = Heap.defaultIsEqual; }\n        if (this.length > 0) {\n            if (o === undefined) {\n                this.pop();\n                return true;\n            }\n            else {\n                var idx = this.heapArray.findIndex(function (el) { return fn(el, o); });\n                if (idx >= 0) {\n                    if (idx === 0) {\n                        this.pop();\n                    }\n                    else if (idx === this.length - 1) {\n                        this.heapArray.pop();\n                    }\n                    else {\n                        this.heapArray.splice(idx, 1, this.heapArray.pop());\n                        this._sortNodeUp(idx);\n                        this._sortNodeDown(idx);\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * Pop the current peek value, and add the new item.\n     * @param  {any} element  Element to replace peek\n     * @return {any}         Old peek\n     */\n    Heap.prototype.replace = function (element) {\n        var peek = this.heapArray[0];\n        this.heapArray[0] = element;\n        this._sortNodeDown(0);\n        return peek;\n    };\n    /**\n     * Size of the heap\n     * @return {Number}\n     */\n    Heap.prototype.size = function () {\n        return this.length;\n    };\n    /**\n     * Return the top (highest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}    Array of length <= N.\n     */\n    Heap.prototype.top = function (n) {\n        if (n === void 0) { n = 1; }\n        if (this.heapArray.length === 0 || n <= 0) {\n            // Nothing to do\n            return [];\n        }\n        else if (this.heapArray.length === 1 || n === 1) {\n            // Just the peek\n            return [this.heapArray[0]];\n        }\n        else if (n >= this.heapArray.length) {\n            // The whole peek\n            return __spreadArray([], __read(this.heapArray), false);\n        }\n        else {\n            // Some elements\n            var result = this._topN_push(~~n);\n            return result;\n        }\n    };\n    /**\n     * Clone the heap's internal array\n     * @return {Array}\n     */\n    Heap.prototype.toArray = function () {\n        return __spreadArray([], __read(this.heapArray), false);\n    };\n    /**\n     * String output, call to Array.prototype.toString()\n     * @return {String}\n     */\n    Heap.prototype.toString = function () {\n        return this.heapArray.toString();\n    };\n    /**\n     * Get the element at the given index.\n     * @param  {Number} i Index to get\n     * @return {any}       Element at that index\n     */\n    Heap.prototype.get = function (i) {\n        return this.heapArray[i];\n    };\n    /**\n     * Get the elements of these node's children\n     * @param  {Number} idx Node index\n     * @return {Array(any)}  Children elements\n     */\n    Heap.prototype.getChildrenOf = function (idx) {\n        var _this = this;\n        return Heap.getChildrenIndexOf(idx)\n            .map(function (i) { return _this.heapArray[i]; })\n            .filter(function (e) { return e !== undefined; });\n    };\n    /**\n     * Get the element of this node's parent\n     * @param  {Number} idx Node index\n     * @return {any}     Parent element\n     */\n    Heap.prototype.getParentOf = function (idx) {\n        var pi = Heap.getParentIndexOf(idx);\n        return this.heapArray[pi];\n    };\n    /**\n     * Iterator interface\n     */\n    Heap.prototype[Symbol.iterator] = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!this.length) return [3 /*break*/, 2];\n                    return [4 /*yield*/, this.pop()];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 0];\n                case 2: return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Returns an iterator. To comply with Java interface.\n     */\n    Heap.prototype.iterator = function () {\n        return this.toArray();\n    };\n    /**\n     * Limit heap size if needed\n     */\n    Heap.prototype._applyLimit = function () {\n        if (this._limit && this._limit < this.heapArray.length) {\n            var rm = this.heapArray.length - this._limit;\n            // It's much faster than splice\n            while (rm) {\n                this.heapArray.pop();\n                --rm;\n            }\n        }\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap, without corner cases, unsorted\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._bottomN_push = function (n) {\n        // Use an inverted heap\n        var bottomHeap = new Heap(this.compare);\n        bottomHeap.limit = n;\n        bottomHeap.heapArray = this.heapArray.slice(-n);\n        bottomHeap.init();\n        var startAt = this.heapArray.length - 1 - n;\n        var parentStartAt = Heap.getParentIndexOf(startAt);\n        var indices = [];\n        for (var i = startAt; i > parentStartAt; --i) {\n            indices.push(i);\n        }\n        var arr = this.heapArray;\n        while (indices.length) {\n            var i = indices.shift();\n            if (this.compare(arr[i], bottomHeap.peek()) > 0) {\n                bottomHeap.replace(arr[i]);\n                if (i % 2) {\n                    indices.push(Heap.getParentIndexOf(i));\n                }\n            }\n        }\n        return bottomHeap.toArray();\n    };\n    /**\n     * Move a node to a new index, switching places\n     * @param  {Number} j First node index\n     * @param  {Number} k Another node index\n     */\n    Heap.prototype._moveNode = function (j, k) {\n        var _a;\n        _a = __read([this.heapArray[k], this.heapArray[j]], 2), this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];\n    };\n    /**\n     * Move a node down the tree (to the leaves) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    Heap.prototype._sortNodeDown = function (i) {\n        var _this = this;\n        var moveIt = i < this.heapArray.length - 1;\n        var self = this.heapArray[i];\n        var getPotentialParent = function (best, j) {\n            if (_this.heapArray.length > j && _this.compare(_this.heapArray[j], _this.heapArray[best]) < 0) {\n                best = j;\n            }\n            return best;\n        };\n        while (moveIt) {\n            var childrenIdx = Heap.getChildrenIndexOf(i);\n            var bestChildIndex = childrenIdx.reduce(getPotentialParent, childrenIdx[0]);\n            var bestChild = this.heapArray[bestChildIndex];\n            if (typeof bestChild !== 'undefined' && this.compare(self, bestChild) > 0) {\n                this._moveNode(i, bestChildIndex);\n                i = bestChildIndex;\n            }\n            else {\n                moveIt = false;\n            }\n        }\n    };\n    /**\n     * Move a node up the tree (to the root) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    Heap.prototype._sortNodeUp = function (i) {\n        var moveIt = i > 0;\n        while (moveIt) {\n            var pi = Heap.getParentIndexOf(i);\n            if (pi >= 0 && this.compare(this.heapArray[pi], this.heapArray[i]) > 0) {\n                this._moveNode(i, pi);\n                i = pi;\n            }\n            else {\n                moveIt = false;\n            }\n        }\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_push = function (n) {\n        // Use an inverted heap\n        var topHeap = new Heap(this._invertedCompare);\n        topHeap.limit = n;\n        var indices = [0];\n        var arr = this.heapArray;\n        while (indices.length) {\n            var i = indices.shift();\n            if (i < arr.length) {\n                if (topHeap.length < n) {\n                    topHeap.push(arr[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n                else if (this.compare(arr[i], topHeap.peek()) < 0) {\n                    topHeap.replace(arr[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n            }\n        }\n        return topHeap.toArray();\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: init + push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_fill = function (n) {\n        // Use an inverted heap\n        var heapArray = this.heapArray;\n        var topHeap = new Heap(this._invertedCompare);\n        topHeap.limit = n;\n        topHeap.heapArray = heapArray.slice(0, n);\n        topHeap.init();\n        var branch = Heap.getParentIndexOf(n - 1) + 1;\n        var indices = [];\n        for (var i = branch; i < n; ++i) {\n            indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i).filter(function (l) { return l < heapArray.length; })), false));\n        }\n        if ((n - 1) % 2) {\n            indices.push(n);\n        }\n        while (indices.length) {\n            var i = indices.shift();\n            if (i < heapArray.length) {\n                if (this.compare(heapArray[i], topHeap.peek()) < 0) {\n                    topHeap.replace(heapArray[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n            }\n        }\n        return topHeap.toArray();\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_heap = function (n) {\n        var topHeap = this.clone();\n        var result = [];\n        for (var i = 0; i < n; ++i) {\n            result.push(topHeap.pop());\n        }\n        return result;\n    };\n    /**\n     * Return index of the top element\n     * @param list\n     */\n    Heap.prototype._topIdxOf = function (list) {\n        if (!list.length) {\n            return -1;\n        }\n        var idx = 0;\n        var top = list[idx];\n        for (var i = 1; i < list.length; ++i) {\n            var comp = this.compare(list[i], top);\n            if (comp < 0) {\n                idx = i;\n                top = list[i];\n            }\n        }\n        return idx;\n    };\n    /**\n     * Return the top element\n     * @param list\n     */\n    Heap.prototype._topOf = function () {\n        var list = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            list[_i] = arguments[_i];\n        }\n        var heap = new Heap(this.compare);\n        heap.init(list);\n        return heap.peek();\n    };\n    return Heap;\n}());\n\nexport { Heap, Heap as default, toInt };\n","// DataView.getBigUint64 was added to relatively recent versions of Safari. It's pretty easy to\n// maintain this fallback code.\n//\n// eslint-disable-next-line @foxglove/no-boolean-parameters\nexport const getBigUint64 = typeof DataView.prototype.getBigUint64 === \"function\"\n    ? DataView.prototype.getBigUint64 // eslint-disable-line @typescript-eslint/unbound-method\n    : function (offset, littleEndian) {\n        const lo = littleEndian === true\n            ? this.getUint32(offset, littleEndian)\n            : this.getUint32(offset + 4, littleEndian);\n        const hi = littleEndian === true\n            ? this.getUint32(offset + 4, littleEndian)\n            : this.getUint32(offset, littleEndian);\n        return (BigInt(hi) << 32n) | BigInt(lo);\n    };\n//# sourceMappingURL=getBigUint64.js.map","import { getBigUint64 } from \"./getBigUint64\";\nexport default class Reader {\n    constructor(view, offset = 0) {\n        this.textDecoder = new TextDecoder();\n        this.view = view;\n        this.offset = offset;\n    }\n    uint8() {\n        const value = this.view.getUint8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    uint16() {\n        const value = this.view.getUint16(this.offset, true);\n        this.offset += 2;\n        return value;\n    }\n    uint32() {\n        const value = this.view.getUint32(this.offset, true);\n        this.offset += 4;\n        return value;\n    }\n    uint64() {\n        const value = getBigUint64.call(this.view, this.offset, true);\n        this.offset += 8;\n        return value;\n    }\n    string() {\n        const length = this.uint32();\n        if (this.offset + length > this.view.byteLength) {\n            throw new Error(`String length ${length} exceeds bounds of buffer`);\n        }\n        const value = this.textDecoder.decode(new Uint8Array(this.view.buffer, this.view.byteOffset + this.offset, length));\n        this.offset += length;\n        return value;\n    }\n    keyValuePairs(readKey, readValue) {\n        const length = this.uint32();\n        if (this.offset + length > this.view.byteLength) {\n            throw new Error(`Key-value pairs length ${length} exceeds bounds of buffer`);\n        }\n        const result = [];\n        const endOffset = this.offset + length;\n        try {\n            while (this.offset < endOffset) {\n                result.push([readKey(this), readValue(this)]);\n            }\n        }\n        catch (err) {\n            throw new Error(`Error reading key-value pairs: ${err.message}`);\n        }\n        if (this.offset !== endOffset) {\n            throw new Error(`Key-value pairs length (${this.offset - endOffset + length}) greater than expected (${length})`);\n        }\n        return result;\n    }\n    map(readKey, readValue) {\n        const length = this.uint32();\n        if (this.offset + length > this.view.byteLength) {\n            throw new Error(`Map length ${length} exceeds bounds of buffer`);\n        }\n        const result = new Map();\n        const endOffset = this.offset + length;\n        try {\n            while (this.offset < endOffset) {\n                const key = readKey(this);\n                const value = readValue(this);\n                const existingValue = result.get(key);\n                if (existingValue != undefined) {\n                    throw new Error(`Duplicate key ${String(key)} (${String(existingValue)} vs ${String(value)})`);\n                }\n                result.set(key, value);\n            }\n        }\n        catch (err) {\n            throw new Error(`Error reading map: ${err.message}`);\n        }\n        if (this.offset !== endOffset) {\n            throw new Error(`Map length (${this.offset - endOffset + length}) greater than expected (${length})`);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=Reader.js.map","/** Array.from(\"\\x89MCAP0\\r\\n\", (c) => c.charCodeAt(0)) */\nexport const MCAP_MAGIC = Object.freeze([137, 77, 67, 65, 80, 48, 13, 10]);\nexport var Opcode;\n(function (Opcode) {\n    Opcode[Opcode[\"MIN\"] = 1] = \"MIN\";\n    Opcode[Opcode[\"HEADER\"] = 1] = \"HEADER\";\n    Opcode[Opcode[\"FOOTER\"] = 2] = \"FOOTER\";\n    Opcode[Opcode[\"SCHEMA\"] = 3] = \"SCHEMA\";\n    Opcode[Opcode[\"CHANNEL\"] = 4] = \"CHANNEL\";\n    Opcode[Opcode[\"MESSAGE\"] = 5] = \"MESSAGE\";\n    Opcode[Opcode[\"CHUNK\"] = 6] = \"CHUNK\";\n    Opcode[Opcode[\"MESSAGE_INDEX\"] = 7] = \"MESSAGE_INDEX\";\n    Opcode[Opcode[\"CHUNK_INDEX\"] = 8] = \"CHUNK_INDEX\";\n    Opcode[Opcode[\"ATTACHMENT\"] = 9] = \"ATTACHMENT\";\n    Opcode[Opcode[\"ATTACHMENT_INDEX\"] = 10] = \"ATTACHMENT_INDEX\";\n    Opcode[Opcode[\"STATISTICS\"] = 11] = \"STATISTICS\";\n    Opcode[Opcode[\"METADATA\"] = 12] = \"METADATA\";\n    Opcode[Opcode[\"METADATA_INDEX\"] = 13] = \"METADATA_INDEX\";\n    Opcode[Opcode[\"SUMMARY_OFFSET\"] = 14] = \"SUMMARY_OFFSET\";\n    Opcode[Opcode[\"DATA_END\"] = 15] = \"DATA_END\";\n    Opcode[Opcode[\"MAX\"] = 15] = \"MAX\";\n})(Opcode || (Opcode = {}));\nexport function isKnownOpcode(opcode) {\n    return opcode >= Opcode.MIN && opcode <= Opcode.MAX;\n}\n//# sourceMappingURL=constants.js.map","import { crc32 } from \"@foxglove/crc\";\nimport Reader from \"./Reader\";\nimport { isKnownOpcode, MCAP_MAGIC, Opcode } from \"./constants\";\n/**\n * Parse a MCAP magic string at `startOffset` in `view`.\n */\nexport function parseMagic(view, startOffset) {\n    if (startOffset + MCAP_MAGIC.length > view.byteLength) {\n        return { usedBytes: 0 };\n    }\n    if (!MCAP_MAGIC.every((val, i) => val === view.getUint8(startOffset + i))) {\n        throw new Error(`Expected MCAP magic '${MCAP_MAGIC.map((val) => val.toString(16).padStart(2, \"0\")).join(\" \")}', found '${Array.from(MCAP_MAGIC, (_, i) => view\n            .getUint8(startOffset + i)\n            .toString(16)\n            .padStart(2, \"0\")).join(\" \")}'`);\n    }\n    return {\n        magic: { specVersion: \"0\" },\n        usedBytes: MCAP_MAGIC.length,\n    };\n}\n/**\n * Parse a MCAP record beginning at `startOffset` in `view`.\n */\nexport function parseRecord({ view, startOffset, validateCrcs, }) {\n    if (startOffset + /*opcode*/ 1 + /*record content length*/ 8 >= view.byteLength) {\n        return { usedBytes: 0 };\n    }\n    const headerReader = new Reader(view, startOffset);\n    const opcode = headerReader.uint8();\n    const recordLength = headerReader.uint64();\n    if (recordLength > Number.MAX_SAFE_INTEGER) {\n        throw new Error(`Record content length ${recordLength} is too large`);\n    }\n    const recordEndOffset = headerReader.offset + Number(recordLength);\n    if (recordEndOffset > view.byteLength) {\n        return { usedBytes: 0 };\n    }\n    if (!isKnownOpcode(opcode)) {\n        const record = {\n            type: \"Unknown\",\n            opcode,\n            data: new Uint8Array(view.buffer, view.byteOffset + headerReader.offset, Number(recordLength)),\n        };\n        return { record, usedBytes: recordEndOffset - startOffset };\n    }\n    const recordView = new DataView(view.buffer, view.byteOffset + headerReader.offset, Number(recordLength));\n    const reader = new Reader(recordView);\n    switch (opcode) {\n        case Opcode.HEADER: {\n            const profile = reader.string();\n            const library = reader.string();\n            const record = { type: \"Header\", profile, library };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.FOOTER: {\n            const summaryStart = reader.uint64();\n            const summaryOffsetStart = reader.uint64();\n            const summaryCrc = reader.uint32();\n            const record = {\n                type: \"Footer\",\n                summaryStart,\n                summaryOffsetStart,\n                summaryCrc,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.SCHEMA: {\n            const id = reader.uint16();\n            const name = reader.string();\n            const encoding = reader.string();\n            const dataLen = reader.uint32();\n            if (reader.offset + dataLen > recordView.byteLength) {\n                throw new Error(`Schema data length ${dataLen} exceeds bounds of record`);\n            }\n            const data = new Uint8Array(recordView.buffer.slice(recordView.byteOffset + reader.offset, recordView.byteOffset + reader.offset + dataLen));\n            reader.offset += dataLen;\n            const record = {\n                type: \"Schema\",\n                id,\n                encoding,\n                name,\n                data,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.CHANNEL: {\n            const channelId = reader.uint16();\n            const schemaId = reader.uint16();\n            const topicName = reader.string();\n            const messageEncoding = reader.string();\n            const metadata = reader.map((r) => r.string(), (r) => r.string());\n            const record = {\n                type: \"Channel\",\n                id: channelId,\n                schemaId,\n                topic: topicName,\n                messageEncoding,\n                metadata,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.MESSAGE: {\n            const channelId = reader.uint16();\n            const sequence = reader.uint32();\n            const logTime = reader.uint64();\n            const publishTime = reader.uint64();\n            const data = new Uint8Array(recordView.buffer.slice(recordView.byteOffset + reader.offset, recordView.byteOffset + recordView.byteLength));\n            const record = {\n                type: \"Message\",\n                channelId,\n                sequence,\n                logTime,\n                publishTime,\n                data,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.CHUNK: {\n            const startTime = reader.uint64();\n            const endTime = reader.uint64();\n            const uncompressedSize = reader.uint64();\n            const uncompressedCrc = reader.uint32();\n            const compression = reader.string();\n            const recordByteLength = Number(reader.uint64());\n            if (recordByteLength + reader.offset > recordView.byteLength) {\n                throw new Error(\"Chunk records length exceeds remaining record size\");\n            }\n            const records = new Uint8Array(recordView.buffer.slice(recordView.byteOffset + reader.offset, recordView.byteOffset + reader.offset + recordByteLength));\n            const record = {\n                type: \"Chunk\",\n                messageStartTime: startTime,\n                messageEndTime: endTime,\n                compression,\n                uncompressedSize,\n                uncompressedCrc,\n                records,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.MESSAGE_INDEX: {\n            const channelId = reader.uint16();\n            const records = reader.keyValuePairs((r) => r.uint64(), (r) => r.uint64());\n            const record = {\n                type: \"MessageIndex\",\n                channelId,\n                records,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.CHUNK_INDEX: {\n            const messageStartTime = reader.uint64();\n            const messageEndTime = reader.uint64();\n            const chunkStartOffset = reader.uint64();\n            const chunkLength = reader.uint64();\n            const messageIndexOffsets = reader.map((r) => r.uint16(), (r) => r.uint64());\n            const messageIndexLength = reader.uint64();\n            const compression = reader.string();\n            const compressedSize = reader.uint64();\n            const uncompressedSize = reader.uint64();\n            const record = {\n                type: \"ChunkIndex\",\n                messageStartTime,\n                messageEndTime,\n                chunkStartOffset,\n                chunkLength,\n                messageIndexOffsets,\n                messageIndexLength,\n                compression,\n                compressedSize,\n                uncompressedSize,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.ATTACHMENT: {\n            const logTime = reader.uint64();\n            const createTime = reader.uint64();\n            const name = reader.string();\n            const mediaType = reader.string();\n            const dataLen = reader.uint64();\n            if (BigInt(recordView.byteOffset + reader.offset) + dataLen > Number.MAX_SAFE_INTEGER) {\n                throw new Error(`Attachment too large: ${dataLen}`);\n            }\n            if (reader.offset + Number(dataLen) + 4 /*crc*/ > recordView.byteLength) {\n                throw new Error(`Attachment data length ${dataLen} exceeds bounds of record`);\n            }\n            const data = new Uint8Array(recordView.buffer.slice(recordView.byteOffset + reader.offset, recordView.byteOffset + reader.offset + Number(dataLen)));\n            reader.offset += Number(dataLen);\n            const crcLength = reader.offset;\n            const expectedCrc = reader.uint32();\n            if (validateCrcs && expectedCrc !== 0) {\n                const actualCrc = crc32(new DataView(recordView.buffer, recordView.byteOffset, crcLength));\n                if (actualCrc !== expectedCrc) {\n                    throw new Error(`Attachment CRC32 mismatch: expected ${expectedCrc}, actual ${actualCrc}`);\n                }\n            }\n            const record = {\n                type: \"Attachment\",\n                logTime,\n                createTime,\n                name,\n                mediaType,\n                data,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.ATTACHMENT_INDEX: {\n            const offset = reader.uint64();\n            const length = reader.uint64();\n            const logTime = reader.uint64();\n            const createTime = reader.uint64();\n            const dataSize = reader.uint64();\n            const name = reader.string();\n            const mediaType = reader.string();\n            const record = {\n                type: \"AttachmentIndex\",\n                offset,\n                length,\n                logTime,\n                createTime,\n                dataSize,\n                name,\n                mediaType,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.STATISTICS: {\n            const messageCount = reader.uint64();\n            const schemaCount = reader.uint16();\n            const channelCount = reader.uint32();\n            const attachmentCount = reader.uint32();\n            const metadataCount = reader.uint32();\n            const chunkCount = reader.uint32();\n            const messageStartTime = reader.uint64();\n            const messageEndTime = reader.uint64();\n            const channelMessageCounts = reader.map((r) => r.uint16(), (r) => r.uint64());\n            const record = {\n                type: \"Statistics\",\n                messageCount,\n                schemaCount,\n                channelCount,\n                attachmentCount,\n                metadataCount,\n                chunkCount,\n                messageStartTime,\n                messageEndTime,\n                channelMessageCounts,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.METADATA: {\n            const name = reader.string();\n            const metadata = reader.map((r) => r.string(), (r) => r.string());\n            const record = { type: \"Metadata\", metadata, name };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.METADATA_INDEX: {\n            const offset = reader.uint64();\n            const length = reader.uint64();\n            const name = reader.string();\n            const record = {\n                type: \"MetadataIndex\",\n                offset,\n                length,\n                name,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.SUMMARY_OFFSET: {\n            const groupOpcode = reader.uint8();\n            const groupStart = reader.uint64();\n            const groupLength = reader.uint64();\n            const record = {\n                type: \"SummaryOffset\",\n                groupOpcode,\n                groupStart,\n                groupLength,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.DATA_END: {\n            const dataSectionCrc = reader.uint32();\n            const record = {\n                type: \"DataEnd\",\n                dataSectionCrc,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n    }\n}\n//# sourceMappingURL=parse.js.map","/**\n * Return the lowest index of `array` where an element can be inserted and maintain its sorted\n * order. This is a specialization of lodash's sortedIndexBy().\n */\nexport function sortedIndexBy(array, value, iteratee) {\n    let low = 0;\n    let high = array.length;\n    if (high === 0) {\n        return 0;\n    }\n    const computedValue = iteratee(value);\n    while (low < high) {\n        const mid = (low + high) >>> 1;\n        const curComputedValue = iteratee(array[mid][0]);\n        if (curComputedValue < computedValue) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return high;\n}\n//# sourceMappingURL=sortedIndexBy.js.map","import Heap from \"heap-js\";\nimport { parseRecord } from \"./parse\";\nimport { sortedIndexBy } from \"./sortedIndexBy\";\n/**\n * ChunkCursor represents the reader's position in a particular chunk. The indexed reader holds\n * ChunkCursors in a heap in order to merge multiple chunks together.\n *\n * Each chunk can contain multiple channels, and so a ChunkCursor itself contains a heap of cursors\n * pointing into the message index for each channel of interest.\n */\nexport class ChunkCursor {\n    constructor(params) {\n        this.chunkIndex = params.chunkIndex;\n        this.relevantChannels = params.relevantChannels;\n        this.startTime = params.startTime;\n        this.endTime = params.endTime;\n        this.reverse = params.reverse;\n        if (this.chunkIndex.messageIndexLength === 0n) {\n            throw new Error(`Chunks without message indexes are not currently supported`);\n        }\n    }\n    /**\n     * Returns `< 0` if the callee's next available message logTime is earlier than `other`'s, `> 0`\n     * for the opposite case. Never returns `0` because ties are broken by the chunks' offsets in the\n     * file.\n     *\n     * Cursors that still need `loadMessageIndexes()` are sorted earlier so the caller can load them\n     * and re-sort the cursors.\n     */\n    compare(other) {\n        if (this.reverse !== other.reverse) {\n            throw new Error(\"Cannot compare a reversed ChunkCursor to a non-reversed ChunkCursor\");\n        }\n        let diff = Number(this.getSortTime() - other.getSortTime());\n        // Break ties by chunk offset in the file\n        if (diff === 0) {\n            diff = Number(this.chunkIndex.chunkStartOffset - other.chunkIndex.chunkStartOffset);\n        }\n        return this.reverse ? -diff : diff;\n    }\n    /**\n     * Returns true if there are more messages available in the chunk. Message indexes must have been\n     * loaded before using this method.\n     */\n    hasMoreMessages() {\n        if (!this.messageIndexCursors) {\n            throw new Error(\"loadMessageIndexes() must be called before hasMore()\");\n        }\n        return this.messageIndexCursors.size() > 0;\n    }\n    /**\n     * Pop a message offset off of the chunk cursor. Message indexes must have been loaded before\n     * using this method.\n     */\n    popMessage() {\n        if (!this.messageIndexCursors) {\n            throw new Error(\"loadMessageIndexes() must be called before popMessage()\");\n        }\n        const cursor = this.messageIndexCursors.peek();\n        if (!cursor) {\n            throw new Error(`Unexpected popMessage() call when no more messages are available, in chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n        }\n        const record = cursor.records[cursor.index];\n        const [logTime] = record;\n        if (this.startTime != undefined && logTime < this.startTime) {\n            throw new Error(`Encountered message with logTime (${logTime}) prior to startTime (${this.startTime}) in chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n        }\n        if (this.endTime != undefined && logTime > this.endTime) {\n            throw new Error(`Encountered message with logTime (${logTime}) after endTime (${this.endTime}) in chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n        }\n        const nextRecord = cursor.records[cursor.index + 1];\n        if (nextRecord && this.reverse) {\n            if (this.startTime == undefined || nextRecord[0] >= this.startTime) {\n                cursor.index++;\n                this.messageIndexCursors.replace(cursor);\n                return record;\n            }\n        }\n        else if (nextRecord) {\n            if (this.endTime == undefined || nextRecord[0] <= this.endTime) {\n                cursor.index++;\n                this.messageIndexCursors.replace(cursor);\n                return record;\n            }\n        }\n        this.messageIndexCursors.pop();\n        return record;\n    }\n    /**\n     * Returns true if message indexes have been loaded, false if `loadMessageIndexes()` needs to be\n     * called.\n     */\n    hasMessageIndexes() {\n        return this.messageIndexCursors != undefined;\n    }\n    async loadMessageIndexes(readable) {\n        const reverse = this.reverse;\n        this.messageIndexCursors = new Heap((a, b) => {\n            const logTimeA = a.records[a.index]?.[0];\n            const logTimeB = b.records[b.index]?.[0];\n            if (reverse) {\n                if (logTimeA == undefined) {\n                    return -1;\n                }\n                else if (logTimeB == undefined) {\n                    return 1;\n                }\n                return Number(logTimeB - logTimeA);\n            }\n            else {\n                if (logTimeA == undefined) {\n                    return 1;\n                }\n                else if (logTimeB == undefined) {\n                    return -1;\n                }\n                return Number(logTimeA - logTimeB);\n            }\n        });\n        let messageIndexStartOffset;\n        let relevantMessageIndexStartOffset;\n        for (const [channelId, offset] of this.chunkIndex.messageIndexOffsets) {\n            if (messageIndexStartOffset == undefined || offset < messageIndexStartOffset) {\n                messageIndexStartOffset = offset;\n            }\n            if (!this.relevantChannels || this.relevantChannels.has(channelId)) {\n                if (relevantMessageIndexStartOffset == undefined ||\n                    offset < relevantMessageIndexStartOffset) {\n                    relevantMessageIndexStartOffset = offset;\n                }\n            }\n        }\n        if (messageIndexStartOffset == undefined || relevantMessageIndexStartOffset == undefined) {\n            return;\n        }\n        // Future optimization: read only message indexes for given channelIds, not all message indexes for the chunk\n        const messageIndexEndOffset = messageIndexStartOffset + this.chunkIndex.messageIndexLength;\n        const messageIndexes = await readable.read(relevantMessageIndexStartOffset, messageIndexEndOffset - relevantMessageIndexStartOffset);\n        const messageIndexesView = new DataView(messageIndexes.buffer, messageIndexes.byteOffset, messageIndexes.byteLength);\n        let offset = 0;\n        for (let result; (result = parseRecord({ view: messageIndexesView, startOffset: offset, validateCrcs: true })),\n            result.record; offset += result.usedBytes) {\n            if (result.record.type !== \"MessageIndex\") {\n                continue;\n            }\n            if (result.record.records.length === 0 ||\n                (this.relevantChannels && !this.relevantChannels.has(result.record.channelId))) {\n                continue;\n            }\n            result.record.records.sort(([logTimeA], [logTimeB]) => Number(logTimeA - logTimeB));\n            if (reverse) {\n                // If we used `logTimeB - logTimeA` as the comparator for reverse iteration, messages with\n                // the same timestamp would not be in reverse order. To avoid this problem we use reverse()\n                // instead.\n                result.record.records.reverse();\n            }\n            for (let i = 0; i < result.record.records.length; i++) {\n                const [logTime] = result.record.records[i];\n                if (logTime < this.chunkIndex.messageStartTime) {\n                    throw new Error(`Encountered message index entry in channel ${result.record.channelId} with logTime (${logTime}) earlier than chunk messageStartTime (${this.chunkIndex.messageStartTime}) in chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n                }\n                if (logTime > this.chunkIndex.messageEndTime) {\n                    throw new Error(`Encountered message index entry in channel ${result.record.channelId} with logTime (${logTime}) later than chunk messageEndTime (${this.chunkIndex.messageEndTime}) in chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n                }\n            }\n            let startIndex = 0;\n            if (reverse) {\n                if (this.endTime != undefined) {\n                    startIndex = sortedIndexBy(result.record.records, this.endTime, (logTime) => -logTime);\n                }\n            }\n            else {\n                if (this.startTime != undefined) {\n                    startIndex = sortedIndexBy(result.record.records, this.startTime, (logTime) => logTime);\n                }\n            }\n            if (startIndex >= result.record.records.length) {\n                continue;\n            }\n            if (reverse) {\n                if (this.startTime != undefined && result.record.records[startIndex][0] < this.startTime) {\n                    continue;\n                }\n            }\n            else {\n                if (this.endTime != undefined && result.record.records[startIndex][0] > this.endTime) {\n                    continue;\n                }\n            }\n            this.messageIndexCursors.push({\n                index: startIndex,\n                channelId: result.record.channelId,\n                records: result.record.records,\n            });\n        }\n        if (offset !== messageIndexesView.byteLength) {\n            throw new Error(`${messageIndexesView.byteLength - offset} bytes remaining in message index section`);\n        }\n    }\n    getSortTime() {\n        if (!this.messageIndexCursors) {\n            return this.reverse ? this.chunkIndex.messageEndTime : this.chunkIndex.messageStartTime;\n        }\n        const cursor = this.messageIndexCursors.peek();\n        if (!cursor) {\n            throw new Error(`Unexpected empty cursor for chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n        }\n        return cursor.records[cursor.index][0];\n    }\n}\n//# sourceMappingURL=ChunkCursor.js.map","import { crc32, crc32Final, crc32Init, crc32Update } from \"@foxglove/crc\";\nimport Heap from \"heap-js\";\nimport { ChunkCursor } from \"./ChunkCursor\";\nimport { MCAP_MAGIC } from \"./constants\";\nimport { parseMagic, parseRecord } from \"./parse\";\nexport class McapIndexedReader {\n    constructor(args) {\n        this.metadataIndexes = [];\n        this.readable = args.readable;\n        this.chunkIndexes = args.chunkIndexes;\n        this.attachmentIndexes = args.attachmentIndexes;\n        this.metadataIndexes = args.metadataIndexes;\n        this.statistics = args.statistics;\n        this.decompressHandlers = args.decompressHandlers;\n        this.channelsById = args.channelsById;\n        this.schemasById = args.schemasById;\n        this.summaryOffsetsByOpcode = args.summaryOffsetsByOpcode;\n        this.header = args.header;\n        this.footer = args.footer;\n        for (const chunk of args.chunkIndexes) {\n            if (this.messageStartTime == undefined || chunk.messageStartTime < this.messageStartTime) {\n                this.messageStartTime = chunk.messageStartTime;\n            }\n            if (this.messageEndTime == undefined || chunk.messageEndTime > this.messageEndTime) {\n                this.messageEndTime = chunk.messageEndTime;\n            }\n        }\n        for (const attachment of args.attachmentIndexes) {\n            if (this.attachmentStartTime == undefined || attachment.logTime < this.attachmentStartTime) {\n                this.attachmentStartTime = attachment.logTime;\n            }\n            if (this.attachmentEndTime == undefined || attachment.logTime > this.attachmentEndTime) {\n                this.attachmentEndTime = attachment.logTime;\n            }\n        }\n    }\n    errorWithLibrary(message) {\n        return new Error(`${message} [library=${this.header.library}]`);\n    }\n    static async Initialize({ readable, decompressHandlers, }) {\n        const size = await readable.size();\n        let header;\n        {\n            const headerPrefix = await readable.read(0n, BigInt(MCAP_MAGIC.length + /* Opcode.HEADER */ 1 + /* record content length */ 8));\n            const headerPrefixView = new DataView(headerPrefix.buffer, headerPrefix.byteOffset, headerPrefix.byteLength);\n            void parseMagic(headerPrefixView, 0);\n            const headerLength = headerPrefixView.getBigUint64(MCAP_MAGIC.length + /* Opcode.HEADER */ 1, true);\n            const headerRecord = await readable.read(BigInt(MCAP_MAGIC.length), \n            /* Opcode.HEADER */ 1n + /* record content length */ 8n + headerLength);\n            const headerResult = parseRecord({\n                view: new DataView(headerRecord.buffer, headerRecord.byteOffset, headerRecord.byteLength),\n                startOffset: 0,\n                validateCrcs: true,\n            });\n            if (headerResult.record?.type !== \"Header\") {\n                throw new Error(`Unable to read header at beginning of file; found ${headerResult.record?.type ?? \"nothing\"}`);\n            }\n            if (headerResult.usedBytes !== headerRecord.byteLength) {\n                throw new Error(`${headerRecord.byteLength - headerResult.usedBytes} bytes remaining after parsing header`);\n            }\n            header = headerResult.record;\n        }\n        function errorWithLibrary(message) {\n            return new Error(`${message} [library=${header.library}]`);\n        }\n        let footerOffset;\n        let footerAndMagicView;\n        {\n            const headerLengthLowerBound = BigInt(MCAP_MAGIC.length +\n                /* Opcode.HEADER */ 1 +\n                /* record content length */ 8 +\n                /* profile length */ 4 +\n                /* library length */ 4);\n            const footerAndMagicReadLength = BigInt(\n            /* Opcode.FOOTER */ 1 +\n                /* record content length */ 8 +\n                /* summaryStart */ 8 +\n                /* summaryOffsetStart */ 8 +\n                /* crc */ 4 +\n                MCAP_MAGIC.length);\n            if (size < headerLengthLowerBound + footerAndMagicReadLength) {\n                throw errorWithLibrary(`File size (${size}) is too small to be valid MCAP`);\n            }\n            footerOffset = size - footerAndMagicReadLength;\n            const footerBuffer = await readable.read(footerOffset, footerAndMagicReadLength);\n            footerAndMagicView = new DataView(footerBuffer.buffer, footerBuffer.byteOffset, footerBuffer.byteLength);\n        }\n        try {\n            void parseMagic(footerAndMagicView, footerAndMagicView.byteLength - MCAP_MAGIC.length);\n        }\n        catch (error) {\n            throw errorWithLibrary(error.message);\n        }\n        let footer;\n        {\n            const footerResult = parseRecord({\n                view: footerAndMagicView,\n                startOffset: 0,\n                validateCrcs: true,\n            });\n            if (footerResult.record?.type !== \"Footer\") {\n                throw errorWithLibrary(`Unable to read footer from end of file (offset ${footerOffset}); found ${footerResult.record?.type ?? \"nothing\"}`);\n            }\n            if (footerResult.usedBytes !== footerAndMagicView.byteLength - MCAP_MAGIC.length) {\n                throw errorWithLibrary(`${footerAndMagicView.byteLength - MCAP_MAGIC.length - footerResult.usedBytes} bytes remaining after parsing footer`);\n            }\n            footer = footerResult.record;\n        }\n        if (footer.summaryStart === 0n) {\n            throw errorWithLibrary(\"File is not indexed\");\n        }\n        // Copy the footer prefix before reading the summary because calling readable.read() may reuse the buffer.\n        const footerPrefix = new Uint8Array(\n        /* Opcode.FOOTER */ 1 +\n            /* record content length */ 8 +\n            /* summary start */ 8 +\n            /* summary offset start */ 8);\n        footerPrefix.set(new Uint8Array(footerAndMagicView.buffer, footerAndMagicView.byteOffset, footerPrefix.byteLength));\n        // Future optimization: avoid holding whole summary blob in memory at once\n        const allSummaryData = await readable.read(footer.summaryStart, footerOffset - footer.summaryStart);\n        if (footer.summaryCrc !== 0) {\n            let summaryCrc = crc32Init();\n            summaryCrc = crc32Update(summaryCrc, allSummaryData);\n            summaryCrc = crc32Update(summaryCrc, footerPrefix);\n            summaryCrc = crc32Final(summaryCrc);\n            if (summaryCrc !== footer.summaryCrc) {\n                throw errorWithLibrary(`Incorrect summary CRC ${summaryCrc} (expected ${footer.summaryCrc})`);\n            }\n        }\n        const indexView = new DataView(allSummaryData.buffer, allSummaryData.byteOffset, allSummaryData.byteLength);\n        const channelsById = new Map();\n        const schemasById = new Map();\n        const chunkIndexes = [];\n        const attachmentIndexes = [];\n        const metadataIndexes = [];\n        const summaryOffsetsByOpcode = new Map();\n        let statistics;\n        let offset = 0;\n        for (let result; (result = parseRecord({ view: indexView, startOffset: offset, validateCrcs: true })),\n            result.record; offset += result.usedBytes) {\n            switch (result.record.type) {\n                case \"Schema\":\n                    schemasById.set(result.record.id, result.record);\n                    break;\n                case \"Channel\":\n                    channelsById.set(result.record.id, result.record);\n                    break;\n                case \"ChunkIndex\":\n                    chunkIndexes.push(result.record);\n                    break;\n                case \"AttachmentIndex\":\n                    attachmentIndexes.push(result.record);\n                    break;\n                case \"MetadataIndex\":\n                    metadataIndexes.push(result.record);\n                    break;\n                case \"Statistics\":\n                    if (statistics) {\n                        throw errorWithLibrary(\"Duplicate Statistics record\");\n                    }\n                    statistics = result.record;\n                    break;\n                case \"SummaryOffset\":\n                    summaryOffsetsByOpcode.set(result.record.groupOpcode, result.record);\n                    break;\n                case \"Header\":\n                case \"Footer\":\n                case \"Message\":\n                case \"Chunk\":\n                case \"MessageIndex\":\n                case \"Attachment\":\n                case \"Metadata\":\n                case \"DataEnd\":\n                    throw errorWithLibrary(`${result.record.type} record not allowed in index section`);\n                case \"Unknown\":\n                    break;\n            }\n        }\n        if (offset !== indexView.byteLength) {\n            throw errorWithLibrary(`${indexView.byteLength - offset} bytes remaining in index section`);\n        }\n        return new McapIndexedReader({\n            readable,\n            chunkIndexes,\n            attachmentIndexes,\n            metadataIndexes,\n            statistics,\n            decompressHandlers,\n            channelsById,\n            schemasById,\n            summaryOffsetsByOpcode,\n            header,\n            footer,\n        });\n    }\n    async *readMessages(args = {}) {\n        const { topics, startTime = this.messageStartTime, endTime = this.messageEndTime, reverse = false, validateCrcs, } = args;\n        if (startTime == undefined || endTime == undefined) {\n            return;\n        }\n        let relevantChannels;\n        if (topics) {\n            relevantChannels = new Set();\n            for (const channel of this.channelsById.values()) {\n                if (topics.includes(channel.topic)) {\n                    relevantChannels.add(channel.id);\n                }\n            }\n        }\n        const chunkCursors = new Heap((a, b) => a.compare(b));\n        for (const chunkIndex of this.chunkIndexes) {\n            if (chunkIndex.messageStartTime <= endTime && chunkIndex.messageEndTime >= startTime) {\n                chunkCursors.push(new ChunkCursor({ chunkIndex, relevantChannels, startTime, endTime, reverse }));\n            }\n        }\n        // Holds the decompressed chunk data for \"active\" chunks. Items are added below when a chunk\n        // cursor becomes active (i.e. when we first need to access messages from the chunk) and removed\n        // when the cursor is removed from the heap.\n        const chunkViewCache = new Map();\n        for (let cursor; (cursor = chunkCursors.peek());) {\n            if (!cursor.hasMessageIndexes()) {\n                // If we encounter a chunk whose message indexes have not been loaded yet, load them and re-organize the heap.\n                await cursor.loadMessageIndexes(this.readable);\n                if (cursor.hasMoreMessages()) {\n                    chunkCursors.replace(cursor);\n                }\n                else {\n                    chunkCursors.pop();\n                }\n                continue;\n            }\n            let chunkView = chunkViewCache.get(cursor.chunkIndex.chunkStartOffset);\n            if (!chunkView) {\n                chunkView = await this.loadChunkData(cursor.chunkIndex);\n                chunkViewCache.set(cursor.chunkIndex.chunkStartOffset, chunkView);\n            }\n            const [logTime, offset] = cursor.popMessage();\n            if (offset >= BigInt(chunkView.byteLength)) {\n                throw this.errorWithLibrary(`Message offset beyond chunk bounds (log time ${logTime}, offset ${offset}, chunk data length ${chunkView.byteLength}) in chunk at offset ${cursor.chunkIndex.chunkStartOffset}`);\n            }\n            const result = parseRecord({\n                view: chunkView,\n                startOffset: Number(offset),\n                validateCrcs: validateCrcs ?? true,\n            });\n            if (!result.record) {\n                throw this.errorWithLibrary(`Unable to parse record at offset ${offset} in chunk at offset ${cursor.chunkIndex.chunkStartOffset}`);\n            }\n            if (result.record.type !== \"Message\") {\n                throw this.errorWithLibrary(`Unexpected record type ${result.record.type} in message index (time ${logTime}, offset ${offset} in chunk at offset ${cursor.chunkIndex.chunkStartOffset})`);\n            }\n            if (result.record.logTime !== logTime) {\n                throw this.errorWithLibrary(`Message log time ${result.record.logTime} did not match message index entry (${logTime} at offset ${offset} in chunk at offset ${cursor.chunkIndex.chunkStartOffset})`);\n            }\n            yield result.record;\n            if (cursor.hasMoreMessages()) {\n                chunkCursors.replace(cursor);\n            }\n            else {\n                chunkCursors.pop();\n                chunkViewCache.delete(cursor.chunkIndex.chunkStartOffset);\n            }\n        }\n    }\n    async *readMetadata(args = {}) {\n        const { name } = args;\n        for (const metadataIndex of this.metadataIndexes) {\n            if (name != undefined && metadataIndex.name !== name) {\n                continue;\n            }\n            const metadataData = await this.readable.read(metadataIndex.offset, metadataIndex.length);\n            const metadataResult = parseRecord({\n                view: new DataView(metadataData.buffer, metadataData.byteOffset, metadataData.byteLength),\n                startOffset: 0,\n                validateCrcs: false,\n            });\n            if (metadataResult.record?.type !== \"Metadata\") {\n                throw this.errorWithLibrary(`Metadata data at offset ${metadataIndex.offset} does not point to metadata record (found ${String(metadataResult.record?.type)})`);\n            }\n            yield metadataResult.record;\n        }\n    }\n    async *readAttachments(args = {}) {\n        const { name, mediaType, startTime = this.attachmentStartTime, endTime = this.attachmentEndTime, validateCrcs, } = args;\n        if (startTime == undefined || endTime == undefined) {\n            return;\n        }\n        for (const attachmentIndex of this.attachmentIndexes) {\n            if (name != undefined && attachmentIndex.name !== name) {\n                continue;\n            }\n            if (mediaType != undefined && attachmentIndex.mediaType !== mediaType) {\n                continue;\n            }\n            if (attachmentIndex.logTime > endTime || attachmentIndex.logTime < startTime) {\n                continue;\n            }\n            const attachmentData = await this.readable.read(attachmentIndex.offset, attachmentIndex.length);\n            const attachmentResult = parseRecord({\n                view: new DataView(attachmentData.buffer, attachmentData.byteOffset, attachmentData.byteLength),\n                startOffset: 0,\n                validateCrcs: validateCrcs ?? true,\n            });\n            if (attachmentResult.record?.type !== \"Attachment\") {\n                throw this.errorWithLibrary(`Attachment data at offset ${attachmentIndex.offset} does not point to attachment record (found ${String(attachmentResult.record?.type)})`);\n            }\n            yield attachmentResult.record;\n        }\n    }\n    async loadChunkData(chunkIndex) {\n        const chunkData = await this.readable.read(chunkIndex.chunkStartOffset, chunkIndex.chunkLength);\n        const chunkResult = parseRecord({\n            view: new DataView(chunkData.buffer, chunkData.byteOffset, chunkData.byteLength),\n            startOffset: 0,\n            validateCrcs: true,\n        });\n        if (chunkResult.record?.type !== \"Chunk\") {\n            throw this.errorWithLibrary(`Chunk start offset ${chunkIndex.chunkStartOffset} does not point to chunk record (found ${String(chunkResult.record?.type)})`);\n        }\n        const chunk = chunkResult.record;\n        let buffer = chunk.records;\n        if (chunk.compression !== \"\" && buffer.byteLength > 0) {\n            const decompress = this.decompressHandlers?.[chunk.compression];\n            if (!decompress) {\n                throw this.errorWithLibrary(`Unsupported compression ${chunk.compression}`);\n            }\n            buffer = decompress(buffer, chunk.uncompressedSize);\n        }\n        if (chunk.uncompressedCrc !== 0) {\n            const chunkCrc = crc32(buffer);\n            if (chunkCrc !== chunk.uncompressedCrc) {\n                throw this.errorWithLibrary(`Incorrect chunk CRC ${chunkCrc} (expected ${chunk.uncompressedCrc})`);\n            }\n        }\n        return new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n}\n//# sourceMappingURL=McapIndexedReader.js.map","/**\n * A growable buffer for use when processing a stream of data.\n */\nexport default class StreamBuffer {\n    constructor(initialCapacity = 0) {\n        this.buffer = new ArrayBuffer(initialCapacity);\n        this.view = new DataView(this.buffer, 0, 0);\n    }\n    bytesRemaining() {\n        return this.view.byteLength;\n    }\n    /** Mark some data as consumed, so the memory can be reused when new data is appended. */\n    consume(count) {\n        this.view = new DataView(this.buffer, this.view.byteOffset + count, this.view.byteLength - count);\n    }\n    /** Add data to the buffer, shifting existing data or reallocating if necessary. */\n    append(data) {\n        if (this.view.byteOffset + this.view.byteLength + data.byteLength <= this.buffer.byteLength) {\n            // Data fits by appending only\n            const array = new Uint8Array(this.view.buffer, this.view.byteOffset);\n            array.set(data, this.view.byteLength);\n            this.view = new DataView(this.buffer, this.view.byteOffset, this.view.byteLength + data.byteLength);\n        }\n        else if (this.view.byteLength + data.byteLength <= this.buffer.byteLength) {\n            // Data fits in allocated buffer but requires moving existing data to start of buffer\n            const oldData = new Uint8Array(this.buffer, this.view.byteOffset, this.view.byteLength);\n            const array = new Uint8Array(this.buffer);\n            array.set(oldData, 0);\n            array.set(data, oldData.byteLength);\n            this.view = new DataView(this.buffer, 0, this.view.byteLength + data.byteLength);\n        }\n        else {\n            // New data doesn't fit, copy to a new buffer\n            // Currently, the new buffer size may be smaller than the old size. For future optimizations,\n            // we could consider making the buffer size increase monotonically.\n            const oldData = new Uint8Array(this.buffer, this.view.byteOffset, this.view.byteLength);\n            this.buffer = new ArrayBuffer((this.view.byteLength + data.byteLength) * 2);\n            const array = new Uint8Array(this.buffer);\n            array.set(oldData, 0);\n            array.set(data, oldData.byteLength);\n            this.view = new DataView(this.buffer, 0, this.view.byteLength + data.byteLength);\n        }\n    }\n}\n//# sourceMappingURL=StreamBuffer.js.map","import { crc32 } from \"@foxglove/crc\";\nimport StreamBuffer from \"./StreamBuffer\";\nimport { MCAP_MAGIC } from \"./constants\";\nimport { parseMagic, parseRecord } from \"./parse\";\n/**\n * A streaming reader for MCAP files.\n *\n * Usage example:\n * ```\n * const reader = new McapStreamReader();\n * stream.on(\"data\", (data) => {\n *   try {\n *     reader.append(data);\n *     for (let record; (record = reader.nextRecord()); ) {\n *       // process available records\n *     }\n *   } catch (e) {\n *     // handle errors\n *   }\n * });\n * ```\n */\nexport default class McapStreamReader {\n    constructor({ includeChunks = false, decompressHandlers = {}, validateCrcs = true, noMagicPrefix = false, } = {}) {\n        this.buffer = new StreamBuffer(MCAP_MAGIC.length * 2);\n        this.doneReading = false;\n        this.generator = this.read();\n        this.channelsById = new Map();\n        this.includeChunks = includeChunks;\n        this.decompressHandlers = decompressHandlers;\n        this.validateCrcs = validateCrcs;\n        this.noMagicPrefix = noMagicPrefix;\n    }\n    /** @returns True if a valid, complete mcap file has been parsed. */\n    done() {\n        return this.doneReading;\n    }\n    /** @returns The number of bytes that have been received by `append()` but not yet parsed. */\n    bytesRemaining() {\n        return this.buffer.bytesRemaining();\n    }\n    /**\n     * Provide the reader with newly received bytes for it to process. After calling this function,\n     * call `nextRecord()` again to parse any records that are now available.\n     */\n    append(data) {\n        if (this.doneReading) {\n            throw new Error(\"Already done reading\");\n        }\n        this.buffer.append(data);\n    }\n    /**\n     * Read the next record from the stream if possible. If not enough data is available to parse a\n     * complete record, or if the reading has terminated with a valid footer, returns undefined.\n     *\n     * This function may throw any errors encountered during parsing. If an error is thrown, the\n     * reader is in an unspecified state and should no longer be used.\n     */\n    nextRecord() {\n        if (this.doneReading) {\n            return undefined;\n        }\n        const result = this.generator.next();\n        if (result.value?.type === \"Channel\") {\n            const existing = this.channelsById.get(result.value.id);\n            this.channelsById.set(result.value.id, result.value);\n            if (existing && !isChannelEqual(existing, result.value)) {\n                throw new Error(`Channel record for id ${result.value.id} (topic: ${result.value.topic}) differs from previous channel record of the same id.`);\n            }\n        }\n        else if (result.value?.type === \"Message\") {\n            const channelId = result.value.channelId;\n            const existing = this.channelsById.get(channelId);\n            if (!existing) {\n                throw new Error(`Encountered message on channel ${channelId} without prior channel record`);\n            }\n        }\n        if (result.done === true) {\n            this.doneReading = true;\n        }\n        return result.value;\n    }\n    *read() {\n        if (!this.noMagicPrefix) {\n            let magic, usedBytes;\n            while ((({ magic, usedBytes } = parseMagic(this.buffer.view, 0)), !magic)) {\n                yield;\n            }\n            this.buffer.consume(usedBytes);\n        }\n        let header;\n        function errorWithLibrary(message) {\n            return new Error(`${message} ${header ? `[library=${header.library}]` : \"[no header]\"}`);\n        }\n        for (;;) {\n            let record;\n            {\n                let usedBytes;\n                while ((({ record, usedBytes } = parseRecord({\n                    view: this.buffer.view,\n                    startOffset: 0,\n                    validateCrcs: this.validateCrcs,\n                })),\n                    !record)) {\n                    yield;\n                }\n                this.buffer.consume(usedBytes);\n            }\n            switch (record.type) {\n                case \"Unknown\":\n                    break;\n                case \"Header\":\n                    if (header) {\n                        throw new Error(`Duplicate Header record: library=${header.library} profile=${header.profile} vs. library=${record.library} profile=${record.profile}`);\n                    }\n                    header = record;\n                    yield record;\n                    break;\n                case \"Schema\":\n                case \"Channel\":\n                case \"Message\":\n                case \"MessageIndex\":\n                case \"ChunkIndex\":\n                case \"Attachment\":\n                case \"AttachmentIndex\":\n                case \"Statistics\":\n                case \"Metadata\":\n                case \"MetadataIndex\":\n                case \"SummaryOffset\":\n                case \"DataEnd\":\n                    yield record;\n                    break;\n                case \"Chunk\": {\n                    if (this.includeChunks) {\n                        yield record;\n                    }\n                    let buffer = record.records;\n                    if (record.compression !== \"\" && buffer.byteLength > 0) {\n                        const decompress = this.decompressHandlers[record.compression];\n                        if (!decompress) {\n                            throw errorWithLibrary(`Unsupported compression ${record.compression}`);\n                        }\n                        buffer = decompress(buffer, record.uncompressedSize);\n                    }\n                    if (this.validateCrcs && record.uncompressedCrc !== 0) {\n                        const chunkCrc = crc32(buffer);\n                        if (chunkCrc !== record.uncompressedCrc) {\n                            throw errorWithLibrary(`Incorrect chunk CRC ${chunkCrc} (expected ${record.uncompressedCrc})`);\n                        }\n                    }\n                    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n                    let chunkOffset = 0;\n                    for (let chunkResult; (chunkResult = parseRecord({\n                        view,\n                        startOffset: chunkOffset,\n                        validateCrcs: this.validateCrcs,\n                    })),\n                        chunkResult.record; chunkOffset += chunkResult.usedBytes) {\n                        switch (chunkResult.record.type) {\n                            case \"Unknown\":\n                                break;\n                            case \"Header\":\n                            case \"Footer\":\n                            case \"Chunk\":\n                            case \"MessageIndex\":\n                            case \"ChunkIndex\":\n                            case \"Attachment\":\n                            case \"AttachmentIndex\":\n                            case \"Statistics\":\n                            case \"Metadata\":\n                            case \"MetadataIndex\":\n                            case \"SummaryOffset\":\n                            case \"DataEnd\":\n                                throw errorWithLibrary(`${chunkResult.record.type} record not allowed inside a chunk`);\n                            case \"Schema\":\n                            case \"Channel\":\n                            case \"Message\":\n                                yield chunkResult.record;\n                                break;\n                        }\n                    }\n                    if (chunkOffset !== buffer.byteLength) {\n                        throw errorWithLibrary(`${buffer.byteLength - chunkOffset} bytes remaining in chunk`);\n                    }\n                    break;\n                }\n                case \"Footer\":\n                    try {\n                        let magic, usedBytes;\n                        while ((({ magic, usedBytes } = parseMagic(this.buffer.view, 0)), !magic)) {\n                            yield;\n                        }\n                        this.buffer.consume(usedBytes);\n                    }\n                    catch (error) {\n                        throw errorWithLibrary(error.message);\n                    }\n                    if (this.buffer.bytesRemaining() !== 0) {\n                        throw errorWithLibrary(`${this.buffer.bytesRemaining()} bytes remaining after MCAP footer and trailing magic`);\n                    }\n                    return record;\n            }\n        }\n    }\n}\nfunction isChannelEqual(a, b) {\n    if (!(a.id === b.id &&\n        a.messageEncoding === b.messageEncoding &&\n        a.schemaId === b.schemaId &&\n        a.topic === b.topic &&\n        a.metadata.size === b.metadata.size)) {\n        return false;\n    }\n    for (const [keyA, valueA] of a.metadata.entries()) {\n        const valueB = b.metadata.get(keyA);\n        if (valueA !== valueB) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=McapStreamReader.js.map","import { crc32 } from \"@foxglove/crc\";\nimport { BufferBuilder } from \"./BufferBuilder\";\nimport { MCAP_MAGIC, Opcode } from \"./constants\";\n/**\n * McapRecordBuilder provides methods to serialize mcap records to a buffer in memory.\n *\n * It makes no effort to ensure spec compatibility on the order of records, this is the responsibility\n * of the caller.\n *\n * You'll likely want to use one of the higher level writer interfaces unless you are building your\n * own higher level writing interface.\n */\nexport class McapRecordBuilder {\n    constructor(options) {\n        this.options = options;\n        this.bufferBuilder = new BufferBuilder();\n    }\n    get length() {\n        return this.bufferBuilder.length;\n    }\n    get buffer() {\n        return this.bufferBuilder.buffer;\n    }\n    reset() {\n        this.bufferBuilder.reset();\n    }\n    writeMagic() {\n        this.bufferBuilder.bytes(new Uint8Array(MCAP_MAGIC));\n    }\n    writeHeader(header) {\n        this.bufferBuilder.uint8(Opcode.HEADER);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .string(header.profile)\n            .string(header.library);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeFooter(footer) {\n        this.bufferBuilder\n            .uint8(Opcode.FOOTER)\n            .uint64(20n) // footer is fixed length\n            .uint64(footer.summaryStart)\n            .uint64(footer.summaryOffsetStart)\n            .uint32(footer.summaryCrc);\n        // footer record cannot be padded\n        return 20n;\n    }\n    writeSchema(schema) {\n        this.bufferBuilder.uint8(Opcode.SCHEMA);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint16(schema.id)\n            .string(schema.name)\n            .string(schema.encoding)\n            .uint32(schema.data.byteLength)\n            .bytes(schema.data);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeChannel(info) {\n        this.bufferBuilder.uint8(Opcode.CHANNEL);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint16(info.id)\n            .uint16(info.schemaId)\n            .string(info.topic)\n            .string(info.messageEncoding)\n            .tupleArray((key) => this.bufferBuilder.string(key), (value) => this.bufferBuilder.string(value), info.metadata);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeMessage(message) {\n        this.bufferBuilder.uint8(Opcode.MESSAGE);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint16(message.channelId)\n            .uint32(message.sequence)\n            .uint64(message.logTime)\n            .uint64(message.publishTime)\n            .bytes(message.data);\n        // message record cannot be padded\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n    }\n    writeAttachment(attachment) {\n        this.bufferBuilder.uint8(Opcode.ATTACHMENT);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder.uint64(0n); // placeholder\n        const crcStartPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(attachment.logTime)\n            .uint64(attachment.createTime)\n            .string(attachment.name)\n            .string(attachment.mediaType)\n            .uint64(BigInt(attachment.data.byteLength))\n            .bytes(attachment.data);\n        this.bufferBuilder.uint32(crc32(this.bufferBuilder.bufferView(crcStartPosition, this.bufferBuilder.length - crcStartPosition)));\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeAttachmentIndex(attachmentIndex) {\n        this.bufferBuilder.uint8(Opcode.ATTACHMENT_INDEX);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint64(attachmentIndex.offset)\n            .uint64(attachmentIndex.length)\n            .uint64(attachmentIndex.logTime)\n            .uint64(attachmentIndex.createTime)\n            .uint64(attachmentIndex.dataSize)\n            .string(attachmentIndex.name)\n            .string(attachmentIndex.mediaType);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeChunk(chunk) {\n        this.bufferBuilder.uint8(Opcode.CHUNK);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint64(chunk.messageStartTime)\n            .uint64(chunk.messageEndTime)\n            .uint64(chunk.uncompressedSize)\n            .uint32(chunk.uncompressedCrc)\n            .string(chunk.compression)\n            .uint64(BigInt(chunk.records.byteLength))\n            .bytes(chunk.records);\n        // chunk record cannot be padded\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeChunkIndex(chunkIndex) {\n        this.bufferBuilder.uint8(Opcode.CHUNK_INDEX);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint64(chunkIndex.messageStartTime)\n            .uint64(chunkIndex.messageEndTime)\n            .uint64(chunkIndex.chunkStartOffset)\n            .uint64(chunkIndex.chunkLength)\n            .uint32(chunkIndex.messageIndexOffsets.size * 10);\n        for (const [channelId, offset] of chunkIndex.messageIndexOffsets) {\n            this.bufferBuilder.uint16(channelId).uint64(offset);\n        }\n        this.bufferBuilder\n            .uint64(chunkIndex.messageIndexLength)\n            .string(chunkIndex.compression)\n            .uint64(chunkIndex.compressedSize)\n            .uint64(chunkIndex.uncompressedSize);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeMessageIndex(messageIndex) {\n        this.bufferBuilder.uint8(Opcode.MESSAGE_INDEX);\n        const startPosition = this.bufferBuilder.length;\n        // each records tuple is a fixed byte length\n        const messageIndexRecordsByteLength = messageIndex.records.length * 16;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint16(messageIndex.channelId)\n            .uint32(messageIndexRecordsByteLength);\n        for (const record of messageIndex.records) {\n            this.bufferBuilder.uint64(record[0]).uint64(record[1]);\n        }\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeMetadata(metadata) {\n        this.bufferBuilder.uint8(Opcode.METADATA);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .string(metadata.name)\n            .tupleArray((key) => this.bufferBuilder.string(key), (value) => this.bufferBuilder.string(value), metadata.metadata);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeMetadataIndex(metadataIndex) {\n        this.bufferBuilder.uint8(Opcode.METADATA_INDEX);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .uint64(metadataIndex.offset)\n            .uint64(metadataIndex.length)\n            .string(metadataIndex.name);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeSummaryOffset(summaryOffset) {\n        this.bufferBuilder.uint8(Opcode.SUMMARY_OFFSET);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .uint8(summaryOffset.groupOpcode)\n            .uint64(summaryOffset.groupStart)\n            .uint64(summaryOffset.groupLength);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeStatistics(statistics) {\n        this.bufferBuilder.uint8(Opcode.STATISTICS);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .uint64(statistics.messageCount)\n            .uint16(statistics.schemaCount)\n            .uint32(statistics.channelCount)\n            .uint32(statistics.attachmentCount)\n            .uint32(statistics.metadataCount)\n            .uint32(statistics.chunkCount)\n            .uint64(statistics.messageStartTime)\n            .uint64(statistics.messageEndTime)\n            .tupleArray((key) => this.bufferBuilder.uint16(key), (value) => this.bufferBuilder.uint64(value), statistics.channelMessageCounts);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeDataEnd(dataEnd) {\n        this.bufferBuilder.uint8(Opcode.DATA_END);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .uint32(dataEnd.dataSectionCrc);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n}\n//# sourceMappingURL=McapRecordBuilder.js.map","import { McapRecordBuilder } from \"./McapRecordBuilder\";\nclass ChunkBuilder {\n    constructor({ useMessageIndex = true }) {\n        this.recordWriter = new McapRecordBuilder();\n        this.totalMessageCount = 0;\n        this.messageStartTime = 0n;\n        this.messageEndTime = 0n;\n        if (useMessageIndex) {\n            this.messageIndices = new Map();\n        }\n    }\n    get numMessages() {\n        return this.totalMessageCount;\n    }\n    get buffer() {\n        return this.recordWriter.buffer;\n    }\n    get byteLength() {\n        return this.recordWriter.length;\n    }\n    get indices() {\n        if (this.messageIndices) {\n            return this.messageIndices.values();\n        }\n        return [];\n    }\n    addSchema(schema) {\n        this.recordWriter.writeSchema(schema);\n    }\n    addChannel(info) {\n        if (this.messageIndices && !this.messageIndices.has(info.id)) {\n            this.messageIndices.set(info.id, {\n                channelId: info.id,\n                records: [],\n            });\n        }\n        this.recordWriter.writeChannel(info);\n    }\n    addMessage(message) {\n        if (this.totalMessageCount === 0 || message.logTime < this.messageStartTime) {\n            this.messageStartTime = message.logTime;\n        }\n        if (this.totalMessageCount === 0 || message.logTime > this.messageEndTime) {\n            this.messageEndTime = message.logTime;\n        }\n        if (this.messageIndices) {\n            let messageIndex = this.messageIndices.get(message.channelId);\n            if (!messageIndex) {\n                messageIndex = {\n                    channelId: message.channelId,\n                    records: [],\n                };\n                this.messageIndices.set(message.channelId, messageIndex);\n            }\n            messageIndex.records.push([message.logTime, BigInt(this.recordWriter.length)]);\n        }\n        this.totalMessageCount += 1;\n        this.recordWriter.writeMessage(message);\n    }\n    reset() {\n        this.messageStartTime = 0n;\n        this.messageEndTime = 0n;\n        this.totalMessageCount = 0;\n        this.messageIndices?.clear();\n        this.recordWriter.reset();\n    }\n}\nexport { ChunkBuilder };\n//# sourceMappingURL=ChunkBuilder.js.map","import { crc32Init, crc32Update, crc32Final, crc32 } from \"@foxglove/crc\";\nimport { ChunkBuilder } from \"./ChunkBuilder\";\nimport { McapRecordBuilder } from \"./McapRecordBuilder\";\nimport { Opcode } from \"./constants\";\n/**\n * McapWriter provides an interface for writing messages to MCAP files.\n *\n * NOTE: callers must wait on any method call to complete before calling another\n * method. Calling a method before another has completed will result in a corrupt\n * MCAP file.\n */\nexport class McapWriter {\n    constructor(options) {\n        this.nextChannelId = 0;\n        this.nextSchemaId = 1;\n        this.recordWriter = new McapRecordBuilder();\n        this.schemas = new Map();\n        this.channels = new Map();\n        this.writtenSchemaIds = new Set();\n        this.writtenChannelIds = new Set();\n        this.dataSectionCrc = crc32Init();\n        const { writable, useStatistics = true, useSummaryOffsets = true, useChunks = true, repeatSchemas = true, repeatChannels = true, useAttachmentIndex = true, useMetadataIndex = true, useMessageIndex = true, useChunkIndex = true, startChannelId = 0, chunkSize = 1024 * 1024, compressChunk, } = options;\n        this.writable = writable;\n        this.useSummaryOffsets = useSummaryOffsets;\n        if (useStatistics) {\n            this.statistics = {\n                messageCount: 0n,\n                schemaCount: 0,\n                channelCount: 0,\n                attachmentCount: 0,\n                metadataCount: 0,\n                chunkCount: 0,\n                messageStartTime: 0n,\n                messageEndTime: 0n,\n                channelMessageCounts: new Map(),\n            };\n        }\n        if (useChunks) {\n            this.chunkBuilder = new ChunkBuilder({ useMessageIndex });\n        }\n        this.repeatSchemas = repeatSchemas;\n        this.repeatChannels = repeatChannels;\n        if (useAttachmentIndex) {\n            this.attachmentIndices = [];\n        }\n        if (useMetadataIndex) {\n            this.metadataIndices = [];\n        }\n        if (useChunkIndex) {\n            this.chunkIndices = [];\n        }\n        this.nextChannelId = startChannelId;\n        this.chunkSize = chunkSize;\n        this.compressChunk = compressChunk;\n    }\n    async start(header) {\n        this.recordWriter.writeMagic();\n        this.recordWriter.writeHeader(header);\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n    }\n    async end() {\n        await this.finalizeChunk();\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n        this.recordWriter.writeDataEnd({ dataSectionCrc: crc32Final(this.dataSectionCrc) });\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n        const summaryOffsets = [];\n        const summaryStart = this.writable.position();\n        let summaryCrc = crc32Init();\n        if (this.repeatSchemas) {\n            const schemaStart = this.writable.position();\n            let schemaLength = 0n;\n            for (const schema of this.schemas.values()) {\n                schemaLength += this.recordWriter.writeSchema(schema);\n            }\n            summaryOffsets.push({\n                groupOpcode: Opcode.SCHEMA,\n                groupStart: schemaStart,\n                groupLength: schemaLength,\n            });\n        }\n        if (this.repeatChannels) {\n            summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n            await this.writable.write(this.recordWriter.buffer);\n            this.recordWriter.reset();\n            const channelStart = this.writable.position();\n            let channelLength = 0n;\n            for (const channel of this.channels.values()) {\n                channelLength += this.recordWriter.writeChannel(channel);\n            }\n            summaryOffsets.push({\n                groupOpcode: Opcode.CHANNEL,\n                groupStart: channelStart,\n                groupLength: channelLength,\n            });\n        }\n        if (this.statistics) {\n            summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n            await this.writable.write(this.recordWriter.buffer);\n            this.recordWriter.reset();\n            const statisticsStart = this.writable.position();\n            const statisticsLength = this.recordWriter.writeStatistics(this.statistics);\n            summaryOffsets.push({\n                groupOpcode: Opcode.STATISTICS,\n                groupStart: statisticsStart,\n                groupLength: statisticsLength,\n            });\n        }\n        summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n        if (this.metadataIndices) {\n            summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n            await this.writable.write(this.recordWriter.buffer);\n            this.recordWriter.reset();\n            const metadataIndexStart = this.writable.position();\n            let metadataIndexLength = 0n;\n            for (const metadataIndex of this.metadataIndices) {\n                metadataIndexLength += this.recordWriter.writeMetadataIndex(metadataIndex);\n            }\n            summaryOffsets.push({\n                groupOpcode: Opcode.METADATA_INDEX,\n                groupStart: metadataIndexStart,\n                groupLength: metadataIndexLength,\n            });\n        }\n        if (this.attachmentIndices) {\n            summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n            await this.writable.write(this.recordWriter.buffer);\n            this.recordWriter.reset();\n            const attachmentIndexStart = this.writable.position();\n            let attachmentIndexLength = 0n;\n            for (const attachmentIndex of this.attachmentIndices) {\n                attachmentIndexLength += this.recordWriter.writeAttachmentIndex(attachmentIndex);\n            }\n            summaryOffsets.push({\n                groupOpcode: Opcode.ATTACHMENT_INDEX,\n                groupStart: attachmentIndexStart,\n                groupLength: attachmentIndexLength,\n            });\n        }\n        if (this.chunkIndices) {\n            summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n            await this.writable.write(this.recordWriter.buffer);\n            this.recordWriter.reset();\n            const chunkIndexStart = this.writable.position();\n            let chunkIndexLength = 0n;\n            for (const chunkIndex of this.chunkIndices) {\n                chunkIndexLength += this.recordWriter.writeChunkIndex(chunkIndex);\n            }\n            summaryOffsets.push({\n                groupOpcode: Opcode.CHUNK_INDEX,\n                groupStart: chunkIndexStart,\n                groupLength: chunkIndexLength,\n            });\n        }\n        summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n        const summaryOffsetStart = this.writable.position();\n        const summaryLength = summaryOffsetStart - summaryStart;\n        if (this.useSummaryOffsets) {\n            for (const summaryOffset of summaryOffsets) {\n                if (summaryOffset.groupLength !== 0n) {\n                    this.recordWriter.writeSummaryOffset(summaryOffset);\n                }\n            }\n        }\n        summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n        const footer = {\n            summaryStart: summaryLength === 0n ? 0n : summaryStart,\n            summaryOffsetStart: this.useSummaryOffsets ? summaryOffsetStart : 0n,\n            summaryCrc: 0,\n        };\n        const tempBuffer = new DataView(new ArrayBuffer(1 + 8 + 8 + 8));\n        tempBuffer.setUint8(0, Opcode.FOOTER);\n        tempBuffer.setBigUint64(1, 8n + 8n + 4n, true);\n        tempBuffer.setBigUint64(1 + 8, footer.summaryStart, true);\n        tempBuffer.setBigUint64(1 + 8 + 8, footer.summaryOffsetStart, true);\n        summaryCrc = crc32Update(summaryCrc, tempBuffer);\n        footer.summaryCrc = crc32Final(summaryCrc);\n        this.recordWriter.writeFooter(footer);\n        this.recordWriter.writeMagic();\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n    }\n    /**\n     * Add a schema and return a generated schema id. The schema id is used when adding channels.\n     */\n    async registerSchema(info) {\n        const id = this.nextSchemaId++;\n        this.schemas.set(id, { ...info, id });\n        if (this.statistics) {\n            ++this.statistics.schemaCount;\n        }\n        return id;\n    }\n    /**\n     * Add a channel and return a generated channel id. The channel id is used when adding messages.\n     */\n    async registerChannel(info) {\n        const id = this.nextChannelId++;\n        this.channels.set(id, { ...info, id });\n        if (this.statistics) {\n            ++this.statistics.channelCount;\n        }\n        return id;\n    }\n    async addMessage(message) {\n        if (this.statistics) {\n            if (this.statistics.messageCount === 0n) {\n                this.statistics.messageStartTime = message.logTime;\n                this.statistics.messageEndTime = message.logTime;\n            }\n            else {\n                if (message.logTime < this.statistics.messageStartTime) {\n                    this.statistics.messageStartTime = message.logTime;\n                }\n                if (message.logTime > this.statistics.messageEndTime) {\n                    this.statistics.messageEndTime = message.logTime;\n                }\n            }\n            this.statistics.channelMessageCounts.set(message.channelId, (this.statistics.channelMessageCounts.get(message.channelId) ?? 0n) + 1n);\n            ++this.statistics.messageCount;\n        }\n        // write out channel and schema if we have not yet done so\n        if (!this.writtenChannelIds.has(message.channelId)) {\n            const channel = this.channels.get(message.channelId);\n            if (!channel) {\n                throw new Error(`McapWriter#addMessage failed: missing channel for id ${message.channelId}`);\n            }\n            if (channel.schemaId !== 0 && !this.writtenSchemaIds.has(channel.schemaId)) {\n                const schema = this.schemas.get(channel.schemaId);\n                if (!schema) {\n                    throw new Error(`McapWriter#addMessage failed: missing schema for id ${channel.schemaId}`);\n                }\n                if (this.chunkBuilder) {\n                    this.chunkBuilder.addSchema(schema);\n                }\n                else {\n                    this.recordWriter.writeSchema(schema);\n                }\n                this.writtenSchemaIds.add(channel.schemaId);\n            }\n            if (this.chunkBuilder) {\n                this.chunkBuilder.addChannel(channel);\n            }\n            else {\n                this.recordWriter.writeChannel(channel);\n            }\n            this.writtenChannelIds.add(message.channelId);\n        }\n        if (this.chunkBuilder) {\n            this.chunkBuilder.addMessage(message);\n        }\n        else {\n            this.recordWriter.writeMessage(message);\n        }\n        if (this.chunkBuilder && this.chunkBuilder.byteLength > this.chunkSize) {\n            await this.finalizeChunk();\n        }\n    }\n    async addAttachment(attachment) {\n        const length = this.recordWriter.writeAttachment(attachment);\n        if (this.statistics) {\n            ++this.statistics.attachmentCount;\n        }\n        if (this.attachmentIndices) {\n            const offset = this.writable.position();\n            this.attachmentIndices.push({\n                logTime: attachment.logTime,\n                createTime: attachment.createTime,\n                name: attachment.name,\n                mediaType: attachment.mediaType,\n                offset,\n                dataSize: BigInt(attachment.data.byteLength),\n                length,\n            });\n        }\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n    }\n    async addMetadata(metadata) {\n        const recordSize = this.recordWriter.writeMetadata(metadata);\n        if (this.statistics) {\n            ++this.statistics.metadataCount;\n        }\n        if (this.metadataIndices) {\n            const offset = this.writable.position();\n            this.metadataIndices.push({\n                name: metadata.name,\n                offset,\n                length: recordSize,\n            });\n        }\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n    }\n    async finalizeChunk() {\n        if (!this.chunkBuilder || this.chunkBuilder.numMessages === 0) {\n            return;\n        }\n        if (this.statistics) {\n            ++this.statistics.chunkCount;\n        }\n        const chunkData = this.chunkBuilder.buffer;\n        const uncompressedSize = BigInt(chunkData.length);\n        const uncompressedCrc = crc32(chunkData);\n        let compression = \"\";\n        let compressedData = chunkData;\n        if (this.compressChunk) {\n            ({ compression, compressedData } = this.compressChunk(chunkData));\n        }\n        const chunkRecord = {\n            messageStartTime: this.chunkBuilder.messageStartTime,\n            messageEndTime: this.chunkBuilder.messageEndTime,\n            uncompressedSize,\n            uncompressedCrc,\n            compression,\n            records: compressedData,\n        };\n        const chunkStartOffset = this.writable.position();\n        const chunkLength = this.recordWriter.writeChunk(chunkRecord);\n        const messageIndexOffsets = this.chunkIndices ? new Map() : undefined;\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n        const messageIndexStart = this.writable.position();\n        let messageIndexLength = 0n;\n        for (const messageIndex of this.chunkBuilder.indices) {\n            messageIndexOffsets?.set(messageIndex.channelId, messageIndexStart + messageIndexLength);\n            messageIndexLength += this.recordWriter.writeMessageIndex(messageIndex);\n        }\n        if (this.chunkIndices) {\n            this.chunkIndices.push({\n                messageStartTime: chunkRecord.messageStartTime,\n                messageEndTime: chunkRecord.messageEndTime,\n                chunkStartOffset,\n                chunkLength,\n                messageIndexOffsets: messageIndexOffsets,\n                messageIndexLength,\n                compression: chunkRecord.compression,\n                compressedSize: BigInt(chunkRecord.records.byteLength),\n                uncompressedSize: chunkRecord.uncompressedSize,\n            });\n        }\n        this.chunkBuilder.reset();\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n    }\n}\n//# sourceMappingURL=McapWriter.js.map","import { MCAP_MAGIC } from \"./constants\";\n/** Check if the given buffer starts with the MCAP magic prefix. */\nexport function hasMcapPrefix(prefix) {\n    return (prefix.byteLength >= MCAP_MAGIC.length &&\n        MCAP_MAGIC.every((val, i) => val === prefix.getUint8(i)));\n}\n//# sourceMappingURL=hasMcapPrefix.js.map","/* eslint-disable */\n// This is a generated file, generated using the flatc flatbuffer\n// compiler.\nimport * as flatbuffers from 'flatbuffers';\n// @ts-ignore\nimport { BaseType as reflectionBaseType, Enum as reflectionEnum, EnumVal as reflectionEnumVal, Field as reflectionField, KeyValue as reflectionKeyValue, Object_ as reflectionObject, RPCCall as reflectionRPCCall, Schema as reflectionSchema, SchemaFile as reflectionSchemaFile, Service as reflectionService, Type as reflectionType } from './reflection_generated';\nexport var BaseType;\n(function (BaseType) {\n    BaseType[BaseType[\"None\"] = 0] = \"None\";\n    BaseType[BaseType[\"UType\"] = 1] = \"UType\";\n    BaseType[BaseType[\"Bool\"] = 2] = \"Bool\";\n    BaseType[BaseType[\"Byte\"] = 3] = \"Byte\";\n    BaseType[BaseType[\"UByte\"] = 4] = \"UByte\";\n    BaseType[BaseType[\"Short\"] = 5] = \"Short\";\n    BaseType[BaseType[\"UShort\"] = 6] = \"UShort\";\n    BaseType[BaseType[\"Int\"] = 7] = \"Int\";\n    BaseType[BaseType[\"UInt\"] = 8] = \"UInt\";\n    BaseType[BaseType[\"Long\"] = 9] = \"Long\";\n    BaseType[BaseType[\"ULong\"] = 10] = \"ULong\";\n    BaseType[BaseType[\"Float\"] = 11] = \"Float\";\n    BaseType[BaseType[\"Double\"] = 12] = \"Double\";\n    BaseType[BaseType[\"String\"] = 13] = \"String\";\n    BaseType[BaseType[\"Vector\"] = 14] = \"Vector\";\n    BaseType[BaseType[\"Obj\"] = 15] = \"Obj\";\n    BaseType[BaseType[\"Union\"] = 16] = \"Union\";\n    BaseType[BaseType[\"Array\"] = 17] = \"Array\";\n    BaseType[BaseType[\"MaxBaseType\"] = 18] = \"MaxBaseType\";\n})(BaseType || (BaseType = {}));\n/**\n * New schema language features that are not supported by old code generators.\n */\n// ts-prune-ignore-next\nexport var AdvancedFeatures;\n(function (AdvancedFeatures) {\n    AdvancedFeatures[\"AdvancedArrayFeatures\"] = \"1\";\n    AdvancedFeatures[\"AdvancedUnionFeatures\"] = \"2\";\n    AdvancedFeatures[\"OptionalScalars\"] = \"4\";\n    AdvancedFeatures[\"DefaultVectorsAndStrings\"] = \"8\";\n})(AdvancedFeatures || (AdvancedFeatures = {}));\nexport class Type {\n    bb = null;\n    bb_pos = 0;\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsType(bb, obj) {\n        return (obj || new Type()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsType(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Type()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    baseType() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt8(this.bb_pos + offset) : reflectionBaseType.None;\n    }\n    mutate_base_type(value) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt8(this.bb_pos + offset, value);\n        return true;\n    }\n    element() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.readInt8(this.bb_pos + offset) : reflectionBaseType.None;\n    }\n    mutate_element(value) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt8(this.bb_pos + offset, value);\n        return true;\n    }\n    index() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? this.bb.readInt32(this.bb_pos + offset) : -1;\n    }\n    mutate_index(value) {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt32(this.bb_pos + offset, value);\n        return true;\n    }\n    fixedLength() {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;\n    }\n    mutate_fixed_length(value) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeUint16(this.bb_pos + offset, value);\n        return true;\n    }\n    /**\n     * The size (octets) of the `base_type` field.\n     */\n    baseSize() {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? this.bb.readUint32(this.bb_pos + offset) : 4;\n    }\n    mutate_base_size(value) {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeUint32(this.bb_pos + offset, value);\n        return true;\n    }\n    /**\n     * The size (octets) of the `element` field, if present.\n     */\n    elementSize() {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;\n    }\n    mutate_element_size(value) {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeUint32(this.bb_pos + offset, value);\n        return true;\n    }\n    static getFullyQualifiedName() {\n        return 'reflection.Type';\n    }\n    static startType(builder) {\n        builder.startObject(6);\n    }\n    static addBaseType(builder, baseType) {\n        builder.addFieldInt8(0, baseType, reflectionBaseType.None);\n    }\n    static addElement(builder, element) {\n        builder.addFieldInt8(1, element, reflectionBaseType.None);\n    }\n    static addIndex(builder, index) {\n        builder.addFieldInt32(2, index, -1);\n    }\n    static addFixedLength(builder, fixedLength) {\n        builder.addFieldInt16(3, fixedLength, 0);\n    }\n    static addBaseSize(builder, baseSize) {\n        builder.addFieldInt32(4, baseSize, 4);\n    }\n    static addElementSize(builder, elementSize) {\n        builder.addFieldInt32(5, elementSize, 0);\n    }\n    static endType(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createType(builder, baseType, element, index, fixedLength, baseSize, elementSize) {\n        Type.startType(builder);\n        Type.addBaseType(builder, baseType);\n        Type.addElement(builder, element);\n        Type.addIndex(builder, index);\n        Type.addFixedLength(builder, fixedLength);\n        Type.addBaseSize(builder, baseSize);\n        Type.addElementSize(builder, elementSize);\n        return Type.endType(builder);\n    }\n    unpack() {\n        return new TypeT(this.baseType(), this.element(), this.index(), this.fixedLength(), this.baseSize(), this.elementSize());\n    }\n    unpackTo(_o) {\n        _o.baseType = this.baseType();\n        _o.element = this.element();\n        _o.index = this.index();\n        _o.fixedLength = this.fixedLength();\n        _o.baseSize = this.baseSize();\n        _o.elementSize = this.elementSize();\n    }\n}\nexport class TypeT {\n    baseType;\n    element;\n    index;\n    fixedLength;\n    baseSize;\n    elementSize;\n    constructor(baseType = reflectionBaseType.None, element = reflectionBaseType.None, index = -1, fixedLength = 0, baseSize = 4, elementSize = 0) {\n        this.baseType = baseType;\n        this.element = element;\n        this.index = index;\n        this.fixedLength = fixedLength;\n        this.baseSize = baseSize;\n        this.elementSize = elementSize;\n    }\n    pack(builder) {\n        return reflectionType.createType(builder, this.baseType, this.element, this.index, this.fixedLength, this.baseSize, this.elementSize);\n    }\n}\nexport class KeyValue {\n    bb = null;\n    bb_pos = 0;\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsKeyValue(bb, obj) {\n        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsKeyValue(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    key(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    value(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    static getFullyQualifiedName() {\n        return 'reflection.KeyValue';\n    }\n    static startKeyValue(builder) {\n        builder.startObject(2);\n    }\n    static addKey(builder, keyOffset) {\n        builder.addFieldOffset(0, keyOffset, 0);\n    }\n    static addValue(builder, valueOffset) {\n        builder.addFieldOffset(1, valueOffset, 0);\n    }\n    static endKeyValue(builder) {\n        const offset = builder.endObject();\n        builder.requiredField(offset, 4); // key\n        return offset;\n    }\n    static createKeyValue(builder, keyOffset, valueOffset) {\n        KeyValue.startKeyValue(builder);\n        KeyValue.addKey(builder, keyOffset);\n        KeyValue.addValue(builder, valueOffset);\n        return KeyValue.endKeyValue(builder);\n    }\n    unpack() {\n        return new KeyValueT(this.key(), this.value());\n    }\n    unpackTo(_o) {\n        _o.key = this.key();\n        _o.value = this.value();\n    }\n}\nexport class KeyValueT {\n    key;\n    value;\n    constructor(key = null, value = null) {\n        this.key = key;\n        this.value = value;\n    }\n    pack(builder) {\n        const key = (this.key !== null ? builder.createString(this.key) : 0);\n        const value = (this.value !== null ? builder.createString(this.value) : 0);\n        return reflectionKeyValue.createKeyValue(builder, key, value);\n    }\n}\nexport class EnumVal {\n    bb = null;\n    bb_pos = 0;\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsEnumVal(bb, obj) {\n        return (obj || new EnumVal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsEnumVal(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new EnumVal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    name(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    value() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');\n    }\n    mutate_value(value) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt64(this.bb_pos + offset, value);\n        return true;\n    }\n    unionType(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? (obj || new reflectionType()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    documentation(index, optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n    documentationLength() {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    static getFullyQualifiedName() {\n        return 'reflection.EnumVal';\n    }\n    static startEnumVal(builder) {\n        builder.startObject(5);\n    }\n    static addName(builder, nameOffset) {\n        builder.addFieldOffset(0, nameOffset, 0);\n    }\n    static addValue(builder, value) {\n        builder.addFieldInt64(1, value, BigInt('0'));\n    }\n    static addUnionType(builder, unionTypeOffset) {\n        builder.addFieldOffset(3, unionTypeOffset, 0);\n    }\n    static addDocumentation(builder, documentationOffset) {\n        builder.addFieldOffset(4, documentationOffset, 0);\n    }\n    static createDocumentationVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startDocumentationVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static endEnumVal(builder) {\n        const offset = builder.endObject();\n        builder.requiredField(offset, 4); // name\n        return offset;\n    }\n    unpack() {\n        return new EnumValT(this.name(), this.value(), (this.unionType() !== null ? this.unionType().unpack() : null), this.bb.createScalarList(this.documentation.bind(this), this.documentationLength()));\n    }\n    unpackTo(_o) {\n        _o.name = this.name();\n        _o.value = this.value();\n        _o.unionType = (this.unionType() !== null ? this.unionType().unpack() : null);\n        _o.documentation = this.bb.createScalarList(this.documentation.bind(this), this.documentationLength());\n    }\n}\nexport class EnumValT {\n    name;\n    value;\n    unionType;\n    documentation;\n    constructor(name = null, value = BigInt('0'), unionType = null, documentation = []) {\n        this.name = name;\n        this.value = value;\n        this.unionType = unionType;\n        this.documentation = documentation;\n    }\n    pack(builder) {\n        const name = (this.name !== null ? builder.createString(this.name) : 0);\n        const unionType = (this.unionType !== null ? this.unionType.pack(builder) : 0);\n        const documentation = reflectionEnumVal.createDocumentationVector(builder, builder.createObjectOffsetList(this.documentation));\n        reflectionEnumVal.startEnumVal(builder);\n        reflectionEnumVal.addName(builder, name);\n        reflectionEnumVal.addValue(builder, this.value);\n        reflectionEnumVal.addUnionType(builder, unionType);\n        reflectionEnumVal.addDocumentation(builder, documentation);\n        return reflectionEnumVal.endEnumVal(builder);\n    }\n}\nexport class Enum {\n    bb = null;\n    bb_pos = 0;\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsEnum(bb, obj) {\n        return (obj || new Enum()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsEnum(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Enum()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    name(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    values(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? (obj || new reflectionEnumVal()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    valuesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    isUnion() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    mutate_is_union(value) {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt8(this.bb_pos + offset, +value);\n        return true;\n    }\n    underlyingType(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? (obj || new reflectionType()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    attributes(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? (obj || new reflectionKeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    attributesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    documentation(index, optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n    documentationLength() {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    declarationFile(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 16);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    static getFullyQualifiedName() {\n        return 'reflection.Enum';\n    }\n    static startEnum(builder) {\n        builder.startObject(7);\n    }\n    static addName(builder, nameOffset) {\n        builder.addFieldOffset(0, nameOffset, 0);\n    }\n    static addValues(builder, valuesOffset) {\n        builder.addFieldOffset(1, valuesOffset, 0);\n    }\n    static createValuesVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startValuesVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addIsUnion(builder, isUnion) {\n        builder.addFieldInt8(2, +isUnion, +false);\n    }\n    static addUnderlyingType(builder, underlyingTypeOffset) {\n        builder.addFieldOffset(3, underlyingTypeOffset, 0);\n    }\n    static addAttributes(builder, attributesOffset) {\n        builder.addFieldOffset(4, attributesOffset, 0);\n    }\n    static createAttributesVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startAttributesVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addDocumentation(builder, documentationOffset) {\n        builder.addFieldOffset(5, documentationOffset, 0);\n    }\n    static createDocumentationVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startDocumentationVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addDeclarationFile(builder, declarationFileOffset) {\n        builder.addFieldOffset(6, declarationFileOffset, 0);\n    }\n    static endEnum(builder) {\n        const offset = builder.endObject();\n        builder.requiredField(offset, 4); // name\n        builder.requiredField(offset, 6); // values\n        builder.requiredField(offset, 10); // underlying_type\n        return offset;\n    }\n    unpack() {\n        return new EnumT(this.name(), this.bb.createObjList(this.values.bind(this), this.valuesLength()), this.isUnion(), (this.underlyingType() !== null ? this.underlyingType().unpack() : null), this.bb.createObjList(this.attributes.bind(this), this.attributesLength()), this.bb.createScalarList(this.documentation.bind(this), this.documentationLength()), this.declarationFile());\n    }\n    unpackTo(_o) {\n        _o.name = this.name();\n        _o.values = this.bb.createObjList(this.values.bind(this), this.valuesLength());\n        _o.isUnion = this.isUnion();\n        _o.underlyingType = (this.underlyingType() !== null ? this.underlyingType().unpack() : null);\n        _o.attributes = this.bb.createObjList(this.attributes.bind(this), this.attributesLength());\n        _o.documentation = this.bb.createScalarList(this.documentation.bind(this), this.documentationLength());\n        _o.declarationFile = this.declarationFile();\n    }\n}\nexport class EnumT {\n    name;\n    values;\n    isUnion;\n    underlyingType;\n    attributes;\n    documentation;\n    declarationFile;\n    constructor(name = null, values = [], isUnion = false, underlyingType = null, attributes = [], documentation = [], declarationFile = null) {\n        this.name = name;\n        this.values = values;\n        this.isUnion = isUnion;\n        this.underlyingType = underlyingType;\n        this.attributes = attributes;\n        this.documentation = documentation;\n        this.declarationFile = declarationFile;\n    }\n    pack(builder) {\n        const name = (this.name !== null ? builder.createString(this.name) : 0);\n        const values = reflectionEnum.createValuesVector(builder, builder.createObjectOffsetList(this.values));\n        const underlyingType = (this.underlyingType !== null ? this.underlyingType.pack(builder) : 0);\n        const attributes = reflectionEnum.createAttributesVector(builder, builder.createObjectOffsetList(this.attributes));\n        const documentation = reflectionEnum.createDocumentationVector(builder, builder.createObjectOffsetList(this.documentation));\n        const declarationFile = (this.declarationFile !== null ? builder.createString(this.declarationFile) : 0);\n        reflectionEnum.startEnum(builder);\n        reflectionEnum.addName(builder, name);\n        reflectionEnum.addValues(builder, values);\n        reflectionEnum.addIsUnion(builder, this.isUnion);\n        reflectionEnum.addUnderlyingType(builder, underlyingType);\n        reflectionEnum.addAttributes(builder, attributes);\n        reflectionEnum.addDocumentation(builder, documentation);\n        reflectionEnum.addDeclarationFile(builder, declarationFile);\n        return reflectionEnum.endEnum(builder);\n    }\n}\nexport class Field {\n    bb = null;\n    bb_pos = 0;\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsField(bb, obj) {\n        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsField(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    name(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    type(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? (obj || new reflectionType()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    id() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;\n    }\n    mutate_id(value) {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeUint16(this.bb_pos + offset, value);\n        return true;\n    }\n    offset() {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;\n    }\n    mutate_offset(value) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeUint16(this.bb_pos + offset, value);\n        return true;\n    }\n    defaultInteger() {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');\n    }\n    mutate_default_integer(value) {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt64(this.bb_pos + offset, value);\n        return true;\n    }\n    defaultReal() {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;\n    }\n    mutate_default_real(value) {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeFloat64(this.bb_pos + offset, value);\n        return true;\n    }\n    deprecated() {\n        const offset = this.bb.__offset(this.bb_pos, 16);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    mutate_deprecated(value) {\n        const offset = this.bb.__offset(this.bb_pos, 16);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt8(this.bb_pos + offset, +value);\n        return true;\n    }\n    required() {\n        const offset = this.bb.__offset(this.bb_pos, 18);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    mutate_required(value) {\n        const offset = this.bb.__offset(this.bb_pos, 18);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt8(this.bb_pos + offset, +value);\n        return true;\n    }\n    key() {\n        const offset = this.bb.__offset(this.bb_pos, 20);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    mutate_key(value) {\n        const offset = this.bb.__offset(this.bb_pos, 20);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt8(this.bb_pos + offset, +value);\n        return true;\n    }\n    attributes(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 22);\n        return offset ? (obj || new reflectionKeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    attributesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 22);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    documentation(index, optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 24);\n        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n    documentationLength() {\n        const offset = this.bb.__offset(this.bb_pos, 24);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    optional() {\n        const offset = this.bb.__offset(this.bb_pos, 26);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    mutate_optional(value) {\n        const offset = this.bb.__offset(this.bb_pos, 26);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt8(this.bb_pos + offset, +value);\n        return true;\n    }\n    /**\n     * Number of padding octets to always add after this field. Structs only.\n     */\n    padding() {\n        const offset = this.bb.__offset(this.bb_pos, 28);\n        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;\n    }\n    mutate_padding(value) {\n        const offset = this.bb.__offset(this.bb_pos, 28);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeUint16(this.bb_pos + offset, value);\n        return true;\n    }\n    static getFullyQualifiedName() {\n        return 'reflection.Field';\n    }\n    static startField(builder) {\n        builder.startObject(13);\n    }\n    static addName(builder, nameOffset) {\n        builder.addFieldOffset(0, nameOffset, 0);\n    }\n    static addType(builder, typeOffset) {\n        builder.addFieldOffset(1, typeOffset, 0);\n    }\n    static addId(builder, id) {\n        builder.addFieldInt16(2, id, 0);\n    }\n    static addOffset(builder, offset) {\n        builder.addFieldInt16(3, offset, 0);\n    }\n    static addDefaultInteger(builder, defaultInteger) {\n        builder.addFieldInt64(4, defaultInteger, BigInt('0'));\n    }\n    static addDefaultReal(builder, defaultReal) {\n        builder.addFieldFloat64(5, defaultReal, 0.0);\n    }\n    static addDeprecated(builder, deprecated) {\n        builder.addFieldInt8(6, +deprecated, +false);\n    }\n    static addRequired(builder, required) {\n        builder.addFieldInt8(7, +required, +false);\n    }\n    static addKey(builder, key) {\n        builder.addFieldInt8(8, +key, +false);\n    }\n    static addAttributes(builder, attributesOffset) {\n        builder.addFieldOffset(9, attributesOffset, 0);\n    }\n    static createAttributesVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startAttributesVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addDocumentation(builder, documentationOffset) {\n        builder.addFieldOffset(10, documentationOffset, 0);\n    }\n    static createDocumentationVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startDocumentationVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addOptional(builder, optional) {\n        builder.addFieldInt8(11, +optional, +false);\n    }\n    static addPadding(builder, padding) {\n        builder.addFieldInt16(12, padding, 0);\n    }\n    static endField(builder) {\n        const offset = builder.endObject();\n        builder.requiredField(offset, 4); // name\n        builder.requiredField(offset, 6); // type\n        return offset;\n    }\n    unpack() {\n        return new FieldT(this.name(), (this.type() !== null ? this.type().unpack() : null), this.id(), this.offset(), this.defaultInteger(), this.defaultReal(), this.deprecated(), this.required(), this.key(), this.bb.createObjList(this.attributes.bind(this), this.attributesLength()), this.bb.createScalarList(this.documentation.bind(this), this.documentationLength()), this.optional(), this.padding());\n    }\n    unpackTo(_o) {\n        _o.name = this.name();\n        _o.type = (this.type() !== null ? this.type().unpack() : null);\n        _o.id = this.id();\n        _o.offset = this.offset();\n        _o.defaultInteger = this.defaultInteger();\n        _o.defaultReal = this.defaultReal();\n        _o.deprecated = this.deprecated();\n        _o.required = this.required();\n        _o.key = this.key();\n        _o.attributes = this.bb.createObjList(this.attributes.bind(this), this.attributesLength());\n        _o.documentation = this.bb.createScalarList(this.documentation.bind(this), this.documentationLength());\n        _o.optional = this.optional();\n        _o.padding = this.padding();\n    }\n}\nexport class FieldT {\n    name;\n    type;\n    id;\n    offset;\n    defaultInteger;\n    defaultReal;\n    deprecated;\n    required;\n    key;\n    attributes;\n    documentation;\n    optional;\n    padding;\n    constructor(name = null, type = null, id = 0, offset = 0, defaultInteger = BigInt('0'), defaultReal = 0.0, deprecated = false, required = false, key = false, attributes = [], documentation = [], optional = false, padding = 0) {\n        this.name = name;\n        this.type = type;\n        this.id = id;\n        this.offset = offset;\n        this.defaultInteger = defaultInteger;\n        this.defaultReal = defaultReal;\n        this.deprecated = deprecated;\n        this.required = required;\n        this.key = key;\n        this.attributes = attributes;\n        this.documentation = documentation;\n        this.optional = optional;\n        this.padding = padding;\n    }\n    pack(builder) {\n        const name = (this.name !== null ? builder.createString(this.name) : 0);\n        const type = (this.type !== null ? this.type.pack(builder) : 0);\n        const attributes = reflectionField.createAttributesVector(builder, builder.createObjectOffsetList(this.attributes));\n        const documentation = reflectionField.createDocumentationVector(builder, builder.createObjectOffsetList(this.documentation));\n        reflectionField.startField(builder);\n        reflectionField.addName(builder, name);\n        reflectionField.addType(builder, type);\n        reflectionField.addId(builder, this.id);\n        reflectionField.addOffset(builder, this.offset);\n        reflectionField.addDefaultInteger(builder, this.defaultInteger);\n        reflectionField.addDefaultReal(builder, this.defaultReal);\n        reflectionField.addDeprecated(builder, this.deprecated);\n        reflectionField.addRequired(builder, this.required);\n        reflectionField.addKey(builder, this.key);\n        reflectionField.addAttributes(builder, attributes);\n        reflectionField.addDocumentation(builder, documentation);\n        reflectionField.addOptional(builder, this.optional);\n        reflectionField.addPadding(builder, this.padding);\n        return reflectionField.endField(builder);\n    }\n}\nexport class Object_ {\n    bb = null;\n    bb_pos = 0;\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsObject(bb, obj) {\n        return (obj || new Object_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsObject(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Object_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    name(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    fields(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? (obj || new reflectionField()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    fieldsLength() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    isStruct() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    mutate_is_struct(value) {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt8(this.bb_pos + offset, +value);\n        return true;\n    }\n    minalign() {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;\n    }\n    mutate_minalign(value) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt32(this.bb_pos + offset, value);\n        return true;\n    }\n    bytesize() {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;\n    }\n    mutate_bytesize(value) {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeInt32(this.bb_pos + offset, value);\n        return true;\n    }\n    attributes(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        return offset ? (obj || new reflectionKeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    attributesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    documentation(index, optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 16);\n        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n    documentationLength() {\n        const offset = this.bb.__offset(this.bb_pos, 16);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    declarationFile(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 18);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    static getFullyQualifiedName() {\n        return 'reflection.Object';\n    }\n    static startObject(builder) {\n        builder.startObject(8);\n    }\n    static addName(builder, nameOffset) {\n        builder.addFieldOffset(0, nameOffset, 0);\n    }\n    static addFields(builder, fieldsOffset) {\n        builder.addFieldOffset(1, fieldsOffset, 0);\n    }\n    static createFieldsVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startFieldsVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addIsStruct(builder, isStruct) {\n        builder.addFieldInt8(2, +isStruct, +false);\n    }\n    static addMinalign(builder, minalign) {\n        builder.addFieldInt32(3, minalign, 0);\n    }\n    static addBytesize(builder, bytesize) {\n        builder.addFieldInt32(4, bytesize, 0);\n    }\n    static addAttributes(builder, attributesOffset) {\n        builder.addFieldOffset(5, attributesOffset, 0);\n    }\n    static createAttributesVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startAttributesVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addDocumentation(builder, documentationOffset) {\n        builder.addFieldOffset(6, documentationOffset, 0);\n    }\n    static createDocumentationVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startDocumentationVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addDeclarationFile(builder, declarationFileOffset) {\n        builder.addFieldOffset(7, declarationFileOffset, 0);\n    }\n    static endObject(builder) {\n        const offset = builder.endObject();\n        builder.requiredField(offset, 4); // name\n        builder.requiredField(offset, 6); // fields\n        return offset;\n    }\n    static createObject(builder, nameOffset, fieldsOffset, isStruct, minalign, bytesize, attributesOffset, documentationOffset, declarationFileOffset) {\n        Object_.startObject(builder);\n        Object_.addName(builder, nameOffset);\n        Object_.addFields(builder, fieldsOffset);\n        Object_.addIsStruct(builder, isStruct);\n        Object_.addMinalign(builder, minalign);\n        Object_.addBytesize(builder, bytesize);\n        Object_.addAttributes(builder, attributesOffset);\n        Object_.addDocumentation(builder, documentationOffset);\n        Object_.addDeclarationFile(builder, declarationFileOffset);\n        return Object_.endObject(builder);\n    }\n    unpack() {\n        return new ObjectT(this.name(), this.bb.createObjList(this.fields.bind(this), this.fieldsLength()), this.isStruct(), this.minalign(), this.bytesize(), this.bb.createObjList(this.attributes.bind(this), this.attributesLength()), this.bb.createScalarList(this.documentation.bind(this), this.documentationLength()), this.declarationFile());\n    }\n    unpackTo(_o) {\n        _o.name = this.name();\n        _o.fields = this.bb.createObjList(this.fields.bind(this), this.fieldsLength());\n        _o.isStruct = this.isStruct();\n        _o.minalign = this.minalign();\n        _o.bytesize = this.bytesize();\n        _o.attributes = this.bb.createObjList(this.attributes.bind(this), this.attributesLength());\n        _o.documentation = this.bb.createScalarList(this.documentation.bind(this), this.documentationLength());\n        _o.declarationFile = this.declarationFile();\n    }\n}\nexport class ObjectT {\n    name;\n    fields;\n    isStruct;\n    minalign;\n    bytesize;\n    attributes;\n    documentation;\n    declarationFile;\n    constructor(name = null, fields = [], isStruct = false, minalign = 0, bytesize = 0, attributes = [], documentation = [], declarationFile = null) {\n        this.name = name;\n        this.fields = fields;\n        this.isStruct = isStruct;\n        this.minalign = minalign;\n        this.bytesize = bytesize;\n        this.attributes = attributes;\n        this.documentation = documentation;\n        this.declarationFile = declarationFile;\n    }\n    pack(builder) {\n        const name = (this.name !== null ? builder.createString(this.name) : 0);\n        const fields = reflectionObject.createFieldsVector(builder, builder.createObjectOffsetList(this.fields));\n        const attributes = reflectionObject.createAttributesVector(builder, builder.createObjectOffsetList(this.attributes));\n        const documentation = reflectionObject.createDocumentationVector(builder, builder.createObjectOffsetList(this.documentation));\n        const declarationFile = (this.declarationFile !== null ? builder.createString(this.declarationFile) : 0);\n        return reflectionObject.createObject(builder, name, fields, this.isStruct, this.minalign, this.bytesize, attributes, documentation, declarationFile);\n    }\n}\nexport class RPCCall {\n    bb = null;\n    bb_pos = 0;\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsRPCCall(bb, obj) {\n        return (obj || new RPCCall()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsRPCCall(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new RPCCall()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    name(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    request(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? (obj || new reflectionObject()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    response(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? (obj || new reflectionObject()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    attributes(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? (obj || new reflectionKeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    attributesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    documentation(index, optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n    documentationLength() {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    static getFullyQualifiedName() {\n        return 'reflection.RPCCall';\n    }\n    static startRPCCall(builder) {\n        builder.startObject(5);\n    }\n    static addName(builder, nameOffset) {\n        builder.addFieldOffset(0, nameOffset, 0);\n    }\n    static addRequest(builder, requestOffset) {\n        builder.addFieldOffset(1, requestOffset, 0);\n    }\n    static addResponse(builder, responseOffset) {\n        builder.addFieldOffset(2, responseOffset, 0);\n    }\n    static addAttributes(builder, attributesOffset) {\n        builder.addFieldOffset(3, attributesOffset, 0);\n    }\n    static createAttributesVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startAttributesVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addDocumentation(builder, documentationOffset) {\n        builder.addFieldOffset(4, documentationOffset, 0);\n    }\n    static createDocumentationVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startDocumentationVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static endRPCCall(builder) {\n        const offset = builder.endObject();\n        builder.requiredField(offset, 4); // name\n        builder.requiredField(offset, 6); // request\n        builder.requiredField(offset, 8); // response\n        return offset;\n    }\n    unpack() {\n        return new RPCCallT(this.name(), (this.request() !== null ? this.request().unpack() : null), (this.response() !== null ? this.response().unpack() : null), this.bb.createObjList(this.attributes.bind(this), this.attributesLength()), this.bb.createScalarList(this.documentation.bind(this), this.documentationLength()));\n    }\n    unpackTo(_o) {\n        _o.name = this.name();\n        _o.request = (this.request() !== null ? this.request().unpack() : null);\n        _o.response = (this.response() !== null ? this.response().unpack() : null);\n        _o.attributes = this.bb.createObjList(this.attributes.bind(this), this.attributesLength());\n        _o.documentation = this.bb.createScalarList(this.documentation.bind(this), this.documentationLength());\n    }\n}\nexport class RPCCallT {\n    name;\n    request;\n    response;\n    attributes;\n    documentation;\n    constructor(name = null, request = null, response = null, attributes = [], documentation = []) {\n        this.name = name;\n        this.request = request;\n        this.response = response;\n        this.attributes = attributes;\n        this.documentation = documentation;\n    }\n    pack(builder) {\n        const name = (this.name !== null ? builder.createString(this.name) : 0);\n        const request = (this.request !== null ? this.request.pack(builder) : 0);\n        const response = (this.response !== null ? this.response.pack(builder) : 0);\n        const attributes = reflectionRPCCall.createAttributesVector(builder, builder.createObjectOffsetList(this.attributes));\n        const documentation = reflectionRPCCall.createDocumentationVector(builder, builder.createObjectOffsetList(this.documentation));\n        reflectionRPCCall.startRPCCall(builder);\n        reflectionRPCCall.addName(builder, name);\n        reflectionRPCCall.addRequest(builder, request);\n        reflectionRPCCall.addResponse(builder, response);\n        reflectionRPCCall.addAttributes(builder, attributes);\n        reflectionRPCCall.addDocumentation(builder, documentation);\n        return reflectionRPCCall.endRPCCall(builder);\n    }\n}\nexport class Service {\n    bb = null;\n    bb_pos = 0;\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsService(bb, obj) {\n        return (obj || new Service()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsService(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Service()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    name(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    calls(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? (obj || new reflectionRPCCall()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    callsLength() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    attributes(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? (obj || new reflectionKeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    attributesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    documentation(index, optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n    documentationLength() {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    declarationFile(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    static getFullyQualifiedName() {\n        return 'reflection.Service';\n    }\n    static startService(builder) {\n        builder.startObject(5);\n    }\n    static addName(builder, nameOffset) {\n        builder.addFieldOffset(0, nameOffset, 0);\n    }\n    static addCalls(builder, callsOffset) {\n        builder.addFieldOffset(1, callsOffset, 0);\n    }\n    static createCallsVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startCallsVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addAttributes(builder, attributesOffset) {\n        builder.addFieldOffset(2, attributesOffset, 0);\n    }\n    static createAttributesVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startAttributesVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addDocumentation(builder, documentationOffset) {\n        builder.addFieldOffset(3, documentationOffset, 0);\n    }\n    static createDocumentationVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startDocumentationVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addDeclarationFile(builder, declarationFileOffset) {\n        builder.addFieldOffset(4, declarationFileOffset, 0);\n    }\n    static endService(builder) {\n        const offset = builder.endObject();\n        builder.requiredField(offset, 4); // name\n        return offset;\n    }\n    static createService(builder, nameOffset, callsOffset, attributesOffset, documentationOffset, declarationFileOffset) {\n        Service.startService(builder);\n        Service.addName(builder, nameOffset);\n        Service.addCalls(builder, callsOffset);\n        Service.addAttributes(builder, attributesOffset);\n        Service.addDocumentation(builder, documentationOffset);\n        Service.addDeclarationFile(builder, declarationFileOffset);\n        return Service.endService(builder);\n    }\n    unpack() {\n        return new ServiceT(this.name(), this.bb.createObjList(this.calls.bind(this), this.callsLength()), this.bb.createObjList(this.attributes.bind(this), this.attributesLength()), this.bb.createScalarList(this.documentation.bind(this), this.documentationLength()), this.declarationFile());\n    }\n    unpackTo(_o) {\n        _o.name = this.name();\n        _o.calls = this.bb.createObjList(this.calls.bind(this), this.callsLength());\n        _o.attributes = this.bb.createObjList(this.attributes.bind(this), this.attributesLength());\n        _o.documentation = this.bb.createScalarList(this.documentation.bind(this), this.documentationLength());\n        _o.declarationFile = this.declarationFile();\n    }\n}\nexport class ServiceT {\n    name;\n    calls;\n    attributes;\n    documentation;\n    declarationFile;\n    constructor(name = null, calls = [], attributes = [], documentation = [], declarationFile = null) {\n        this.name = name;\n        this.calls = calls;\n        this.attributes = attributes;\n        this.documentation = documentation;\n        this.declarationFile = declarationFile;\n    }\n    pack(builder) {\n        const name = (this.name !== null ? builder.createString(this.name) : 0);\n        const calls = reflectionService.createCallsVector(builder, builder.createObjectOffsetList(this.calls));\n        const attributes = reflectionService.createAttributesVector(builder, builder.createObjectOffsetList(this.attributes));\n        const documentation = reflectionService.createDocumentationVector(builder, builder.createObjectOffsetList(this.documentation));\n        const declarationFile = (this.declarationFile !== null ? builder.createString(this.declarationFile) : 0);\n        return reflectionService.createService(builder, name, calls, attributes, documentation, declarationFile);\n    }\n}\n/**\n * File specific information.\n * Symbols declared within a file may be recovered by iterating over all\n * symbols and examining the `declaration_file` field.\n */\nexport class SchemaFile {\n    bb = null;\n    bb_pos = 0;\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsSchemaFile(bb, obj) {\n        return (obj || new SchemaFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsSchemaFile(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new SchemaFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    filename(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    includedFilenames(index, optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n    includedFilenamesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    static getFullyQualifiedName() {\n        return 'reflection.SchemaFile';\n    }\n    static startSchemaFile(builder) {\n        builder.startObject(2);\n    }\n    static addFilename(builder, filenameOffset) {\n        builder.addFieldOffset(0, filenameOffset, 0);\n    }\n    static addIncludedFilenames(builder, includedFilenamesOffset) {\n        builder.addFieldOffset(1, includedFilenamesOffset, 0);\n    }\n    static createIncludedFilenamesVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startIncludedFilenamesVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static endSchemaFile(builder) {\n        const offset = builder.endObject();\n        builder.requiredField(offset, 4); // filename\n        return offset;\n    }\n    static createSchemaFile(builder, filenameOffset, includedFilenamesOffset) {\n        SchemaFile.startSchemaFile(builder);\n        SchemaFile.addFilename(builder, filenameOffset);\n        SchemaFile.addIncludedFilenames(builder, includedFilenamesOffset);\n        return SchemaFile.endSchemaFile(builder);\n    }\n    unpack() {\n        return new SchemaFileT(this.filename(), this.bb.createScalarList(this.includedFilenames.bind(this), this.includedFilenamesLength()));\n    }\n    unpackTo(_o) {\n        _o.filename = this.filename();\n        _o.includedFilenames = this.bb.createScalarList(this.includedFilenames.bind(this), this.includedFilenamesLength());\n    }\n}\nexport class SchemaFileT {\n    filename;\n    includedFilenames;\n    constructor(filename = null, includedFilenames = []) {\n        this.filename = filename;\n        this.includedFilenames = includedFilenames;\n    }\n    pack(builder) {\n        const filename = (this.filename !== null ? builder.createString(this.filename) : 0);\n        const includedFilenames = reflectionSchemaFile.createIncludedFilenamesVector(builder, builder.createObjectOffsetList(this.includedFilenames));\n        return reflectionSchemaFile.createSchemaFile(builder, filename, includedFilenames);\n    }\n}\nexport class Schema {\n    bb = null;\n    bb_pos = 0;\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsSchema(bb, obj) {\n        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsSchema(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static bufferHasIdentifier(bb) {\n        return bb.__has_identifier('BFBS');\n    }\n    objects(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? (obj || new reflectionObject()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    objectsLength() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    enums(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? (obj || new reflectionEnum()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    enumsLength() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    fileIdent(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    fileExt(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    rootTable(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? (obj || new reflectionObject()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    services(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        return offset ? (obj || new reflectionService()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    servicesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    advancedFeatures() {\n        const offset = this.bb.__offset(this.bb_pos, 16);\n        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');\n    }\n    mutate_advanced_features(value) {\n        const offset = this.bb.__offset(this.bb_pos, 16);\n        if (offset === 0) {\n            return false;\n        }\n        this.bb.writeUint64(this.bb_pos + offset, value);\n        return true;\n    }\n    /**\n     * All the files used in this compilation. Files are relative to where\n     * flatc was invoked.\n     */\n    fbsFiles(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 18);\n        return offset ? (obj || new reflectionSchemaFile()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    fbsFilesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 18);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    static getFullyQualifiedName() {\n        return 'reflection.Schema';\n    }\n    static startSchema(builder) {\n        builder.startObject(8);\n    }\n    static addObjects(builder, objectsOffset) {\n        builder.addFieldOffset(0, objectsOffset, 0);\n    }\n    static createObjectsVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startObjectsVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addEnums(builder, enumsOffset) {\n        builder.addFieldOffset(1, enumsOffset, 0);\n    }\n    static createEnumsVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startEnumsVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addFileIdent(builder, fileIdentOffset) {\n        builder.addFieldOffset(2, fileIdentOffset, 0);\n    }\n    static addFileExt(builder, fileExtOffset) {\n        builder.addFieldOffset(3, fileExtOffset, 0);\n    }\n    static addRootTable(builder, rootTableOffset) {\n        builder.addFieldOffset(4, rootTableOffset, 0);\n    }\n    static addServices(builder, servicesOffset) {\n        builder.addFieldOffset(5, servicesOffset, 0);\n    }\n    static createServicesVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startServicesVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addAdvancedFeatures(builder, advancedFeatures) {\n        builder.addFieldInt64(6, advancedFeatures, BigInt('0'));\n    }\n    static addFbsFiles(builder, fbsFilesOffset) {\n        builder.addFieldOffset(7, fbsFilesOffset, 0);\n    }\n    static createFbsFilesVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startFbsFilesVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static endSchema(builder) {\n        const offset = builder.endObject();\n        builder.requiredField(offset, 4); // objects\n        builder.requiredField(offset, 6); // enums\n        return offset;\n    }\n    static finishSchemaBuffer(builder, offset) {\n        builder.finish(offset, 'BFBS');\n    }\n    static finishSizePrefixedSchemaBuffer(builder, offset) {\n        builder.finish(offset, 'BFBS', true);\n    }\n    unpack() {\n        return new SchemaT(this.bb.createObjList(this.objects.bind(this), this.objectsLength()), this.bb.createObjList(this.enums.bind(this), this.enumsLength()), this.fileIdent(), this.fileExt(), (this.rootTable() !== null ? this.rootTable().unpack() : null), this.bb.createObjList(this.services.bind(this), this.servicesLength()), this.advancedFeatures(), this.bb.createObjList(this.fbsFiles.bind(this), this.fbsFilesLength()));\n    }\n    unpackTo(_o) {\n        _o.objects = this.bb.createObjList(this.objects.bind(this), this.objectsLength());\n        _o.enums = this.bb.createObjList(this.enums.bind(this), this.enumsLength());\n        _o.fileIdent = this.fileIdent();\n        _o.fileExt = this.fileExt();\n        _o.rootTable = (this.rootTable() !== null ? this.rootTable().unpack() : null);\n        _o.services = this.bb.createObjList(this.services.bind(this), this.servicesLength());\n        _o.advancedFeatures = this.advancedFeatures();\n        _o.fbsFiles = this.bb.createObjList(this.fbsFiles.bind(this), this.fbsFilesLength());\n    }\n}\nexport class SchemaT {\n    objects;\n    enums;\n    fileIdent;\n    fileExt;\n    rootTable;\n    services;\n    advancedFeatures;\n    fbsFiles;\n    constructor(objects = [], enums = [], fileIdent = null, fileExt = null, rootTable = null, services = [], advancedFeatures = BigInt('0'), fbsFiles = []) {\n        this.objects = objects;\n        this.enums = enums;\n        this.fileIdent = fileIdent;\n        this.fileExt = fileExt;\n        this.rootTable = rootTable;\n        this.services = services;\n        this.advancedFeatures = advancedFeatures;\n        this.fbsFiles = fbsFiles;\n    }\n    pack(builder) {\n        const objects = reflectionSchema.createObjectsVector(builder, builder.createObjectOffsetList(this.objects));\n        const enums = reflectionSchema.createEnumsVector(builder, builder.createObjectOffsetList(this.enums));\n        const fileIdent = (this.fileIdent !== null ? builder.createString(this.fileIdent) : 0);\n        const fileExt = (this.fileExt !== null ? builder.createString(this.fileExt) : 0);\n        const rootTable = (this.rootTable !== null ? this.rootTable.pack(builder) : 0);\n        const services = reflectionSchema.createServicesVector(builder, builder.createObjectOffsetList(this.services));\n        const fbsFiles = reflectionSchema.createFbsFilesVector(builder, builder.createObjectOffsetList(this.fbsFiles));\n        reflectionSchema.startSchema(builder);\n        reflectionSchema.addObjects(builder, objects);\n        reflectionSchema.addEnums(builder, enums);\n        reflectionSchema.addFileIdent(builder, fileIdent);\n        reflectionSchema.addFileExt(builder, fileExt);\n        reflectionSchema.addRootTable(builder, rootTable);\n        reflectionSchema.addServices(builder, services);\n        reflectionSchema.addAdvancedFeatures(builder, this.advancedFeatures);\n        reflectionSchema.addFbsFiles(builder, fbsFiles);\n        return reflectionSchema.endSchema(builder);\n    }\n}\n//# sourceMappingURL=reflection_generated.js.map","// This file is essentially a clone of upstream flatbuffers code which\n// uses different (less-restrictive) linters.\n/* eslint no-underscore-dangle: 0 */\n/* eslint no-restricted-syntax: 0 */\n/* eslint @foxglove/strict-equality: 0 */\n/* eslint @foxglove/no-boolean-parameters: 0 */\n/* eslint @typescript-eslint/switch-exhaustiveness-check: 0 */\n/* eslint @typescript-eslint/restrict-plus-operands: 0 */\n/* eslint @typescript-eslint/no-explicit-any: 0 */\nimport * as reflection from \"./reflection_generated\";\n// Returns the size, in bytes, of the given type. For vectors/strings/etc.\n// returns the size of the offset.\nfunction typeSize(baseType) {\n    switch (baseType) {\n        case reflection.BaseType.None:\n        case reflection.BaseType.UType:\n        case reflection.BaseType.Bool:\n        case reflection.BaseType.Byte:\n        case reflection.BaseType.UByte:\n            return 1;\n        case reflection.BaseType.Short:\n        case reflection.BaseType.UShort:\n            return 2;\n        case reflection.BaseType.Int:\n        case reflection.BaseType.UInt:\n            return 4;\n        case reflection.BaseType.Long:\n        case reflection.BaseType.ULong:\n            return 8;\n        case reflection.BaseType.Float:\n            return 4;\n        case reflection.BaseType.Double:\n            return 8;\n        case reflection.BaseType.String:\n        case reflection.BaseType.Vector:\n        case reflection.BaseType.Obj:\n        case reflection.BaseType.Union:\n        case reflection.BaseType.Array:\n            return 4;\n    }\n    return NaN;\n}\n// Returns whether the given type is a scalar type.\nfunction isScalar(baseType) {\n    switch (baseType) {\n        case reflection.BaseType.UType:\n        case reflection.BaseType.Bool:\n        case reflection.BaseType.Byte:\n        case reflection.BaseType.UByte:\n        case reflection.BaseType.Short:\n        case reflection.BaseType.UShort:\n        case reflection.BaseType.Int:\n        case reflection.BaseType.UInt:\n        case reflection.BaseType.Long:\n        case reflection.BaseType.ULong:\n        case reflection.BaseType.Float:\n        case reflection.BaseType.Double:\n            return true;\n        case reflection.BaseType.None:\n        case reflection.BaseType.String:\n        case reflection.BaseType.Vector:\n        case reflection.BaseType.Obj:\n        case reflection.BaseType.Union:\n        case reflection.BaseType.Array:\n            return false;\n    }\n    return false;\n}\n// Returns whether the given type is integer or not.\nfunction isInteger(baseType) {\n    switch (baseType) {\n        case reflection.BaseType.UType:\n        case reflection.BaseType.Bool:\n        case reflection.BaseType.Byte:\n        case reflection.BaseType.UByte:\n        case reflection.BaseType.Short:\n        case reflection.BaseType.UShort:\n        case reflection.BaseType.Int:\n        case reflection.BaseType.UInt:\n        case reflection.BaseType.Long:\n        case reflection.BaseType.ULong:\n            return true;\n        case reflection.BaseType.Float:\n        case reflection.BaseType.Double:\n        case reflection.BaseType.None:\n        case reflection.BaseType.String:\n        case reflection.BaseType.Vector:\n        case reflection.BaseType.Obj:\n        case reflection.BaseType.Union:\n        case reflection.BaseType.Array:\n            return false;\n    }\n    return false;\n}\n// Stores the data associated with a Table within a given buffer.\nexport class Table {\n    bb;\n    typeIndex;\n    offset;\n    isStruct;\n    // Wrapper to represent an object (Table or Struct) within a ByteBuffer.\n    // The ByteBuffer is the raw data associated with the object.\n    // typeIndex is an index into the schema object vector for the parser\n    // object that this is associated with.\n    // offset is the absolute location within the buffer where the root of the\n    // object is.\n    // isStruct indicates whether the object in question is a flatbuffers struct\n    //   or table (this is relevant for doing some memory bounds checks).\n    // Note that a given Table assumes that it is being used with a particular\n    // Schema object.\n    // External users should generally not be using this constructor directly.\n    constructor(bb, typeIndex, offset, isStruct) {\n        // See https://flatbuffers.dev/md__internals.html for format details.\n        this.bb = bb;\n        this.typeIndex = typeIndex;\n        this.offset = offset;\n        this.isStruct = isStruct;\n        // Check that the table could plausibly fit in bounds\n        if (offset < 0 || offset + 4 > bb.capacity()) {\n            throw new Error(`Attempt to construct Table with offset ${offset}, which would extend beyond ByteBuffer (capacity ${bb.capacity()})`);\n        }\n        if (isStruct) {\n            // If this is a struct, we don't have a vtable, so the below checks don't\n            // apply.\n            return;\n        }\n        // Check that the table's vtable could fit in bounds\n        const offsetToVtable = bb.readInt32(offset);\n        const vtableOffset = offset - offsetToVtable;\n        const vtableMinSize = 2 * 2; // 2x uint16: vtable size and object size\n        if (vtableOffset < 0 || vtableOffset + vtableMinSize > bb.capacity()) {\n            throw new Error(`Table at offset ${offset} points to vtable at ${vtableOffset} (${offset} - ${offsetToVtable}), which would extend beyond the ByteBuffer (capacity ${bb.capacity()})`);\n        }\n        // The vtable's first entry is the size of the vtable itself; check that it fits in bounds.\n        const vtableActualSize = bb.readUint16(vtableOffset);\n        if (vtableActualSize < 4) {\n            throw new Error(`Table at offset ${offset} points to vtable at ${vtableOffset} (${offset} - ${offsetToVtable}), which specifies vtable size ${vtableActualSize}, which should be at least 4 (vtable size + object size)`);\n        }\n        if (vtableOffset + vtableActualSize > bb.capacity()) {\n            throw new Error(`Table at offset ${offset} points to vtable at ${vtableOffset} (${offset} - ${offsetToVtable}), which specifies vtable size ${vtableActualSize}, which would extend beyond the ByteBuffer (capacity ${bb.capacity()})`);\n        }\n        // The vtable's second entry is the size of the table's inline fields; check that it fits in bounds.\n        const objectSize = bb.readUint16(vtableOffset + 2);\n        if (objectSize < 4) {\n            throw new Error(`Table at offset ${offset} points to vtable at ${vtableOffset} (${offset} - ${offsetToVtable}), which specifies inline object size ${objectSize}, which should be at least 4 (vtable offset)`);\n        }\n        if (offset + objectSize > bb.capacity()) {\n            throw new Error(`Table at offset ${offset} points to vtable at ${vtableOffset} (${offset} - ${offsetToVtable}), which specifies inline object size ${objectSize}, which would extend beyond the ByteBuffer (capacity ${bb.capacity()})`);\n        }\n    }\n    // Constructs a Table object for the root of a ByteBuffer--this assumes that\n    // the type of the Table is the root table of the Parser that you are using.\n    // This assumes that the root table is a flatbuffers table, not a struct.\n    static getRootTable(bb) {\n        if (bb.position() + 4 > bb.capacity()) {\n            throw new Error(`Attempt to parse root table offset from ${bb.position()}, which would extend beyond ByteBuffer (capacity ${bb.capacity()})`);\n        }\n        // Additional bounds checks happen in the Table constructor\n        return new Table(bb, -1, bb.readUint32(bb.position()) + bb.position(), false);\n    }\n    // Constructs a table from a type name instead of from a type index.\n    static getNamedTable(bb, schema, type, offset) {\n        for (let ii = 0; ii < schema.objectsLength(); ++ii) {\n            const schemaObject = schema.objects(ii);\n            if (schemaObject !== null && schemaObject.name() === type) {\n                return new Table(bb, ii, offset === undefined\n                    ? bb.readUint32(bb.position()) + bb.position()\n                    : offset, schemaObject.isStruct());\n            }\n        }\n        throw new Error(\"Unable to find type \" + type + \" in schema.\");\n    }\n    // Reads a scalar of a given type at a given offset.\n    readScalar(fieldType, offset) {\n        const size = typeSize(fieldType);\n        if (offset < 0 || offset + size > this.bb.capacity()) {\n            throw new Error(`Attempt to read scalar type ${fieldType} (size ${size}) at offset ${offset}, which would extend beyond ByteBuffer (capacity ${this.bb.capacity()})`);\n        }\n        switch (fieldType) {\n            case reflection.BaseType.UType:\n            case reflection.BaseType.Bool:\n                return this.bb.readUint8(offset);\n            case reflection.BaseType.Byte:\n                return this.bb.readInt8(offset);\n            case reflection.BaseType.UByte:\n                return this.bb.readUint8(offset);\n            case reflection.BaseType.Short:\n                return this.bb.readInt16(offset);\n            case reflection.BaseType.UShort:\n                return this.bb.readUint16(offset);\n            case reflection.BaseType.Int:\n                return this.bb.readInt32(offset);\n            case reflection.BaseType.UInt:\n                return this.bb.readUint32(offset);\n            case reflection.BaseType.Long:\n                return this.bb.readInt64(offset);\n            case reflection.BaseType.ULong:\n                return this.bb.readUint64(offset);\n            case reflection.BaseType.Float:\n                return this.bb.readFloat32(offset);\n            case reflection.BaseType.Double:\n                return this.bb.readFloat64(offset);\n        }\n        throw new Error(`Unsupported message type ${fieldType}`);\n    }\n}\n// The Parser class uses a Schema to provide all the utilities required to\n// parse flatbuffers that have a type that is the same as the root_type defined\n// by the Schema.\n// The classical usage would be to, e.g., be reading a channel with a type of\n// \"foo.Bar\". At startup, you would construct a Parser from the channel's\n// Schema. When a message is received on the channel , you would then use\n// Table.getRootTable() on the received buffer to construct the Table, and\n// then access the members using the various methods of the Parser (or just\n// convert the entire object to a javascript Object/JSON using toObject()).\n// There are three basic ways to access fields in a Table:\n// 1) Call toObject(), which turns the entire table into a javascript object.\n//    This is not meant to be particularly fast, but is useful to, e.g.,\n//    convert something to JSON, or as a debugging tool.\n// 2) Call toObjectLambda() to get a function that lets you do the same thing\n//    as toObject(), except that it preloads all the reflection-related work.\n//    Note that this still deserializes the entire object, which may be\n//    overkill for your application if you care about performance.\n// 2) Use the read*Lambda() accessors: These return a function that lets you\n//    access the specified field given a table. This is used by the plotter\n//    to repeatedly access the same field on a bunch of tables of the same type,\n//    without having to redo all the reflection-related work on every access.\n// 3) Use the read*() accessors: These just call the lambda returned by\n//    read*Lambda() for you, as a convenience. This is cleaner to use, but for\n//    repeated lookups on tables of the same type, this may be inefficient.\nexport class Parser {\n    schema;\n    constructor(schema) {\n        this.schema = schema;\n    }\n    toObjectLambda(typeIndex, readDefaults = false) {\n        const lambdas = {};\n        const schema = this.getType(typeIndex);\n        const numFields = schema.fieldsLength();\n        for (let ii = 0; ii < numFields; ++ii) {\n            const field = schema.fields(ii);\n            if (field === null) {\n                throw new Error(\"Malformed schema: field at index \" + ii + \" not populated.\");\n            }\n            const fieldType = field.type();\n            if (fieldType === null) {\n                throw new Error('Malformed schema: \"type\" field of Field not populated.');\n            }\n            const fieldName = field.name();\n            if (fieldName === null) {\n                throw new Error('Malformed schema: \"name\" field of Field not populated.');\n            }\n            const baseType = fieldType.baseType();\n            if (isScalar(baseType)) {\n                lambdas[fieldName] = this.readScalarLambda(typeIndex, fieldName, readDefaults);\n            }\n            else if (baseType === reflection.BaseType.String) {\n                lambdas[fieldName] = this.readStringLambda(typeIndex, fieldName);\n            }\n            else if (baseType === reflection.BaseType.Obj) {\n                const rawLambda = this.readTableLambda(typeIndex, fieldName);\n                const subTableLambda = this.toObjectLambda(fieldType.index(), readDefaults);\n                lambdas[fieldName] = (t) => {\n                    const subTable = rawLambda(t);\n                    if (subTable === null) {\n                        return null;\n                    }\n                    return subTableLambda(subTable);\n                };\n            }\n            else if (baseType === reflection.BaseType.Vector) {\n                const elementType = fieldType.element();\n                if (isScalar(elementType)) {\n                    lambdas[fieldName] = this.readVectorOfScalarsLambda(typeIndex, fieldName);\n                }\n                else if (elementType === reflection.BaseType.String) {\n                    lambdas[fieldName] = this.readVectorOfStringsLambda(typeIndex, fieldName);\n                }\n                else if (elementType === reflection.BaseType.Obj) {\n                    const vectorLambda = this.readVectorOfTablesLambda(typeIndex, fieldName);\n                    const subTableLambda = this.toObjectLambda(fieldType.index(), readDefaults);\n                    lambdas[fieldName] = (t) => {\n                        const vector = vectorLambda(t);\n                        if (vector === null) {\n                            return null;\n                        }\n                        const result = [];\n                        for (const table of vector) {\n                            result.push(subTableLambda(table));\n                        }\n                        return result;\n                    };\n                }\n                else {\n                    throw new Error(\"Vectors of Unions and Arrays are not supported.\");\n                }\n            }\n            else {\n                throw new Error(\"Unions and Arrays are not supported in field \" + field.name());\n            }\n        }\n        return (t) => {\n            const obj = {};\n            // Go through and attempt to use every single field accessor; return the\n            // resulting object.\n            for (const field in lambdas) {\n                const value = lambdas[field](t);\n                if (value !== null) {\n                    obj[field] = value;\n                }\n            }\n            return obj;\n        };\n    }\n    // Parse a Table to a javascript object. This is can be used, e.g., to convert\n    // a flatbuffer Table to JSON.\n    // If readDefaults is set to true, then scalar fields will be filled out with\n    // their default values if not populated; if readDefaults is false and the\n    // field is not populated, the resulting object will not populate the field.\n    toObject(table, readDefaults = false) {\n        return this.toObjectLambda(table.typeIndex, readDefaults)(table);\n    }\n    // Returns the Object definition associated with the given type index.\n    getType(typeIndex) {\n        if (typeIndex === -1) {\n            const rootTable = this.schema.rootTable();\n            if (rootTable === null) {\n                throw new Error(\"Malformed schema: No root table.\");\n            }\n            return rootTable;\n        }\n        if (typeIndex < 0 || typeIndex > this.schema.objectsLength()) {\n            throw new Error(\"Type index out-of-range.\");\n        }\n        const table = this.schema.objects(typeIndex);\n        if (table === null) {\n            throw new Error(\"Malformed schema: No object at index \" + typeIndex + \".\");\n        }\n        return table;\n    }\n    // Retrieves the Field schema for the given field name within a given\n    // type index.\n    getField(fieldName, typeIndex) {\n        const schema = this.getType(typeIndex);\n        const numFields = schema.fieldsLength();\n        for (let ii = 0; ii < numFields; ++ii) {\n            const field = schema.fields(ii);\n            if (field === null) {\n                throw new Error(\"Malformed schema: Missing Field table at index \" + ii + \".\");\n            }\n            const name = field.name();\n            if (fieldName === name) {\n                return field;\n            }\n        }\n        throw new Error(\"Couldn't find field \" + fieldName + \" in object \" + schema.name() + \".\");\n    }\n    // Reads a scalar with the given field name from a Table. If readDefaults\n    // is set to false and the field is unset, we will return null. If\n    // readDefaults is true and the field is unset, we will look-up the default\n    // value for the field and return that.\n    // For 64-bit fields, returns a flatbuffer Long rather than a standard number.\n    readScalar(table, fieldName, readDefaults = false) {\n        return this.readScalarLambda(table.typeIndex, fieldName, readDefaults)(table);\n    }\n    // Like readScalar(), except that this returns an accessor for the specified\n    // field, rather than the value of the field itself.\n    // Note that the *Lambda() methods take a typeIndex instead of a Table, which\n    // can be obtained using table.typeIndex.\n    readScalarLambda(typeIndex, fieldName, readDefaults = false) {\n        const field = this.getField(fieldName, typeIndex);\n        const fieldType = field.type();\n        if (fieldType === null) {\n            throw new Error('Malformed schema: \"type\" field of Field not populated.');\n        }\n        const isStruct = this.getType(typeIndex).isStruct();\n        if (!isScalar(fieldType.baseType())) {\n            throw new Error(\"Field \" + fieldName + \" is not a scalar type.\");\n        }\n        if (isStruct) {\n            const baseType = fieldType.baseType();\n            return (t) => {\n                return t.readScalar(baseType, t.offset + field.offset());\n            };\n        }\n        return (t) => {\n            const offset = t.offset + t.bb.__offset(t.offset, field.offset());\n            if (offset === t.offset) {\n                if (!readDefaults) {\n                    return null;\n                }\n                if (isInteger(fieldType.baseType())) {\n                    return field.defaultInteger();\n                }\n                else {\n                    return field.defaultReal();\n                }\n            }\n            return t.readScalar(fieldType.baseType(), offset);\n        };\n    }\n    // Reads a string with the given field name from the provided Table.\n    // If the field is unset, returns null.\n    readString(table, fieldName) {\n        return this.readStringLambda(table.typeIndex, fieldName)(table);\n    }\n    readStringLambda(typeIndex, fieldName) {\n        const field = this.getField(fieldName, typeIndex);\n        const fieldType = field.type();\n        if (fieldType === null) {\n            throw new Error('Malformed schema: \"type\" field of Field not populated.');\n        }\n        if (fieldType.baseType() !== reflection.BaseType.String) {\n            throw new Error(\"Field \" + fieldName + \" is not a string.\");\n        }\n        return (t) => {\n            const offsetToOffset = t.offset + t.bb.__offset(t.offset, field.offset());\n            if (offsetToOffset === t.offset) {\n                return null;\n            }\n            return t.bb.__string(offsetToOffset);\n        };\n    }\n    // Reads a sub-message from the given Table. The sub-message may either be\n    // a struct or a Table. Returns null if the sub-message is not set.\n    readTable(table, fieldName) {\n        return this.readTableLambda(table.typeIndex, fieldName)(table);\n    }\n    readTableLambda(typeIndex, fieldName) {\n        const field = this.getField(fieldName, typeIndex);\n        const fieldType = field.type();\n        if (fieldType === null) {\n            throw new Error('Malformed schema: \"type\" field of Field not populated.');\n        }\n        const parentIsStruct = this.getType(typeIndex).isStruct();\n        if (fieldType.baseType() !== reflection.BaseType.Obj) {\n            throw new Error(\"Field \" + fieldName + \" is not an object type.\");\n        }\n        const elementIsStruct = this.getType(fieldType.index()).isStruct();\n        if (parentIsStruct) {\n            return (t) => {\n                return new Table(t.bb, fieldType.index(), t.offset + field.offset(), elementIsStruct);\n            };\n        }\n        return (table) => {\n            const offsetToOffset = table.offset + table.bb.__offset(table.offset, field.offset());\n            if (offsetToOffset === table.offset) {\n                return null;\n            }\n            const objectStart = elementIsStruct ? offsetToOffset : table.bb.__indirect(offsetToOffset);\n            return new Table(table.bb, fieldType.index(), objectStart, elementIsStruct);\n        };\n    }\n    // Reads a vector of scalars (like readScalar, may return a vector of BigInt's\n    // instead). Also, will return null if the vector is not set.\n    readVectorOfScalars(table, fieldName) {\n        return this.readVectorOfScalarsLambda(table.typeIndex, fieldName)(table);\n    }\n    readVectorOfScalarsLambda(typeIndex, fieldName) {\n        const field = this.getField(fieldName, typeIndex);\n        const fieldType = field.type();\n        if (fieldType === null) {\n            throw new Error('Malformed schema: \"type\" field of Field not populated.');\n        }\n        if (fieldType.baseType() !== reflection.BaseType.Vector) {\n            throw new Error(\"Field \" + fieldName + \" is not an vector.\");\n        }\n        const elementType = fieldType.element();\n        if (!isScalar(elementType)) {\n            throw new Error(\"Field \" + fieldName + \" is not an vector of scalars.\");\n        }\n        const isUByteVector = elementType === reflection.BaseType.UByte;\n        return (table) => {\n            const offsetToOffset = table.offset + table.bb.__offset(table.offset, field.offset());\n            if (offsetToOffset === table.offset) {\n                return null;\n            }\n            const numElements = table.bb.__vector_len(offsetToOffset);\n            const baseOffset = table.bb.__vector(offsetToOffset);\n            const scalarSize = typeSize(fieldType.element());\n            let result;\n            // If the vector is a byte vector, we can return a slice into the buffer\n            if (isUByteVector) {\n                result = new Uint8Array(table.bb.bytes().buffer, table.bb.bytes().byteOffset + baseOffset, numElements);\n            }\n            else {\n                result = [];\n                for (let ii = 0; ii < numElements; ++ii) {\n                    result.push(table.readScalar(fieldType.element(), baseOffset + scalarSize * ii));\n                }\n            }\n            return result;\n        };\n    }\n    // Reads a vector of tables. Returns null if vector is not set.\n    readVectorOfTables(table, fieldName) {\n        return this.readVectorOfTablesLambda(table.typeIndex, fieldName)(table);\n    }\n    readVectorOfTablesLambda(typeIndex, fieldName) {\n        const field = this.getField(fieldName, typeIndex);\n        const fieldType = field.type();\n        if (fieldType === null) {\n            throw new Error('Malformed schema: \"type\" field of Field not populated.');\n        }\n        if (fieldType.baseType() !== reflection.BaseType.Vector) {\n            throw new Error(\"Field \" + fieldName + \" is not an vector.\");\n        }\n        if (fieldType.element() !== reflection.BaseType.Obj) {\n            throw new Error(\"Field \" + fieldName + \" is not an vector of objects.\");\n        }\n        const elementSchema = this.getType(fieldType.index());\n        const elementIsStruct = elementSchema.isStruct();\n        const elementSize = elementIsStruct ? elementSchema.bytesize() : typeSize(fieldType.element());\n        return (table) => {\n            const offsetToOffset = table.offset + table.bb.__offset(table.offset, field.offset());\n            if (offsetToOffset === table.offset) {\n                return null;\n            }\n            const numElements = table.bb.__vector_len(offsetToOffset);\n            const result = [];\n            const baseOffset = table.bb.__vector(offsetToOffset);\n            for (let ii = 0; ii < numElements; ++ii) {\n                const elementOffset = baseOffset + elementSize * ii;\n                result.push(new Table(table.bb, fieldType.index(), elementIsStruct ? elementOffset\n                    : table.bb.__indirect(elementOffset), elementIsStruct));\n            }\n            return result;\n        };\n    }\n    // Reads a vector of strings. Returns null if not set.\n    readVectorOfStrings(table, fieldName) {\n        return this.readVectorOfStringsLambda(table.typeIndex, fieldName)(table);\n    }\n    readVectorOfStringsLambda(typeIndex, fieldName) {\n        const field = this.getField(fieldName, typeIndex);\n        const fieldType = field.type();\n        if (fieldType === null) {\n            throw new Error('Malformed schema: \"type\" field of Field not populated.');\n        }\n        if (fieldType.baseType() !== reflection.BaseType.Vector) {\n            throw new Error(\"Field \" + fieldName + \" is not an vector.\");\n        }\n        if (fieldType.element() !== reflection.BaseType.String) {\n            throw new Error(\"Field \" + fieldName + \" is not an vector of strings.\");\n        }\n        return (table) => {\n            const offsetToOffset = table.offset + table.bb.__offset(table.offset, field.offset());\n            if (offsetToOffset === table.offset) {\n                return null;\n            }\n            const numElements = table.bb.__vector_len(offsetToOffset);\n            const result = [];\n            const baseOffset = table.bb.__vector(offsetToOffset);\n            const offsetSize = typeSize(fieldType.element());\n            for (let ii = 0; ii < numElements; ++ii) {\n                result.push(table.bb.__string(baseOffset + offsetSize * ii));\n            }\n            return result;\n        };\n    }\n}\n//# sourceMappingURL=reflection.js.map","\"use strict\";\nvar $protobuf = require(\"../..\");\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require(\"../../google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\n\nvar Namespace = $protobuf.Namespace,\n    Root      = $protobuf.Root,\n    Enum      = $protobuf.Enum,\n    Type      = $protobuf.Type,\n    Field     = $protobuf.Field,\n    MapField  = $protobuf.MapField,\n    OneOf     = $protobuf.OneOf,\n    Service   = $protobuf.Service,\n    Method    = $protobuf.Method;\n\n// --- Root ---\n\n/**\n * Properties of a FileDescriptorSet message.\n * @interface IFileDescriptorSet\n * @property {IFileDescriptorProto[]} file Files\n */\n\n/**\n * Properties of a FileDescriptorProto message.\n * @interface IFileDescriptorProto\n * @property {string} [name] File name\n * @property {string} [package] Package\n * @property {*} [dependency] Not supported\n * @property {*} [publicDependency] Not supported\n * @property {*} [weakDependency] Not supported\n * @property {IDescriptorProto[]} [messageType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IServiceDescriptorProto[]} [service] Nested services\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\n * @property {IFileOptions} [options] Options\n * @property {*} [sourceCodeInfo] Not supported\n * @property {string} [syntax=\"proto2\"] Syntax\n */\n\n/**\n * Properties of a FileOptions message.\n * @interface IFileOptions\n * @property {string} [javaPackage]\n * @property {string} [javaOuterClassname]\n * @property {boolean} [javaMultipleFiles]\n * @property {boolean} [javaGenerateEqualsAndHash]\n * @property {boolean} [javaStringCheckUtf8]\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\n * @property {string} [goPackage]\n * @property {boolean} [ccGenericServices]\n * @property {boolean} [javaGenericServices]\n * @property {boolean} [pyGenericServices]\n * @property {boolean} [deprecated]\n * @property {boolean} [ccEnableArenas]\n * @property {string} [objcClassPrefix]\n * @property {string} [csharpNamespace]\n */\n\n/**\n * Values of he FileOptions.OptimizeMode enum.\n * @typedef IFileOptionsOptimizeMode\n * @type {number}\n * @property {number} SPEED=1\n * @property {number} CODE_SIZE=2\n * @property {number} LITE_RUNTIME=3\n */\n\n/**\n * Creates a root from a descriptor set.\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\n * @returns {Root} Root instance\n */\nRoot.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.FileDescriptorSet.decode(descriptor);\n\n    var root = new Root();\n\n    if (descriptor.file) {\n        var fileDescriptor,\n            filePackage;\n        for (var j = 0, i; j < descriptor.file.length; ++j) {\n            filePackage = root;\n            if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length)\n                filePackage = root.define(fileDescriptor[\"package\"]);\n            if (fileDescriptor.name && fileDescriptor.name.length)\n                root.files.push(filePackage.filename = fileDescriptor.name);\n            if (fileDescriptor.messageType)\n                for (i = 0; i < fileDescriptor.messageType.length; ++i)\n                    filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));\n            if (fileDescriptor.enumType)\n                for (i = 0; i < fileDescriptor.enumType.length; ++i)\n                    filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));\n            if (fileDescriptor.extension)\n                for (i = 0; i < fileDescriptor.extension.length; ++i)\n                    filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));\n            if (fileDescriptor.service)\n                for (i = 0; i < fileDescriptor.service.length; ++i)\n                    filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));\n            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\n            if (opts) {\n                var ks = Object.keys(opts);\n                for (i = 0; i < ks.length; ++i)\n                    filePackage.setOption(ks[i], opts[ks[i]]);\n            }\n        }\n    }\n\n    return root;\n};\n\n/**\n * Converts a root to a descriptor set.\n * @returns {Message<IFileDescriptorSet>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nRoot.prototype.toDescriptor = function toDescriptor(syntax) {\n    var set = exports.FileDescriptorSet.create();\n    Root_toDescriptorRecursive(this, set.file, syntax);\n    return set;\n};\n\n// Traverses a namespace and assembles the descriptor set\nfunction Root_toDescriptorRecursive(ns, files, syntax) {\n\n    // Create a new file\n    var file = exports.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\" });\n    if (syntax)\n        file.syntax = syntax;\n    if (!(ns instanceof Root))\n        file[\"package\"] = ns.fullName.substring(1);\n\n    // Add nested types\n    for (var i = 0, nested; i < ns.nestedArray.length; ++i)\n        if ((nested = ns._nestedArray[i]) instanceof Type)\n            file.messageType.push(nested.toDescriptor(syntax));\n        else if (nested instanceof Enum)\n            file.enumType.push(nested.toDescriptor());\n        else if (nested instanceof Field)\n            file.extension.push(nested.toDescriptor(syntax));\n        else if (nested instanceof Service)\n            file.service.push(nested.toDescriptor());\n        else if (nested instanceof /* plain */ Namespace)\n            Root_toDescriptorRecursive(nested, files, syntax); // requires new file\n\n    // Keep package-level options\n    file.options = toDescriptorOptions(ns.options, exports.FileOptions);\n\n    // And keep the file only if there is at least one nested object\n    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)\n        files.push(file);\n}\n\n// --- Type ---\n\n/**\n * Properties of a DescriptorProto message.\n * @interface IDescriptorProto\n * @property {string} [name] Message type name\n * @property {IFieldDescriptorProto[]} [field] Fields\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\n * @property {IDescriptorProto[]} [nestedType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\n * @property {IMessageOptions} [options] Not supported\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\n * @property {string[]} [reservedName] Reserved names\n */\n\n/**\n * Properties of a MessageOptions message.\n * @interface IMessageOptions\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\n */\n\n/**\n * Properties of an ExtensionRange message.\n * @interface IDescriptorProtoExtensionRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\n/**\n * Properties of a ReservedRange message.\n * @interface IDescriptorProtoReservedRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\nvar unnamedMessageIndex = 0;\n\n/**\n * Creates a type from a descriptor.\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Type} Type instance\n */\nType.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.DescriptorProto.decode(descriptor);\n\n    // Create the message type\n    var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),\n        i;\n\n    /* Oneofs */ if (descriptor.oneofDecl)\n        for (i = 0; i < descriptor.oneofDecl.length; ++i)\n            type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\n    /* Fields */ if (descriptor.field)\n        for (i = 0; i < descriptor.field.length; ++i) {\n            var field = Field.fromDescriptor(descriptor.field[i], syntax);\n            type.add(field);\n            if (descriptor.field[i].hasOwnProperty(\"oneofIndex\")) // eslint-disable-line no-prototype-builtins\n                type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\n        }\n    /* Extension fields */ if (descriptor.extension)\n        for (i = 0; i < descriptor.extension.length; ++i)\n            type.add(Field.fromDescriptor(descriptor.extension[i], syntax));\n    /* Nested types */ if (descriptor.nestedType)\n        for (i = 0; i < descriptor.nestedType.length; ++i) {\n            type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));\n            if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)\n                type.setOption(\"map_entry\", true);\n        }\n    /* Nested enums */ if (descriptor.enumType)\n        for (i = 0; i < descriptor.enumType.length; ++i)\n            type.add(Enum.fromDescriptor(descriptor.enumType[i]));\n    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {\n        type.extensions = [];\n        for (i = 0; i < descriptor.extensionRange.length; ++i)\n            type.extensions.push([ descriptor.extensionRange[i].start, descriptor.extensionRange[i].end ]);\n    }\n    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\n        type.reserved = [];\n        /* Ranges */ if (descriptor.reservedRange)\n            for (i = 0; i < descriptor.reservedRange.length; ++i)\n                type.reserved.push([ descriptor.reservedRange[i].start, descriptor.reservedRange[i].end ]);\n        /* Names */ if (descriptor.reservedName)\n            for (i = 0; i < descriptor.reservedName.length; ++i)\n                type.reserved.push(descriptor.reservedName[i]);\n    }\n\n    return type;\n};\n\n/**\n * Converts a type to a descriptor.\n * @returns {Message<IDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nType.prototype.toDescriptor = function toDescriptor(syntax) {\n    var descriptor = exports.DescriptorProto.create({ name: this.name }),\n        i;\n\n    /* Fields */ for (i = 0; i < this.fieldsArray.length; ++i) {\n        var fieldDescriptor;\n        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));\n        if (this._fieldsArray[i] instanceof MapField) { // map fields are repeated FieldNameEntry\n            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),\n                valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),\n                valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14\n                    ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type\n                    : undefined;\n            descriptor.nestedType.push(exports.DescriptorProto.create({\n                name: fieldDescriptor.typeName,\n                field: [\n                    exports.FieldDescriptorProto.create({ name: \"key\", number: 1, label: 1, type: keyType }), // can't reference a type or enum\n                    exports.FieldDescriptorProto.create({ name: \"value\", number: 2, label: 1, type: valueType, typeName: valueTypeName })\n                ],\n                options: exports.MessageOptions.create({ mapEntry: true })\n            }));\n        }\n    }\n    /* Oneofs */ for (i = 0; i < this.oneofsArray.length; ++i)\n        descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\n    /* Nested... */ for (i = 0; i < this.nestedArray.length; ++i) {\n        /* Extension fields */ if (this._nestedArray[i] instanceof Field)\n            descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));\n        /* Types */ else if (this._nestedArray[i] instanceof Type)\n            descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));\n        /* Enums */ else if (this._nestedArray[i] instanceof Enum)\n            descriptor.enumType.push(this._nestedArray[i].toDescriptor());\n        // plain nested namespaces become packages instead in Root#toDescriptor\n    }\n    /* Extension ranges */ if (this.extensions)\n        for (i = 0; i < this.extensions.length; ++i)\n            descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));\n    /* Reserved... */ if (this.reserved)\n        for (i = 0; i < this.reserved.length; ++i)\n            /* Names */ if (typeof this.reserved[i] === \"string\")\n                descriptor.reservedName.push(this.reserved[i]);\n            /* Ranges */ else\n                descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));\n\n    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\n\n    return descriptor;\n};\n\n// --- Field ---\n\n/**\n * Properties of a FieldDescriptorProto message.\n * @interface IFieldDescriptorProto\n * @property {string} [name] Field name\n * @property {number} [number] Field id\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\n * @property {IFieldDescriptorProtoType} [type] Field basic type\n * @property {string} [typeName] Field type name\n * @property {string} [extendee] Extended type name\n * @property {string} [defaultValue] Literal default value\n * @property {number} [oneofIndex] Oneof index if part of a oneof\n * @property {*} [jsonName] Not supported\n * @property {IFieldOptions} [options] Field options\n */\n\n/**\n * Values of the FieldDescriptorProto.Label enum.\n * @typedef IFieldDescriptorProtoLabel\n * @type {number}\n * @property {number} LABEL_OPTIONAL=1\n * @property {number} LABEL_REQUIRED=2\n * @property {number} LABEL_REPEATED=3\n */\n\n/**\n * Values of the FieldDescriptorProto.Type enum.\n * @typedef IFieldDescriptorProtoType\n * @type {number}\n * @property {number} TYPE_DOUBLE=1\n * @property {number} TYPE_FLOAT=2\n * @property {number} TYPE_INT64=3\n * @property {number} TYPE_UINT64=4\n * @property {number} TYPE_INT32=5\n * @property {number} TYPE_FIXED64=6\n * @property {number} TYPE_FIXED32=7\n * @property {number} TYPE_BOOL=8\n * @property {number} TYPE_STRING=9\n * @property {number} TYPE_GROUP=10\n * @property {number} TYPE_MESSAGE=11\n * @property {number} TYPE_BYTES=12\n * @property {number} TYPE_UINT32=13\n * @property {number} TYPE_ENUM=14\n * @property {number} TYPE_SFIXED32=15\n * @property {number} TYPE_SFIXED64=16\n * @property {number} TYPE_SINT32=17\n * @property {number} TYPE_SINT64=18\n */\n\n/**\n * Properties of a FieldOptions message.\n * @interface IFieldOptions\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\n */\n\n/**\n * Values of the FieldOptions.JSType enum.\n * @typedef IFieldOptionsJSType\n * @type {number}\n * @property {number} JS_NORMAL=0\n * @property {number} JS_STRING=1\n * @property {number} JS_NUMBER=2\n */\n\n// copied here from parse.js\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\n\n/**\n * Creates a field from a descriptor.\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Field} Field instance\n */\nField.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.DescriptorProto.decode(descriptor);\n\n    if (typeof descriptor.number !== \"number\")\n        throw Error(\"missing field id\");\n\n    // Rewire field type\n    var fieldType;\n    if (descriptor.typeName && descriptor.typeName.length)\n        fieldType = descriptor.typeName;\n    else\n        fieldType = fromDescriptorType(descriptor.type);\n\n    // Rewire field rule\n    var fieldRule;\n    switch (descriptor.label) {\n        // 0 is reserved for errors\n        case 1: fieldRule = undefined; break;\n        case 2: fieldRule = \"required\"; break;\n        case 3: fieldRule = \"repeated\"; break;\n        default: throw Error(\"illegal label: \" + descriptor.label);\n    }\n\n\tvar extendee = descriptor.extendee;\n\tif (descriptor.extendee !== undefined) {\n\t\textendee = extendee.length ? extendee : undefined;\n\t}\n    var field = new Field(\n        descriptor.name.length ? descriptor.name : \"field\" + descriptor.number,\n        descriptor.number,\n        fieldType,\n        fieldRule,\n        extendee\n    );\n\n    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\n\n    if (descriptor.defaultValue && descriptor.defaultValue.length) {\n        var defaultValue = descriptor.defaultValue;\n        switch (defaultValue) {\n            case \"true\": case \"TRUE\":\n                defaultValue = true;\n                break;\n            case \"false\": case \"FALSE\":\n                defaultValue = false;\n                break;\n            default:\n                var match = numberRe.exec(defaultValue);\n                if (match)\n                    defaultValue = parseInt(defaultValue); // eslint-disable-line radix\n                break;\n        }\n        field.setOption(\"default\", defaultValue);\n    }\n\n    if (packableDescriptorType(descriptor.type)) {\n        if (syntax === \"proto3\") { // defaults to packed=true (internal preset is packed=true)\n            if (descriptor.options && !descriptor.options.packed)\n                field.setOption(\"packed\", false);\n        } else if (!(descriptor.options && descriptor.options.packed)) // defaults to packed=false\n            field.setOption(\"packed\", false);\n    }\n\n    return field;\n};\n\n/**\n * Converts a field to a descriptor.\n * @returns {Message<IFieldDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nField.prototype.toDescriptor = function toDescriptor(syntax) {\n    var descriptor = exports.FieldDescriptorProto.create({ name: this.name, number: this.id });\n\n    if (this.map) {\n\n        descriptor.type = 11; // message\n        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\n        descriptor.label = 3; // repeated\n\n    } else {\n\n        // Rewire field type\n        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {\n            case 10: // group\n            case 11: // type\n            case 14: // enum\n                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\n                break;\n        }\n\n        // Rewire field rule\n        switch (this.rule) {\n            case \"repeated\": descriptor.label = 3; break;\n            case \"required\": descriptor.label = 2; break;\n            default: descriptor.label = 1; break;\n        }\n\n    }\n\n    // Handle extension field\n    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;\n\n    // Handle part of oneof\n    if (this.partOf)\n        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)\n            throw Error(\"missing oneof\");\n\n    if (this.options) {\n        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\n        if (this.options[\"default\"] != null)\n            descriptor.defaultValue = String(this.options[\"default\"]);\n    }\n\n    if (syntax === \"proto3\") { // defaults to packed=true\n        if (!this.packed)\n            (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\n    } else if (this.packed) // defaults to packed=false\n        (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\n\n    return descriptor;\n};\n\n// --- Enum ---\n\n/**\n * Properties of an EnumDescriptorProto message.\n * @interface IEnumDescriptorProto\n * @property {string} [name] Enum name\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\n * @property {IEnumOptions} [options] Enum options\n */\n\n/**\n * Properties of an EnumValueDescriptorProto message.\n * @interface IEnumValueDescriptorProto\n * @property {string} [name] Name\n * @property {number} [number] Value\n * @property {*} [options] Not supported\n */\n\n/**\n * Properties of an EnumOptions message.\n * @interface IEnumOptions\n * @property {boolean} [allowAlias] Whether aliases are allowed\n * @property {boolean} [deprecated]\n */\n\nvar unnamedEnumIndex = 0;\n\n/**\n * Creates an enum from a descriptor.\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Enum} Enum instance\n */\nEnum.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.EnumDescriptorProto.decode(descriptor);\n\n    // Construct values object\n    var values = {};\n    if (descriptor.value)\n        for (var i = 0; i < descriptor.value.length; ++i) {\n            var name  = descriptor.value[i].name,\n                value = descriptor.value[i].number || 0;\n            values[name && name.length ? name : \"NAME\" + value] = value;\n        }\n\n    return new Enum(\n        descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++,\n        values,\n        fromDescriptorOptions(descriptor.options, exports.EnumOptions)\n    );\n};\n\n/**\n * Converts an enum to a descriptor.\n * @returns {Message<IEnumDescriptorProto>} Descriptor\n */\nEnum.prototype.toDescriptor = function toDescriptor() {\n\n    // Values\n    var values = [];\n    for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)\n        values.push(exports.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));\n\n    return exports.EnumDescriptorProto.create({\n        name: this.name,\n        value: values,\n        options: toDescriptorOptions(this.options, exports.EnumOptions)\n    });\n};\n\n// --- OneOf ---\n\n/**\n * Properties of a OneofDescriptorProto message.\n * @interface IOneofDescriptorProto\n * @property {string} [name] Oneof name\n * @property {*} [options] Not supported\n */\n\nvar unnamedOneofIndex = 0;\n\n/**\n * Creates a oneof from a descriptor.\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {OneOf} OneOf instance\n */\nOneOf.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.OneofDescriptorProto.decode(descriptor);\n\n    return new OneOf(\n        // unnamedOneOfIndex is global, not per type, because we have no ref to a type here\n        descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++\n        // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option\n    );\n};\n\n/**\n * Converts a oneof to a descriptor.\n * @returns {Message<IOneofDescriptorProto>} Descriptor\n */\nOneOf.prototype.toDescriptor = function toDescriptor() {\n    return exports.OneofDescriptorProto.create({\n        name: this.name\n        // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option\n    });\n};\n\n// --- Service ---\n\n/**\n * Properties of a ServiceDescriptorProto message.\n * @interface IServiceDescriptorProto\n * @property {string} [name] Service name\n * @property {IMethodDescriptorProto[]} [method] Methods\n * @property {IServiceOptions} [options] Options\n */\n\n/**\n * Properties of a ServiceOptions message.\n * @interface IServiceOptions\n * @property {boolean} [deprecated]\n */\n\nvar unnamedServiceIndex = 0;\n\n/**\n * Creates a service from a descriptor.\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Service} Service instance\n */\nService.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.ServiceDescriptorProto.decode(descriptor);\n\n    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\n    if (descriptor.method)\n        for (var i = 0; i < descriptor.method.length; ++i)\n            service.add(Method.fromDescriptor(descriptor.method[i]));\n\n    return service;\n};\n\n/**\n * Converts a service to a descriptor.\n * @returns {Message<IServiceDescriptorProto>} Descriptor\n */\nService.prototype.toDescriptor = function toDescriptor() {\n\n    // Methods\n    var methods = [];\n    for (var i = 0; i < this.methodsArray.length; ++i)\n        methods.push(this._methodsArray[i].toDescriptor());\n\n    return exports.ServiceDescriptorProto.create({\n        name: this.name,\n        method: methods,\n        options: toDescriptorOptions(this.options, exports.ServiceOptions)\n    });\n};\n\n// --- Method ---\n\n/**\n * Properties of a MethodDescriptorProto message.\n * @interface IMethodDescriptorProto\n * @property {string} [name] Method name\n * @property {string} [inputType] Request type name\n * @property {string} [outputType] Response type name\n * @property {IMethodOptions} [options] Not supported\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\n */\n\n/**\n * Properties of a MethodOptions message.\n * @interface IMethodOptions\n * @property {boolean} [deprecated]\n */\n\nvar unnamedMethodIndex = 0;\n\n/**\n * Creates a method from a descriptor.\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Method} Reflected method instance\n */\nMethod.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.MethodDescriptorProto.decode(descriptor);\n\n    return new Method(\n        // unnamedMethodIndex is global, not per service, because we have no ref to a service here\n        descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++,\n        \"rpc\",\n        descriptor.inputType,\n        descriptor.outputType,\n        Boolean(descriptor.clientStreaming),\n        Boolean(descriptor.serverStreaming),\n        fromDescriptorOptions(descriptor.options, exports.MethodOptions)\n    );\n};\n\n/**\n * Converts a method to a descriptor.\n * @returns {Message<IMethodDescriptorProto>} Descriptor\n */\nMethod.prototype.toDescriptor = function toDescriptor() {\n    return exports.MethodDescriptorProto.create({\n        name: this.name,\n        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\n        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\n        clientStreaming: this.requestStream,\n        serverStreaming: this.responseStream,\n        options: toDescriptorOptions(this.options, exports.MethodOptions)\n    });\n};\n\n// --- utility ---\n\n// Converts a descriptor type to a protobuf.js basic type\nfunction fromDescriptorType(type) {\n    switch (type) {\n        // 0 is reserved for errors\n        case 1: return \"double\";\n        case 2: return \"float\";\n        case 3: return \"int64\";\n        case 4: return \"uint64\";\n        case 5: return \"int32\";\n        case 6: return \"fixed64\";\n        case 7: return \"fixed32\";\n        case 8: return \"bool\";\n        case 9: return \"string\";\n        case 12: return \"bytes\";\n        case 13: return \"uint32\";\n        case 15: return \"sfixed32\";\n        case 16: return \"sfixed64\";\n        case 17: return \"sint32\";\n        case 18: return \"sint64\";\n    }\n    throw Error(\"illegal type: \" + type);\n}\n\n// Tests if a descriptor type is packable\nfunction packableDescriptorType(type) {\n    switch (type) {\n        case 1: // double\n        case 2: // float\n        case 3: // int64\n        case 4: // uint64\n        case 5: // int32\n        case 6: // fixed64\n        case 7: // fixed32\n        case 8: // bool\n        case 13: // uint32\n        case 14: // enum (!)\n        case 15: // sfixed32\n        case 16: // sfixed64\n        case 17: // sint32\n        case 18: // sint64\n            return true;\n    }\n    return false;\n}\n\n// Converts a protobuf.js basic type to a descriptor type\nfunction toDescriptorType(type, resolvedType) {\n    switch (type) {\n        // 0 is reserved for errors\n        case \"double\": return 1;\n        case \"float\": return 2;\n        case \"int64\": return 3;\n        case \"uint64\": return 4;\n        case \"int32\": return 5;\n        case \"fixed64\": return 6;\n        case \"fixed32\": return 7;\n        case \"bool\": return 8;\n        case \"string\": return 9;\n        case \"bytes\": return 12;\n        case \"uint32\": return 13;\n        case \"sfixed32\": return 15;\n        case \"sfixed64\": return 16;\n        case \"sint32\": return 17;\n        case \"sint64\": return 18;\n    }\n    if (resolvedType instanceof Enum)\n        return 14;\n    if (resolvedType instanceof Type)\n        return resolvedType.group ? 10 : 11;\n    throw Error(\"illegal type: \" + type);\n}\n\n// Converts descriptor options to an options object\nfunction fromDescriptorOptions(options, type) {\n    if (!options)\n        return undefined;\n    var out = [];\n    for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)\n        if ((key = (field = type._fieldsArray[i]).name) !== \"uninterpretedOption\")\n            if (options.hasOwnProperty(key)) { // eslint-disable-line no-prototype-builtins\n                val = options[key];\n                if (field.resolvedType instanceof Enum && typeof val === \"number\" && field.resolvedType.valuesById[val] !== undefined)\n                    val = field.resolvedType.valuesById[val];\n                out.push(underScore(key), val);\n            }\n    return out.length ? $protobuf.util.toObject(out) : undefined;\n}\n\n// Converts an options object to descriptor options\nfunction toDescriptorOptions(options, type) {\n    if (!options)\n        return undefined;\n    var out = [];\n    for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {\n        val = options[key = ks[i]];\n        if (key === \"default\")\n            continue;\n        var field = type.fields[key];\n        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))\n            continue;\n        out.push(key, val);\n    }\n    return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;\n}\n\n// Calculates the shortest relative path from `from` to `to`.\nfunction shortname(from, to) {\n    var fromPath = from.fullName.split(\".\"),\n        toPath = to.fullName.split(\".\"),\n        i = 0,\n        j = 0,\n        k = toPath.length - 1;\n    if (!(from instanceof Root) && to instanceof Namespace)\n        while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {\n            var other = to.lookup(fromPath[i++], true);\n            if (other !== null && other !== to)\n                break;\n            ++j;\n        }\n    else\n        for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);\n    return toPath.slice(j).join(\".\");\n}\n\n// copied here from cli/targets/proto.js\nfunction underScore(str) {\n    return str.substring(0,1)\n         + str.substring(1)\n               .replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) { return \"_\" + $1.toLowerCase(); });\n}\n\n// --- exports ---\n\n/**\n * Reflected file descriptor set.\n * @name FileDescriptorSet\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file descriptor proto.\n * @name FileDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected descriptor proto.\n * @name DescriptorProto\n * @type {Type}\n * @property {Type} ExtensionRange\n * @property {Type} ReservedRange\n * @const\n * @tstype $protobuf.Type & {\n *     ExtensionRange: $protobuf.Type,\n *     ReservedRange: $protobuf.Type\n * }\n */\n\n/**\n * Reflected field descriptor proto.\n * @name FieldDescriptorProto\n * @type {Type}\n * @property {Enum} Label\n * @property {Enum} Type\n * @const\n * @tstype $protobuf.Type & {\n *     Label: $protobuf.Enum,\n *     Type: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof descriptor proto.\n * @name OneofDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum descriptor proto.\n * @name EnumDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service descriptor proto.\n * @name ServiceDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value descriptor proto.\n * @name EnumValueDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method descriptor proto.\n * @name MethodDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file options.\n * @name FileOptions\n * @type {Type}\n * @property {Enum} OptimizeMode\n * @const\n * @tstype $protobuf.Type & {\n *     OptimizeMode: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected message options.\n * @name MessageOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected field options.\n * @name FieldOptions\n * @type {Type}\n * @property {Enum} CType\n * @property {Enum} JSType\n * @const\n * @tstype $protobuf.Type & {\n *     CType: $protobuf.Enum,\n *     JSType: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof options.\n * @name OneofOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum options.\n * @name EnumOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value options.\n * @name EnumValueOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service options.\n * @name ServiceOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method options.\n * @name MethodOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected uninterpretet option.\n * @name UninterpretedOption\n * @type {Type}\n * @property {Type} NamePart\n * @const\n * @tstype $protobuf.Type & {\n *     NamePart: $protobuf.Type\n * }\n */\n\n/**\n * Reflected source code info.\n * @name SourceCodeInfo\n * @type {Type}\n * @property {Type} Location\n * @const\n * @tstype $protobuf.Type & {\n *     Location: $protobuf.Type\n * }\n */\n\n/**\n * Reflected generated code info.\n * @name GeneratedCodeInfo\n * @type {Type}\n * @property {Type} Annotation\n * @const\n * @tstype $protobuf.Type & {\n *     Annotation: $protobuf.Type\n * }\n */\n"],"names":["__createBinding","o","m","k","k2","desc","__exportStar","exports","p","crc32GenerateTables","polynomial","numTables","table","i","r","value","CRC32_TABLE","prev","data","byteLength","view","offset","toAlign","remainingBytes","r2","__generator","thisArg","body","_","t","f","y","g","verb","n","v","step","op","e","__read","ar","error","__spreadArray","to","from","pack","l","toInt","Heap","compare","_this","a","b","idx","whichChildren","heap","deep","pi","repeat","str","times","out","node","lines","maxLines","maxLength","nodeText","line","el","half","arr","heapArr","item","iterable","element","elements","_a","result","j","ch","cloned","fn","array","_l","last","_i","peek","rm","bottomHeap","startAt","parentStartAt","indices","moveIt","self","getPotentialParent","best","childrenIdx","bestChildIndex","bestChild","topHeap","heapArray","branch","list","top","comp","getBigUint64","littleEndian","lo","hi","Reader","length","readKey","readValue","endOffset","err","key","existingValue","Opcode","isKnownOpcode","opcode","parseMagic","startOffset","val","parseRecord","validateCrcs","headerReader","recordLength","recordEndOffset","recordView","reader","profile","library","summaryStart","summaryOffsetStart","summaryCrc","id","name","encoding","dataLen","channelId","schemaId","topicName","messageEncoding","metadata","sequence","logTime","publishTime","startTime","endTime","uncompressedSize","uncompressedCrc","compression","recordByteLength","records","messageStartTime","messageEndTime","chunkStartOffset","chunkLength","messageIndexOffsets","messageIndexLength","compressedSize","createTime","mediaType","crcLength","expectedCrc","actualCrc","dataSize","messageCount","schemaCount","channelCount","attachmentCount","metadataCount","chunkCount","channelMessageCounts","groupOpcode","groupStart","groupLength","sortedIndexBy","iteratee","low","high","computedValue","mid","ChunkCursor","params","other","diff","cursor","record","nextRecord","readable","reverse","logTimeA","logTimeB","messageIndexStartOffset","relevantMessageIndexStartOffset","messageIndexEndOffset","messageIndexes","messageIndexesView","startIndex","McapIndexedReader","args","chunk","attachment","message","decompressHandlers","size","header","headerPrefix","headerPrefixView","headerLength","headerRecord","headerResult","errorWithLibrary","footerOffset","footerAndMagicView","headerLengthLowerBound","footerAndMagicReadLength","footerBuffer","footer","footerResult","footerPrefix","allSummaryData","indexView","channelsById","schemasById","chunkIndexes","attachmentIndexes","metadataIndexes","summaryOffsetsByOpcode","statistics","topics","relevantChannels","channel","chunkCursors","chunkIndex","chunkViewCache","chunkView","metadataIndex","metadataData","metadataResult","attachmentIndex","attachmentData","attachmentResult","chunkData","chunkResult","buffer","decompress","chunkCrc","StreamBuffer","initialCapacity","count","oldData","McapStreamReader","includeChunks","noMagicPrefix","existing","isChannelEqual","magic","usedBytes","chunkOffset","keyA","valueA","valueB","options","startPosition","endPosition","schema","info","crcStartPosition","messageIndex","messageIndexRecordsByteLength","summaryOffset","dataEnd","useMessageIndex","McapWriter","writable","useStatistics","useSummaryOffsets","useChunks","repeatSchemas","repeatChannels","useAttachmentIndex","useMetadataIndex","useChunkIndex","startChannelId","chunkSize","compressChunk","summaryOffsets","schemaStart","schemaLength","channelStart","channelLength","statisticsStart","statisticsLength","metadataIndexStart","metadataIndexLength","attachmentIndexStart","attachmentIndexLength","chunkIndexStart","chunkIndexLength","summaryLength","tempBuffer","recordSize","compressedData","chunkRecord","messageIndexStart","hasMcapPrefix","prefix","BaseType","AdvancedFeatures","Type","bb","obj","flatbuffers","builder","baseType","index","fixedLength","baseSize","elementSize","TypeT","_o","KeyValue","optionalEncoding","keyOffset","valueOffset","KeyValueT","EnumVal","nameOffset","unionTypeOffset","documentationOffset","numElems","EnumValT","unionType","documentation","Enum","valuesOffset","isUnion","underlyingTypeOffset","attributesOffset","declarationFileOffset","EnumT","values","underlyingType","attributes","declarationFile","Field","typeOffset","defaultInteger","defaultReal","deprecated","required","optional","padding","FieldT","type","Object_","fieldsOffset","isStruct","minalign","bytesize","ObjectT","fields","RPCCall","requestOffset","responseOffset","RPCCallT","request","response","Service","callsOffset","ServiceT","calls","SchemaFile","filenameOffset","includedFilenamesOffset","SchemaFileT","filename","includedFilenames","Schema","objectsOffset","enumsOffset","fileIdentOffset","fileExtOffset","rootTableOffset","servicesOffset","advancedFeatures","fbsFilesOffset","SchemaT","objects","enums","fileIdent","fileExt","rootTable","services","fbsFiles","typeSize","isScalar","isInteger","Table","typeIndex","offsetToVtable","vtableOffset","vtableMinSize","vtableActualSize","objectSize","ii","schemaObject","fieldType","Parser","readDefaults","lambdas","numFields","field","fieldName","rawLambda","subTableLambda","subTable","elementType","vectorLambda","vector","offsetToOffset","parentIsStruct","elementIsStruct","objectStart","isUByteVector","numElements","baseOffset","scalarSize","elementSchema","elementOffset","offsetSize","$protobuf","module","Namespace","Root","MapField","OneOf","Method","descriptor","root","fileDescriptor","filePackage","opts","fromDescriptorOptions","ks","syntax","set","Root_toDescriptorRecursive","ns","files","file","nested","toDescriptorOptions","unnamedMessageIndex","fieldDescriptor","keyType","toDescriptorType","valueType","valueTypeName","shortname","numberRe","fromDescriptorType","fieldRule","extendee","defaultValue","match","packableDescriptorType","unnamedEnumIndex","unnamedOneofIndex","unnamedServiceIndex","service","methods","unnamedMethodIndex","resolvedType","underScore","fromPath","toPath","$0","$1"],"sourceRoot":""}