(()=>{var te={93986:(c,y,p)=>{"use strict";var P=p(80144),e=p.n(P);function S(t,n){const r=[];let o=0;for(const s of t){const a=n(s,o++);a&&r.push(a)}return r}const N=[e().factory.createModifier(e().SyntaxKind.ExportKeyword),e().factory.createModifier(e().SyntaxKind.DeclareKeyword)],b=(t,n)=>e().factory.createPropertySignature(void 0,t,void 0,n),O=t=>e().factory.createInterfaceDeclaration(N,t,void 0,void 0,[b("sec",e().factory.createKeywordTypeNode(e().SyntaxKind.NumberKeyword)),b("nsec",e().factory.createKeywordTypeNode(e().SyntaxKind.NumberKeyword))]),B=e().factory.createInterfaceDeclaration(N,"json",void 0,void 0,[]),W=t=>t.replace(/\//g,"__"),he=new Map([["uint8",e().SyntaxKind.NumberKeyword],["int8",e().SyntaxKind.NumberKeyword],["uint16",e().SyntaxKind.NumberKeyword],["int16",e().SyntaxKind.NumberKeyword],["uint32",e().SyntaxKind.NumberKeyword],["int32",e().SyntaxKind.NumberKeyword],["float32",e().SyntaxKind.NumberKeyword],["float64",e().SyntaxKind.NumberKeyword],["int64",e().SyntaxKind.NumberKeyword],["uint64",e().SyntaxKind.NumberKeyword],["string",e().SyntaxKind.StringKeyword],["bool",e().SyntaxKind.BooleanKeyword]]),we=new Map([["uint8","Uint8Array"],["int8","Int8Array"]]),ne=O("Time"),j=O("Duration"),Se=new Map([["time",ne],["duration",j]]),oe=t=>{const n={};for(const[r,o]of t){if(r.includes(".")||n[r])continue;const s=S(o.definitions,({name:a,type:u,isArray:d,isConstant:i})=>{let h;const x=we.get(u),C=he.get(u),K=Se.get(u);if(i!==!0)return d===!0&&x!=null?h=e().factory.createTypeReferenceNode(x):C!=null?h=e().factory.createKeywordTypeNode(C):K?h=e().factory.createTypeReferenceNode(K.name):h=e().factory.createTypeReferenceNode(W(u)),d===!0&&x==null&&(h=e().factory.createArrayTypeNode(h)),b(a,h)});n[r]=e().factory.createInterfaceDeclaration([e().factory.createModifier(e().SyntaxKind.ExportKeyword)],W(r),void 0,void 0,s)}return n},xe=({topics:t,datatypes:n})=>{let r=e().factory.createInterfaceDeclaration(N,"TopicsToMessageDefinition",void 0,void 0,[]);const o=e().factory.createInterfaceDeclaration(N,"Input",[e().factory.createTypeParameterDeclaration([],"T",e().factory.createTypeOperatorNode(e().SyntaxKind.KeyOfKeyword,e().factory.createTypeReferenceNode(r.name)))],void 0,[b("topic",e().factory.createTypeReferenceNode("T")),b("receiveTime",e().factory.createTypeReferenceNode("Time")),b("message",e().factory.createTypeReferenceNode("TopicsToMessageDefinition[T]"))]),s="Messages";let a=oe(n);t.forEach(({name:x,schemaName:C})=>{C!=null&&(a[C]||(a={...a,...oe(new Map(Object.entries({[C]:{definitions:[]}})))}),r=e().factory.updateInterfaceDeclaration(r,N,r.name,void 0,void 0,[...r.members,b(e().factory.createStringLiteral(x),e().factory.createTypeReferenceNode(`${s}.${W(C)}`))]))});const u=e().factory.createModuleDeclaration(N,e().factory.createIdentifier(s),e().factory.createModuleBlock(Object.values(a).map(x=>x)),e().NodeFlags.Namespace),d=e().createSourceFile("","",e().ScriptTarget.Latest,!1,e().ScriptKind.TS),i=e().createPrinter();return`
    ${i.printNode(e().EmitHint.Unspecified,B,d)}
    ${i.printNode(e().EmitHint.Unspecified,r,d)}
    ${i.printNode(e().EmitHint.Unspecified,j,d)}
    ${i.printNode(e().EmitHint.Unspecified,ne,d)}

    /**
     * This type contains every message declaration in your bag, so that you can
     * refer to the type "std_msgs/RGBA" as "std_msgs__RGBA" wherever you like.
     */
    ${i.printNode(e().EmitHint.Unspecified,u,d)}

    /**
     * To correctly type your inputs, you use this type to refer to specific
     * input topics, e.g. 'Input<"/your_input_topic">'. If you have
     * multiple input topics, use a union type, e.g.
     * 'Input<"/your_input_topic_1"> |
     * Input<"/your_input_topic_2">'.
     *
     * These types are dynamically generated from the bag(s) currently in your
     * Foxglove Studio session, so if a datatype changes, your User Script
     * may not compile on the newly formatted bag.
     */
    ${i.printNode(e().EmitHint.Unspecified,o,d)}
  `},l={Hint:1,Info:2,Warning:4,Error:8},T={Typescript:"Typescript",DatatypeExtraction:"DatatypeExtraction",InputTopicsChecker:"InputTopicsChecker",OutputTopicChecker:"OutputTopicChecker",Runtime:"Runtime"},m={RUNTIME:1,DatatypeExtraction:{NO_DEFAULT_EXPORT:1,NON_FUNC_DEFAULT_EXPORT:2,NO_TYPE_RETURN:3,BAD_TYPE_RETURN:4,UNKNOWN_ERROR:5,NO_UNIONS:6,NO_FUNCTIONS:7,NO_CLASSES:8,NO_TYPE_LITERALS:9,NO_TUPLES:10,NO_INTERSECTION_TYPES:11,NO_TYPEOF:12,PREFER_ARRAY_LITERALS:13,STRICT_MARKERS_RETURN_TYPE:14,LIMITED_UNIONS:15,NO_NESTED_ANY:16,NO_MAPPED_TYPES:17,INVALID_PROPERTY:18,INVALID_INDEXED_ACCESS:19},InputTopicsChecker:{NO_TOPIC_AVAIL:1,NO_INPUTS_EXPORT:2,EMPTY_INPUTS_EXPORT:3,BAD_INPUTS_TYPE:4},OutputTopicChecker:{NO_OUTPUTS:1,NOT_UNIQUE:2,EXISTING_TOPIC:3}},se={severity:l.Error,message:"No 'default export' function found.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.NO_DEFAULT_EXPORT},ie={severity:l.Error,message:"The 'default export' must be assigned to a function.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.NON_FUNC_DEFAULT_EXPORT},F={severity:l.Error,message:"The 'default export' function must return an object type with at least one property.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.BAD_TYPE_RETURN},Ne={severity:l.Error,message:"The 'default export' function can only return union types of the form: 'YourType | undefined'.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.LIMITED_UNIONS},be={severity:l.Error,message:"Unions are not allowed in return type.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.NO_UNIONS},ae={severity:l.Error,message:"Functions are not allowed as or in the return type.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.NO_FUNCTIONS},_e={severity:l.Error,message:"Type literals are not allowed as or in the return type.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.NO_TYPE_LITERALS},ce={severity:l.Error,message:"Type intersections are not allowed as or in the return type.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.NO_INTERSECTION_TYPES},Ie={severity:l.Error,message:"Please use array literal syntax (e.g. 'number[]') instead of the 'Array<number>'.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.PREFER_ARRAY_LITERALS},G={severity:l.Error,message:"Classes are not allowed as or in the return type.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.NO_CLASSES},Pe={severity:l.Error,message:"'typeof' cannot be used as or in the return type",source:T.DatatypeExtraction,code:m.DatatypeExtraction.NO_TYPEOF},ve={severity:l.Error,message:"Tuples are not allowed as types.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.NO_TUPLES},De={severity:l.Error,message:"Cannot nest 'any' in the return type.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.NO_NESTED_ANY},Oe={severity:l.Error,message:"MappedTypes such as Record<Keys,Type> are not supported.",source:T.DatatypeExtraction,code:m.DatatypeExtraction.NO_MAPPED_TYPES},ue=100;class E extends Error{diagnostic;constructor(n){super(),this.diagnostic=n}}const Ce=(t,n)=>e().forEachChild(t,r=>{if(n.includes(r.kind))return r}),U=(t,n)=>{for(const r of t.declarations??[])if(n.includes(r.kind))return r},Re=(t,n,r)=>{const o=z(n);if(!o)return;const s=t.getDeclaredTypeOfSymbol(o);return U(s.symbol??s.aliasSymbol,r)},pe=(t=[],n)=>{const r={};for(let o=0;o<t.length;o++){const s=t[o];s&&(r[s.name.escapedText.toString()]={current:s,parent:n[o]??{parent:void 0,current:s.default}})}return r},Ke=(t=[],n)=>{const r={};return t.forEach((o,s)=>{const a=o.getText(),u=n[a]??n[s],d=o;r[s]={current:d,parent:u}}),r},de=t=>t.getSourceFile().fileName.endsWith("ros/index.d.ts");function z(t){return t?.symbol}const ke=(t,n)=>{const r=z(t);if(!r)return;const o=n.getExportsOfModule(r).find(d=>d.escapedName==="default");if(!o)throw new E(se);const s=U(o,[e().SyntaxKind.FunctionDeclaration]);if(s)return s;const a=U(o,[e().SyntaxKind.ExportAssignment]);if(!a)throw new E(se);const u=Ce(a,[e().SyntaxKind.FunctionDeclaration,e().SyntaxKind.FunctionExpression,e().SyntaxKind.ArrowFunction,e().SyntaxKind.Identifier]);if(!u)throw new E(ie);return u},Ae=(t,n)=>{const o=t.getTypeAtLocation(n).getCallSignatures(),s=o[0];if(o.length!==1||!s)throw new E(ie);const u=t.getReturnTypeOfSignature(s).getNonNullableType();if(u.isIntersection())throw new E(ce);if(u.isClass())throw new E(G);if(u.isUnion())throw new E(Ne);const d=u.getSymbol();if(!d)throw new E(F);if(!d.declarations||d.declarations.length===0)throw new E(F);let i;if(d.declarations.length===1?i=d.declarations[0]:i=d.declarations.filter(h=>h.kind===e().SyntaxKind.InterfaceDeclaration)[0],!i)throw new E(F);if(e().isTypeLiteralNode(i))return i;if(e().isInterfaceDeclaration(i))return i;throw e().isMappedTypeNode(i)?new E(Oe):e().isClassDeclaration(i)?new E(G):e().isFunctionLike(i)?new E(ae):new E(F)},fe=(t,n,r,o,s,a=1,u={})=>{if(a>ue)throw new Error("Max AST traversal depth exceeded.");const d=e().isInterfaceDeclaration(n)?n.name.text:void 0,i=d!=null?o[d]:void 0;if(de(n)&&i!=null)return{outputDatatype:i,datatypes:s};if(n.getSourceFile().fileName==="/studio_script/generatedTypes.ts"&&e().isPropertySignature(n.parent)&&e().isStringLiteral(n.parent.name))return{outputDatatype:n.parent.name.text,datatypes:s};let h=new Map;const x=(w,D,R=!1,k=!1,g={},_=1)=>{if(_>ue)throw new Error("Max AST traversal depth exceeded.");switch(D.kind){case e().SyntaxKind.InterfaceDeclaration:case e().SyntaxKind.TypeLiteral:{const I=D,v=z(D)?.name,A=v!=null?o[v]:void 0,M=de(I)&&A!=null?A:`${r}/${w}`,L=e().isInterfaceDeclaration(D)?pe(D.typeParameters,g):g,{datatypes:Ee}=fe(t,I,M,o,s,a+1,L),Q=Ee.get(M)?.definitions??[];if(Q.length===2){const Z=Q.find(ee=>ee.name==="sec"),q=Q.find(ee=>ee.name==="nsec");if(Z&&q&&Z.isComplex!==!0&&q.isComplex!==!0&&Z.isArray!==!0&&q.isArray!==!0)return{name:w,type:"time",isArray:!1,isComplex:!1,arrayLength:void 0}}return h=new Map([...h,...Ee]),{name:w,type:M,isArray:R,isComplex:!0,arrayLength:void 0}}case e().SyntaxKind.ArrayType:return x(w,D.elementType,!0,!0,g,_+1);case e().SyntaxKind.BigIntKeyword:return{name:w,type:"int64",isArray:R,isComplex:k,arrayLength:void 0};case e().SyntaxKind.NumberKeyword:return{name:w,type:"float64",isArray:R,isComplex:k,arrayLength:void 0};case e().SyntaxKind.StringKeyword:return{name:w,type:"string",isArray:R,isComplex:k,arrayLength:void 0};case e().SyntaxKind.BooleanKeyword:return{name:w,type:"bool",isArray:R,isComplex:k,arrayLength:void 0};case e().SyntaxKind.TypeAliasDeclaration:{const I=D,v=pe(I.typeParameters,g);return x(w,I.type,R,k,v,_+1)}case e().SyntaxKind.TypeReference:{const I=D,v=t.getSymbolAtLocation(I.typeName);if(v?.escapedName==="Array")throw new E(Ie);if(!v)throw new Error("Could not find symbol");const A=U(v,[e().SyntaxKind.TypeParameter]);if(A){if(g[A.name.escapedText.toString()]){let L=g[A.name.escapedText.toString()];for(;L?.parent;)L=L.parent;return x(w,L.current,R,k,g,_+1)}throw new Error(`Could not find type ${A.getText()} in type map.`)}const M=U(v,[e().SyntaxKind.TypeAliasDeclaration,e().SyntaxKind.InterfaceDeclaration,e().SyntaxKind.ImportSpecifier,e().SyntaxKind.ClassDeclaration]);if(!M)throw new Error("Could not find next node");return x(w,M,R,k,Ke(I.typeArguments,g),_+1)}case e().SyntaxKind.TypeQuery:throw new E(Pe);case e().SyntaxKind.ImportSpecifier:{const I=Re(t,D,[e().SyntaxKind.TypeLiteral,e().SyntaxKind.InterfaceDeclaration,e().SyntaxKind.TypeAliasDeclaration]);if(!I)throw new Error("Failed to find import declaration");return x(w,I,R,k,g,_+1)}case e().SyntaxKind.IntersectionType:throw new E(ce);case e().SyntaxKind.TupleType:throw new E(ve);case e().SyntaxKind.StringLiteral:case e().SyntaxKind.NumericLiteral:case e().SyntaxKind.LiteralType:throw new E(_e);case e().SyntaxKind.ClassDeclaration:throw new E(G);case e().SyntaxKind.UnionType:throw new E(be);case e().SyntaxKind.FunctionType:throw new E(ae);case e().SyntaxKind.AnyKeyword:throw new E(De);default:{const v=t.getTypeAtLocation(D).symbol;if(v==null)throw new E({severity:l.Error,message:`Unsupported type for member '${w}'.`,source:T.DatatypeExtraction,code:m.DatatypeExtraction.BAD_TYPE_RETURN});const A=v.declarations?.[0];if(v.declarations?.length!==1||!A)throw new E(F);return x(w,A,!1,void 0,g,_+1)}}},{members:C=[]}=n,K=C.map(w=>{if(!w.name)throw new E({severity:l.Error,message:`Encountered type member with no name in ${d??r}`,source:T.DatatypeExtraction,code:m.DatatypeExtraction.INVALID_PROPERTY});if(!e().isPropertySignature(w))throw new E({severity:l.Error,message:`Unexpected type member (kind ${w.kind}) in ${d??r}`,source:T.DatatypeExtraction,code:m.DatatypeExtraction.INVALID_PROPERTY});if(!w.type)throw new E({severity:l.Error,message:`Member ${w.name.getText()} has no type in ${d??r}`,source:T.DatatypeExtraction,code:m.DatatypeExtraction.INVALID_PROPERTY});return x(w.name.getText(),w.type,!1,!1,u,a+1)});return{outputDatatype:r,datatypes:new Map([...h,...new Map([[r,{definitions:K}]])])}};var Me=p(64942);const Le=t=>{switch(t){case e().DiagnosticCategory.Error:return l.Error;case e().DiagnosticCategory.Warning:return l.Warning;case e().DiagnosticCategory.Message:return l.Info;case e().DiagnosticCategory.Suggestion:return l.Hint;default:throw new Error("Diagnostic category not recognized")}},Fe=t=>{if(!t.file||t.start==null||t.length==null)throw new Error("Invariant: diagnostic is not initialized");const{line:n,character:r}=t.file.getLineAndCharacterOfPosition(t.start),{line:o,character:s}=t.file.getLineAndCharacterOfPosition(t.start+t.length);return{message:le(t.messageText,`
`),severity:Le(t.category),source:"Typescript",startLineNumber:n,startColumn:r,endLineNumber:o,endColumn:s,code:t.code}};function le(t,n,r=0){if(typeof t=="string")return t;if(t==null)return"";let o="";if(r>0){o+=n;for(let s=0;s<r;s++)o+="  "}if(o+=t.messageText,t.next)for(const s of t.next)o+=le(s,n,r+1);return o}const ye={strict:!0,target:e().ScriptTarget.ES2022,module:e().ModuleKind.CommonJS};var Ue=p(11701);const Ye=`type MessageTypeByTopic = {
  // placeholder
};
type MessageTypeBySchemaName = {
  // placeholder
};

export type { MessageTypeByTopic, MessageTypeBySchemaName };
`,ge=t=>t.diagnostics.some(({severity:n})=>n===l.Error),$e=t=>{const{sourceFile:n,typeChecker:r}=t;if(!n||!r){const i={severity:l.Error,message:"Either the 'sourceFile' or 'typeChecker' is absent. There is a problem with the `compile` step.",source:T.InputTopicsChecker,code:m.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,i]}}const o=r.getSymbolAtLocation(n);if(!o){const i={severity:l.Error,message:"Must export an input topics array. E.g. 'export const inputs = ['/some_topics']'",source:T.InputTopicsChecker,code:m.InputTopicsChecker.NO_INPUTS_EXPORT};return{...t,diagnostics:[...t.diagnostics,i]}}const s=r.getExportsOfModule(o).find(i=>i.escapedName==="inputs");if(!s){const i={severity:l.Error,message:"Must export a non-empty inputs array.",source:T.InputTopicsChecker,code:m.InputTopicsChecker.EMPTY_INPUTS_EXPORT};return{...t,diagnostics:[...t.diagnostics,i]}}const a=s.declarations?.[0];if(!a||!e().isVariableDeclaration(a)){const i={severity:l.Error,message:"inputs export must be an array variable.",source:T.InputTopicsChecker,code:m.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,i]}}if(!a.initializer||!e().isArrayLiteralExpression(a.initializer)){const i={severity:l.Error,message:"inputs export must be an array variable.",source:T.InputTopicsChecker,code:m.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,i]}}const u=a.initializer.elements;if(u.some(({kind:i})=>i!==e().SyntaxKind.StringLiteral)){const i={severity:l.Error,message:"The exported 'inputs' variable must be an array of string literals. E.g. 'export const inputs = ['/some_topics']'",source:T.InputTopicsChecker,code:m.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,i]}}const d=S(u,i=>{if(e().isStringLiteral(i))return i.text});if(d.length===0){const i={severity:l.Error,message:'Must include non-empty inputs array, e.g. export const inputs = ["/some_input_topic"];',source:T.InputTopicsChecker,code:m.InputTopicsChecker.EMPTY_INPUTS_EXPORT};return{...t,diagnostics:[...t.diagnostics,i]}}return{...t,inputTopics:d}},Be=t=>{const n=/^\s*export\s+const\s+output\s*=\s*("([^"]+)"|'([^']+)')/gm.exec(t.sourceCode),r=n?.[2]??n?.[3];if(r==null){const o={severity:l.Error,message:`Must include an output, e.g. export const output = "${Ue.wd}your_output_topic";`,source:T.OutputTopicChecker,code:m.OutputTopicChecker.NO_OUTPUTS};return{...t,diagnostics:[...t.diagnostics,o]}}return{...t,outputTopic:r}},We=(t,n)=>{const{inputTopics:r}=t,o=n.map(({name:a})=>a),s=[];for(const a of r)o.includes(a)||s.push({severity:l.Error,message:`Input "${a}" is not yet available`,source:T.InputTopicsChecker,code:m.InputTopicsChecker.NO_TOPIC_AVAIL});return{...t,diagnostics:[...t.diagnostics,...s]}},je=t=>{const{sourceCode:n,rosLib:r,typesLib:o}=t,s=ye,a="/studio_script/index.ts",u=(0,Me.v)(),d=new Map,i=new Map;i.set(a,n),i.set(u.rosLib.filePath,r),i.set("/studio_script/generatedTypes.ts",o||Ye),u.utilityFiles.forEach(g=>i.set(g.filePath,g.sourceCode)),u.declarations.forEach(g=>i.set(g.filePath,g.sourceCode));let h="",x=!1;const C={getDefaultLibFileName:()=>u.defaultLibFileName,getCurrentDirectory:()=>"",getCanonicalFileName:g=>g,useCaseSensitiveFileNames:()=>!1,readFile:()=>{},fileExists:g=>{for(const[_]of i.entries())if(g===_||g.endsWith(_))return!0;return!1},writeFile:(g,_)=>{x=!0,g==="/studio_script/index.js"?h=_:d.set(g,_)},getNewLine:()=>`
`,getSourceFile:g=>{let _="";for(const[I,v]of i.entries())if(g===I||g.endsWith(I)){_=v;break}return e().createSourceFile(g,_,ye.target,!0)}},K=e().createProgram([a],s,C);if(K.emit(),!x){const g={severity:l.Error,message:"Program code was not emitted.",source:T.InputTopicsChecker,code:m.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,g]}}const D=[...K.getSemanticDiagnostics(),...K.getSyntacticDiagnostics()].map(Fe),R=K.getSourceFile(a),k=K.getTypeChecker();return{...t,sourceFile:R,typeChecker:k,transpiledCode:h,projectCode:d,diagnostics:[...t.diagnostics,...D]}},He=t=>{if(ge(t))return t;const{sourceFile:n}=t;if(!n)throw new Error("'sourceFile' is absent'. There is a problem with the `compile` step.");const r=n.forEachChild(s=>{if(e().isTypeAliasDeclaration(s)&&e().isTypeLiteralNode(s.type)&&s.name.text==="GlobalVariables")return s.type.members;if(e().isInterfaceDeclaration(s)&&s.name.text==="GlobalVariables")return s.members}),o=S(r??[],s=>{if(s.name&&(e().isIdentifier(s.name)||e().isStringLiteral(s.name)))return s.name.text});return{...t,globalVariables:o}},Ve=t=>{if(ge(t))return t;const{sourceFile:n,typeChecker:r,name:o,datatypes:s}=t;if(!n||!r)throw new Error("Either the 'sourceFile' or 'typeChecker' is absent'. There is a problem with the `compile` step.");const a={};for(const u of s.keys())a[W(u)]=u;try{const u=ke(n,r);if(!u)throw new Error("Your node must default export a function");const d=Ae(r,u),{outputDatatype:i,datatypes:h}=fe(r,d,o,a,s);return{...t,datatypes:h,outputDatatype:i}}catch(u){return u instanceof E?{...t,diagnostics:[...t.diagnostics,u.diagnostic]}:{...t,diagnostics:[...t.diagnostics,{message:u.message,severity:l.Error,source:T.DatatypeExtraction,code:m.DatatypeExtraction.UNKNOWN_ERROR}]}}},Xe=(...t)=>(n,r)=>{let o=n;for(const s of t)o=s(o,r);return o},Ge=t=>{const{name:n,sourceCode:r,topics:o,rosLib:s,typesLib:a,datatypes:u}=t;return{...Xe(Be,je,$e,We,Ve,He)({name:n,sourceCode:r,rosLib:s,typesLib:a,transpiledCode:"",projectCode:void 0,inputTopics:[],outputTopic:"",outputDatatype:"",diagnostics:[],globalVariables:[],datatypes:u,sourceFile:void 0,typeChecker:void 0},o),sourceFile:void 0,typeChecker:void 0}},Y="$$RESPONSE",J="$$ERROR";function st(){const t={onmessage:void 0,postMessage(r,o){const s=new MessageEvent("message",{data:r});n.onmessage&&n.onmessage(s)},terminate:()=>{}},n={onmessage:void 0,postMessage(r,o){const s=new MessageEvent("message",{data:r});t.onmessage&&t.onmessage(s)},terminate:()=>{}};return{local:t,remote:n}}class H{static transferables="$$TRANSFERABLES";#e;#n=0;#t={};#r=new Map;constructor(n){if(this.#e=n,this.#e.onmessage)throw new Error("channel.onmessage is already set. Can only use one Rpc instance per channel.");this.#e.onmessage=this.#o}#o=n=>{const{id:r,topic:o,data:s}=n.data;if(o===Y){this.#t[r]?.(n.data),delete this.#t[r];return}new Promise(a=>{const u=this.#r.get(o);if(!u)throw new Error(`no receiver registered for ${o}`);a(u(s))}).then(a=>{if(!a)return this.#e.postMessage({topic:Y,id:r});const u=a[H.transferables];delete a[H.transferables];const d={topic:Y,id:r,data:a};this.#e.postMessage(d,u)}).catch(a=>{const u={topic:Y,id:r,data:{[J]:!0,name:a.name,message:a.message,stack:a.stack}};this.#e.postMessage(u)})};terminate(){for(const[n,r]of Object.entries(this.#t))r({topic:Y,id:n,data:{[J]:!0,name:"Error",message:"Rpc terminated",stack:new Error().stack}})}async send(n,r,o){const s=this.#n++,a={topic:n,id:s,data:r},u=new Promise((d,i)=>{this.#t[s]=h=>{if(h.data?.[J]!=null){const x=new Error(h.data.message);x.name=h.data.name,x.stack=h.data.stack,i(x)}else d(h.data)}});return this.#e.postMessage(a,o),await u}receive(n,r){if(this.#r.has(n))throw new Error(`Receiver already registered for topic: ${n}`);this.#r.set(n,r)}}const Te=p.g;function ze(t){Te.foxgloveStudioReportErrorFn?.(t)}function it(t){Te.foxgloveStudioReportErrorFn=t}class Je extends Error{details;extraInfo;message;constructor(n,r){if(super(),this.details=n,this.extraInfo=r,this.name="AppError",this.message="",n instanceof Error?this.message=n.stack??n.message:typeof n=="string"&&(this.message=n),r!=null)if(r.componentStack!=null)this.message+=`

${r.componentStack}`;else try{const o=JSON.stringify(r);this.message+=`

${o}`}catch{this.message+=`

[ Either cyclic object or object with BigInt(s) ]`}this.message===""&&(this.message="Unknown Error")}}const Qe=()=>typeof p.g.postMessage<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,Ze=()=>typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope,qe=t=>{const n=typeof fetch<"u"&&fetch("data:test").then(()=>!0).catch(()=>!1);return async(...r)=>{if(await n)throw new Error("Content security policy too loose.");return t(...r)}},V=(t,n,r,o)=>{if(Qe()){(o==="error"?console.error:o==="warn"?console.warn:console.info)("Web Worker has uninitialized sendNotification function; this means this error message cannot show up in the UI (so we show it here in the console instead).",t,n,r);return}console.error("Notification before error display is mounted",t,n,r)};let $=V;function et(t){if($!==V)throw new Error("Tried to overwrite existing NotificationHandler");$=t}function at(){if($===V)throw new Error("Tried to unset NotificationHandler but it was already the default");$=V}function tt(t,n,r,o){r==="app"&&(o==="warn"||o==="error")&&ze(new Je(n,t)),$(t,n,r,o)}tt.expectCalledDuringTest=()=>{throw new Error("Should be overriden in setupTestFramework.ts")};function me(t){et((n,r,o,s)=>{r instanceof Error||typeof r=="string"||console.warn("Invalid Error type",r),t.send("sendNotification",{message:n,details:r instanceof Error?r.toString():r,type:o,severity:s})})}function ct(t){me(t),overwriteFetch()}let X=[];if(p.g.onerror=t=>{X.push(t.error.toString())},p.g.onunhandledrejection=t=>{X.push(String(t.reason instanceof Error?t.reason.message:t.reason))},!Ze())throw new Error("Not in a SharedWorker.");p.g.onconnect=t=>{const n=t.ports[0];if(!n)throw new Error("NodeTransformWorker connect requires at least 1 message port.");const r=new H(n);X.forEach(async o=>await r.send("error",o)),X=[],p.g.onerror=o=>{r.send("error",o.error.toString())},p.g.onunhandledrejection=o=>{r.send("error",String(o.reason instanceof Error?o.reason.message:o.reason))},me(r),r.receive("close",()=>{p.g.close()}),r.receive("transform",qe(Ge)),r.receive("generateRosLib",xe),n.start()}},23621:(c,y,p)=>{"use strict";p.d(y,{Y:()=>P,k:()=>e});const P="ros/index.d.ts",e=`
  export declare interface Duration {
    sec: number;
    nsec: number;
  }

  export declare interface Time {
    sec: number;
    nsec: number;
  }

  // Once a data source Messages will be populated with interfaces matching the data source messages.
  export declare namespace Messages {}

  // Once a data source TopicsToMessageDefinition will be populated with topic names to message interfaces.
  export declare interface TopicsToMessageDefinition {}

  /**
   * To correctly type your inputs, you use this type to refer to specific
   * input topics, e.g. 'Input<"/your_input_topic">'. If you have
   * multiple input topics, use a union type, e.g.
   * 'Input<"/your_input_topic_1"> |
   * Input<"/your_input_topic_2">'.
   *
   * These types are dynamically generated from the bag(s) currently in your
   * Foxglove Studio session, so if a datatype changes, your User Script
   * may not compile on the newly formatted bag.
   */
  export declare interface Input<T extends keyof TopicsToMessageDefinition> {
    topic: T;
    receiveTime: Time;
    message: TopicsToMessageDefinition[T];
  }

`},11701:(c,y,p)=>{"use strict";p.d(y,{wd:()=>P});const P="/studio_script/";function e(){const{palette:{mode:N,text:b}}=useTheme();return{dark:{base00:"transparent",base0B:"#ffa657",base09:"#7ee787",base07:"#79c0ff",base08:"#ff7b72",base0D:"#79c0ff",base03:b.secondary},light:{base00:"transparent",base0B:"#953800",base09:"#116329",base07:"#0550ae",base08:"#cf222e",base0D:"#0550ae",base03:b.secondary}}[N]}const S="Tab"},63136:(c,y,p)=>{"use strict";p.d(y,{Z:()=>e});const e={nextTick:(S,...N)=>{queueMicrotask(()=>{S(...N)})},title:"browser",browser:!0,env:{},argv:[]}},89424:()=>{},9445:()=>{},70546:()=>{},15490:()=>{},91389:()=>{},9865:()=>{},73860:()=>{},98752:()=>{}},re={};function f(c){var y=re[c];if(y!==void 0)return y.exports;var p=re[c]={exports:{}};return te[c](p,p.exports,f),p.exports}f.m=te,f.x=()=>{var c=f.O(void 0,[9308,144,4942],()=>f(93986));return c=f.O(c),c},(()=>{var c=[];f.O=(y,p,P,e)=>{if(p){e=e||0;for(var S=c.length;S>0&&c[S-1][2]>e;S--)c[S]=c[S-1];c[S]=[p,P,e];return}for(var N=1/0,S=0;S<c.length;S++){for(var[p,P,e]=c[S],b=!0,O=0;O<p.length;O++)(e&!1||N>=e)&&Object.keys(f.O).every(j=>f.O[j](p[O]))?p.splice(O--,1):(b=!1,e<N&&(N=e));if(b){c.splice(S--,1);var B=P();B!==void 0&&(y=B)}}return y}})(),f.n=c=>{var y=c&&c.__esModule?()=>c.default:()=>c;return f.d(y,{a:y}),y},f.d=(c,y)=>{for(var p in y)f.o(y,p)&&!f.o(c,p)&&Object.defineProperty(c,p,{enumerable:!0,get:y[p]})},f.f={},f.e=c=>Promise.all(Object.keys(f.f).reduce((y,p)=>(f.f[p](c,y),y),[])),f.u=c=>"studio-"+c+".js",f.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),f.o=(c,y)=>Object.prototype.hasOwnProperty.call(c,y),(()=>{var c;f.g.importScripts&&(c=f.g.location+"");var y=f.g.document;if(!c&&y&&(y.currentScript&&(c=y.currentScript.src),!c)){var p=y.getElementsByTagName("script");if(p.length)for(var P=p.length-1;P>-1&&!c;)c=p[P--].src}if(!c)throw new Error("Automatic publicPath is not supported in this browser");c=c.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),f.p=c})(),(()=>{var c={5511:1},y=e=>{var[S,N,b]=e;for(var O in N)f.o(N,O)&&(f.m[O]=N[O]);for(b&&b(f);S.length;)c[S.pop()]=1;P(e)};f.f.i=(e,S)=>{c[e]||importScripts(f.p+f.u(e))};var p=self.webpackChunk=self.webpackChunk||[],P=p.push.bind(p);p.push=y})(),(()=>{var c=f.x;f.x=()=>Promise.all([9308,144,4942].map(f.e,f)).then(c)})();var rt=f.x()})();

//# sourceMappingURL=studio-5511.js.map